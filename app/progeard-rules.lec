# Основы языка Kotlin
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #stepanov_p@mirea.ru
  #
  #Список тем дисциплины
  #1.	Введение в язык Kotlin.
  #2.	Функциональные типы. Тип null. Принципы ООП. Классы. Теневые поля и свойства.
  #3.	Обобщенное программирование в Kotlin. Коллекции. Списки, множества.
  #4.	Ассоциативные массивы. Класс Map.
  #
  #
  #
  #
  #Тема 1. Введение в язык. ООП.
  #Kotlin — статически типизированный, объектно- ориентированный язык программирования, работающий поверх Java Virtual Machine и разрабатываемый компанией JetBrains. Также компилируется в JavaScript. Язык назван в честь острова Котлин в Финском заливе, на котором расположен город Кронштадт.
  #
  #
  #
  #https://kotlinlang.org/	https://jetbrains.com/
  #
  #Название и автор
  #
  #
  #
  #
  #
  #
  #Бреслав Андрей
  #
  #Официальная документация
  #
  #
  #https://kotlinlang.org/ - English version https://kotlinlang.ru/ - Русский перевод
  #
  #Особенности языка
  #	Молодой язык. Разрабатывается с 2010 года. На конференции Google I/O 2017 Kotlin стал основным языком для разработки Android- приложений;
  #	Язык со статической типизацией;
  #	Компилируется в байткод JVM или JS;
  #	Интероперабельность. Можно использовать все существующие Java-фреймворки и библиотеки;
  #	Язык прост для изучения;
  #	Открытый исходный код;
  #	Существует автоматическая конвертация Java- кода в Kotlin и наоборот;
  #	null-безопасность — исключения типа NullPointerException только в Java.
  #
  #Возможности языка
  #Kotlin — универсальный язык. Его можно использовать для создания мобильных, серверных, десктопных и веб-приложений, а также для разработки встраиваемых систем. Благодаря механизмам совместного использования кода можно легко создавать кросс-платформенные библиотеки и приложения.
  #
  #
  #
  #
  #
  #
  #Статистика. Типы приложений
  #
  #
  #
  #Статистика. Топ-15 библиотек.
  #
  #Статистика. Другие языки.
  #
  #
  #Статистика. Больше.
  #https://www.jetbrains.com/ru-ru/lp/devecosystem- 2021/kotlin/
  #
  #
  #Платформа Java
  #Платформа Java
  #Java Platform – программная среда, в которой работают приложения написанные на языке Java
  #Существуют для различных ОС (Windows, Linux, Mac OS) Включает в себя:
  #•	Java Virtual Machine (JVM) – виртуальная машина
  #Java – программа, интерпретирующая приложения Java;
  #•	Java API - библиотеки программных компонентов (классов и интерфейсов), реализующих стандартный функционал
  #
  #
  #
  #
  #
  #
  #
  #JRE, JDK и JVM
  #•	Java Runtime Environment (JRE) - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки.
  #Состоит из:
  #1)	виртуальной машины - Java Virtual Machine (JVM)
  #2)	библиотеки Java-классов.
  #
  #
  #
  #•	Java Development Kit (JDK) – бесплатно распространяемый компанией Oracle Corporation (ранее Sun Microsystems) комплект разработчика приложений на языке Java, включающий в себя компилятор javac, стандартные библиотеки классов Java.
  #
  #•	Java Virtual Machine (JVM) – виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java- программы компилятором javac.
  #
  #
  #Среды разработки
  #IDE – Integrated Development Environment: Среды разработки Kotlin
  #•	IntelliJ IDEA
  #http://www.jetbrains.com/idea/
  #
  #•	Eclipse IDE
  #http://www.eclipse.org
  #
  #•	Visual Studio Code
  #https://code.visualstudio.com/
  #
  #
  #
  #
  #Точка входа в программу
  #В Kotlin точкой входа в программу является функция main():
  #fun main() { println("Hello world!")
  #}
  #Другая форма main может принимать массив строк String.
  #fun main(args: Array<String>) { println(args.contentToString())
  #}
  #
  #Первое приложение в Idea
  #
  #
  #
  #Переменные, ключевое слово val
  #Неизменяемые (только для чтения) локальные переменные определяются с помощью ключевого слова val. Присвоить им значение можно только один раз.
  #val a: Int = 1			// Инициализация при объявлении val b = 1		// Тип Int определен автоматически val c: Int	// Указывать тип обязательно, если переменная не инициализирована сразу
  #c = 1	// Последующее присвоение
  #
  #
  #Переменные, ключевое слово val
  #Изменяемые переменные объявляются с помощью ключевого слова var:
  #var x = 5 // Тип Int определен автоматически x += 1
  #Вы можете объявлять глобальные переменные.
  #val PI = 3.14 var x = 0
  #fun incrementX() { x += 1
  #}
  #
  #
  #Вывод в стандартный поток
  #print() выводит свой аргумент в стандартный поток вывода:
  #print("Hello ") print("world!")
  #println() выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке:
  #println("Hello world!") println(42)
  #
  #
  #Функции
  #Функция принимает два аргумента Int и возвращает Int:
  #fun sum(a: Int, b: Int): Int { return a + b
  #}
  #В качестве тела функции может выступать выражение. Тогда тип возвращаемого значения определяется автоматически:
  #fun sum(a: Int, b: Int) = a + b
  #
  #
  #Функция без возвр. значения
  #Функция, не возвращающая никакого значения (void в Java):
  #fun printSum(a: Int, b: Int): Unit { println("сумма $a и $b равна ${a + b}")
  #}
  #Тип возвращаемого значения Unit может быть опущен:
  #fun printSum(a: Int, b: Int) { println("сумма $a и $b равна ${a + b}")
  #}
  #
  #Базовые типы
  #В Kotlin все компоненты программы, в том числе переменные, представляют объекты, которые имеют определенный тип данных.
  #Тип данных определяет, какой размер памяти может занимать объект данного типа и какие операции с ним можно производить.
  #
  #
  #
  #
  #
  #
  #
  #
  #Допустимо использование переменных внутри строк в формате
  #$name или ${name}:
  #fun main(args: Array<String>) { if (args.size == 0) return
  #print("Первый аргумент: ${args[0]}")
  #}
  #var a = 1
  #// просто имя переменной в шаблоне:
  #val s1 = "a равно $a"
  #a = 2
  #// произвольное выражение в шаблоне:
  #val s2 = "${s1.replace("равно", "было равно")}, но теперь равно $a"
  #/*
  #Результат работы программы:
  #a было равно 1, но теперь равно 2
  #*/
  #
  #Условные конструкции if
  #fun maxOf(a: Int, b: Int): Int { if (a > b) {
  #return a
  #} else {
  #return b
  #}
  #}
  #В Kotlin if может быть использован как выражение (т. е.
  #if ... else возвращает значение):
  #fun maxOf(a: Int, b: Int) = if (a > b) a else b
  #
  #when определяет условное выражение с несколькими "ветвями". Оно похоже на оператор switch, присутствующий в C-подобных языках.
  #when (x) {
  #1 -> print("x == 1")
  #2 -> print("x == 2")
  #else -> { // обратите внимание на блок print("x не равен ни 1, ни 2")
  #}
  #}
  #when последовательно сравнивает свой аргумент со всеми указанными значениями, пока не выполнится какое-либо из условий ветвей.
  #
  #when последовательно сравнивает свой аргумент со всеми
  #указанными значениями, пока не выполнится какое-либо из условий ветвей.
  #when можно использовать и как выражение, и как оператор. При использовании его в виде выражения значение первой ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора значения отдельных веток отбрасываются. В точности как if: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.
  #
  #Значение ветки else вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.
  #Ветка else является обязательной в следующих условиях:
  #•	when имеет объект типа Boolean, enum или их nullable-аналоги;
  #•	ветки when не охватывают все возможные случаи для этого объекта.
  #
  #
  #
  #
  #Цикл for обеспечивает перебор всех значений, поставляемых итератором. Он эквивалентен циклу foreach в таких языках, как C#:
  #for (item in collection) print(item) Телом цикла может быть блок кода: for (item: Int in ints) {
  #// ...
  #}
  #
  #
  #
  #
  #Цикл while
  #Тело циклов while и do-while выполняется до тех пор, пока их
  #условие выполняется. Разница между ними заключается во времени проверки условия:
  #while проверяет условие и, если оно истинно, выполняет тело, а затем возвращается к проверке условия;
  #do-while выполняет тело и только затем проверяет условие. Если оно выполняется, цикл повторяется. Таким образом, тело do-while выполняется по крайней мере один раз независимо от условия:
  #while (x > 0) { x--
  #}
  #do {
  #val y = retrieveData()
  #} while (y != null) // y здесь доступно!
  #
  #Проверка на вхождение числа в интервал с помощью
  #оператора in:
  #val x = 10 val y = 9
  #if (x in 1..y+1) { println("принадлежит диапазону")
  #}
  #Проверка значения на выход за пределы интервала:
  #val list = listOf("a", "b", "c") if (-1 !in 0..list.lastIndex) {
  #println("-1 не принадлежит диапазону")
  #}
  #if (list.size !in list.indices) {
  #println("размер списка также выходит за допустимый диапазон индексов списка")
  #}
  #
  #Перебор значений в заданном интервале:
  #for (x in 1..5) { print(x)
  #}
  #Или по арифметической прогрессии:
  #for (x in 1..10 step 2) { print(x)
  #}
  #println()
  #for (x in 9 downTo 0 step 3) { print(x)
  #}
  #
  #Итерация по коллекции.
  #for (item in items) { println(item)
  #}
  #Проверка, содержит ли коллекция данный объект, с помощью оператора in:
  #val items = setOf("яблоко", "банан", "киви") when {
  #"апельсин" in items -> println("сочно") "apple" in items -> println("яблоко тоже
  #подойдет")
  #}
  #
  #Использование лямбда-выражения для фильтрации и модификации коллекции:
  #val fruits = listOf("банан", "авокадо", "яблоко", "киви")
  #fruits
  #.filter { it.startsWith("а") }
  #.sortedBy { it }
  #.map { it.uppercase() }
  #.forEach { println(it) }
  #
  #Самым распространённым подводным камнем многих языков программирования, в том числе Java, является попытка произвести доступ к null значению. Это приводит к ошибке. В Java такая ошибка называется NullPointerException (сокр. "NPE").
  #Kotlin призван исключить ошибки подобного рода из нашего кода. NPE могут возникать только в случае:
  #•	Явного указания throw NullPointerException();
  #•	Использования оператора !! (описано ниже);
  #•	Эту ошибку вызвал внешний Java-код;
  #•	Есть какое-то несоответствие при инициализации данных (в конструкторе использована ссылка this на данные, которые не были ещё проинициализированы).
  #
  #Система типов Kotlin различает ссылки на те, которые могут иметь значение null (nullable ссылки) и те, которые таковыми быть не могут (non-null ссылки). Типы, которые допускают значение null, должны быть помечены вопросительным знаком, например:
  #var k:Int = 0 //null - недопустимое значение k var k1:Int? = null //null может быть значением k1
  #
  #Рассмотрим еще один пример: переменная часто используемого типа String не может быть null:
  #var a: String = "abc"
  #a = null // ошибка компиляции
  #Для того, чтобы разрешить null значение, мы можем объявить эту строковую переменную как String?:
  #var b: String? = "abc" b = null // ok
  #Теперь, при вызове метода с использованием переменной a, исключены какие-либо NPE. Вы спокойно можете писать:
  #val l = a.length
  #Но в случае, если вы захотите получить доступ к значению b, это будет небезопасно. Компилятор предупредит об ошибке:
  #
  #val l = b.length // ошибка: переменная b может быть null
  #Но нам по-прежнему надо получить доступ к этому свойству/значению, так? Есть несколько способов этого достичь.
  #Первый способ. Проверка на null. Вы можете явно проверить b на null значение и обработать два варианта по отдельности:
  #val l = if (b != null) b.length else -1 или
  #val l = b?.length ?: -1 (Elvis expression)
  #Вторым способом является оператор безопасного вызова ?.:
  #println(b?.length)
  #Этот код возвращает b.length в том, случае, если b не имеет значение null. Иначе он возвращает null. Типом этого выражения будет Int?.
  #
  #Основы языка Kotlin
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #stepanov_p@mirea.ru
  #
  #Тема 2. Функциональные типы. Принципы ООП. Классы. Теневые поля и свойства
  #
  #Массивы
  #Массивы в Котлин – тоже классы. При создании массива нужно
  #определить для обработки каких данных он предназначен.
  #В зависимости от ответа на этот вопрос массивы можно разделить на:
  #обобщенный класс Array<Тип элементов массива>;
  #специализированные классы для обработки числовых и символьных данных: IntArray, DoubleArray, CharArray, BoobleanArray и т.д. Массивы этой категории оптимизированы для работы с соответствующими типами. Данные классы не наследуют класс Array, хотя и обладают тем же набором методов и свойств, например:
  #//массив вещественных чисел var arrDouble : DoubleArray
  #//массив целых чисел var arrIntArray: Array<Int>
  #//массив строк с разрешенным null значением var arrStr: Array<String?>
  #
  #1.	Использовать библиотечную функцию arrayOf(), которой в качестве аргумента передаются элементы массива, т.е. выполнение arrayOf(1, 2, 3) создаёт массив [1, 2, 3]. Для оптимизированных массивов эта функция принимает вид: intArrayOf(), doubleArrayOf() и т.п.
  #2.	Использовать конструктор класса, который принимает размер массива и функцию, возвращающую начальное значение каждого элемента по его индексу:
  #
  #//создаем массив из трех целых чисел, заполненный нулями var array: IntArray = intArrayOf(0, 0, 0)
  #//создадим массив целых чисел из 10 элементов, заполенный нулями, при помощи конструктора
  #var arrayConstr = IntArray(10, {0})
  #// создадим массив типа Array со значениями ["0", "1", "4", "9", "16"] val asc = Array(5, { i -> (i * i).toString() })
  #
  #Функции в Kotlin
  #Особенности:
  #•	могут храниться в переменных и структурах данных;
  #•	передаваться как параметры других функций;
  #•	возвращаться как результат работы других функций Для этого используются:
  #•	функциональные типы;
  #•	лямбда-выражении
  #
  #Функции объявляются с помощью ключевого слова fun.
  #После слова fun указывается произвольное имя функции, затем, в скобках - перечень параметров. Если функция возвращает значение, то тип возвращаемого значения должен указываться после списка параметров через двоеточие.
  #fun double(x: Int): Int {
  #//...
  #}
  #
  #При вызове функции используется традиционный подход, т.е. указывается имя функции и в скобках перечисляются фактические параметры.
  #val result = double(2)
  #Если функция является частью класса (методом), то для её вызова используется знак точки после имени объекта:
  #Sample().foo() //создаёт экземпляр класса Sample и вызывает foo
  #
  #Параметры функции
  #Параметры функции записываются аналогично системе обозначений в языке Pascal - имя: тип. Параметры разделены запятыми. Каждый параметр должен быть явно указан.
  #fun powerOf(number: Int, exponent: Int): Int {
  #//…
  #}
  #Вы можете использовать завершающую запятую при объявлении параметров функции:
  #fun powerOf( number: Int,
  #exponent: Int, // завершающая запятая
  #) {
  #//…
  #}
  #
  #Параметры функции могут иметь значения по умолчанию, которые используются в случае, если аргумент функции не указан при её вызове. Это позволяет снизить уровень перегруженности кода по сравнению с другими языками.
  #fun read(b: Array, off: Int = 0, len: Int = b.size()) {
  #//...
  #}
  #Значения по умолчанию указываются после типа знаком =. Переопределённые методы всегда используют те же самые значения по умолчанию, что и их базовые методы. При переопределении методов со значениями по умолчанию эти параметры должны быть опущены:
  #open class A {
  #open fun foo(i: Int = 10) { ... }
  #}
  #class B : A() {
  #override fun foo(i: Int) { ... } // значение по умолчанию указать нельзя
  #
  #Если параметр со значением по умолчанию ставится перед обычным параметром, то значение по умолчанию можно использовать только при вызове функции с именованными аргументами (см. ниже):
  #fun foo(bar: Int = 0, baz: Int) {
  #//...
  #}
  #foo(baz = 1) // Используется значение по умолчанию bar = 0
  #Но если последний аргумент - это lambda-функция, то передача значений параметров по умолчанию не допускается:
  #
  #Если параметр со значением по умолчанию ставится перед обычным параметром, то значение по умолчанию можно использовать только при вызове функции с именованными аргументами (см. ниже):
  #fun foo(bar: Int = 0, baz: Int) {
  #//...
  #}
  #foo(baz = 1) // Используется значение по умолчанию bar = 0
  #Но если последний аргумент - это lambda-функция (см. далее в презентации), то передача значений параметров по умолчанию не допускается:
  #
  #fun foo(
  #bar: Int = 0, baz: Int = 1, qux: () -> Unit,
  #) {
  #/*...*/
  #}
  #// Использует значение по умолчанию baz = 1 foo(1) {
  #println("hello")
  #}
  #// Использует два значения по умолчанию bar = 0 и baz = 1 foo {
  #println("hello")
  #}
  #
  #Имена параметров могут быть явно указаны при вызове функций. Это
  #очень удобно, когда у функции большой список параметров, в том числе со значениями по умолчанию. Рассмотрим следующую функцию с большим количеством параметров:
  #fun reformat(str: String, normalizeCase: Boolean = true,
  #upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: Char = ' ') {
  #// ...
  #}
  #мы можем вызвать её, используя аргументы по умолчанию:
  #reformat(str)
  #Однако, при вызове этой функции без аргументов по умолчанию, получится что-то вроде
  #reformat(str, true, true, false, '_')
  #
  #С помощью именованных аргументов мы можем сделать код более
  #читабельным:
  #reformat(str, normalizeCase = true,
  #upperCaseFirstLetter = true, divideByCamelHumps = false, wordSeparator = '_'
  #)
  #Или, если нам не нужны все эти аргументы
  #reformat(str, wordSeparator = '_')
  #
  #Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово vararg. Например,
  #fun printStrings(vararg strings: String){ for(str in strings)
  #println(str)
  #}
  #fun main() {
  #printStrings("Maria", "Max", "Alex") printStrings("Kotlin", "JavaScript", "Java", "C#", "C++")
  #}
  #
  #Оператор * (spread operator) (не путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива:
  #fun changeNumbers(vararg numbers: Int, koef: Int){ for(number in numbers)
  #println(number * koef)
  #}
  #fun main() {
  #val nums = intArrayOf(1, 2, 3, 4) changeNumbers(*nums, koef=2)
  #}
  #Обратите внимание на звездочку перед nums при вызове функции: changeNumbers(*nums, koef=2). Без применения данного оператора мы столкнулись бы с ошибкой, поскольку параметры функции представляют не массив, а неопределенное количество значений типа Int.
  #
  #Если функция принимает несколько параметров, то обычно vararg-параметр является последним.
  #fun printUserGroup(count:Int, vararg users: String){ println("Count: $count")
  #for(user in users) println(user)
  #}
  #fun main() {
  #printUserGroup(3, "Ivan", “Petr", “Olga")
  #}
  #
  #Тип возвращаемого значения Unit
  #Если функция не возвращает никакого полезного значения, её возвращаемый тип - Unit. Это возвращаемое значение не нуждается в явном указании:
  #fun printHello(name: String?): Unit { if (name != null)
  #println("Hello ${name}") else
  #println("Hi there!")
  #// return Unit или return необязательны
  #}
  #Указание типа Unit в качестве возвращаемого значения не является обязательным. Код, написанный выше, совершенно идентичен с:
  #fun printHello(name: String?) {
  #...
  #}
  #
  #Однострочные функции
  #Если функция состоит из возвращения значения некоторого выражения, т.е тело функции - это одна строчка, то такие функции можно записать коротко. В короткой записи можно не писать тип возвращаемого значения и после списка параметров после знака равенства указать искомое выражение, например:
  #fun sum(a:Int, b:Int) = a + b
  #идентична функции:
  #fun sum(a:Int, b:Int):Int { return a + b
  #}
  #Однострочные функции лаконичнее и читабельнее.
  #
  #Если функция определена внутри другой функции (вложена), то такую функцию называют локальной.
  #При использовании локальной функции следует учитывать. что на нее распространяются общие правила видимости, что означает, что локальная функция видима только внутри той функции, в которой объявлена.
  #Рассмотрим пример. Пусть функция принимает на вход координаты трех точек и должна вычислить периметр треугольника, построенного на этих трех точках. Для простоты будем считать, что заданные точки образуют треугольник:
  #
  #fun perimetr(x1:Double, y1:Double, x2:Double, y2:Double, x3:Double, y3:Double):Double{
  #fun length(x1:Double, y1:Double, x2:Double, y2:Double) = Math.sqrt(Math.pow(x1-x2, 2.0) + Math.pow(y1 - y2, 2.0))
  #return length(x1, y1, x2, y2) + length(x2, y2, x3, y3) + length(x1, y1, x3, y3)
  #}
  #fun main() {
  #val input = Scanner(System.`in`) var x1 = input.nextDouble() var y1 = input.nextDouble() var x2 = input.nextDouble() var y2 = input.nextDouble() var x3 = input.nextDouble() var y3 = input.nextDouble()
  #println(perimetr(x1, y1, x2, y2, x3, y3))
  #}
  #В примере функция поиска длины отрезка по координатам концов - локальная. Попытка вызвать функцию length() за пределами функции perimeter() потерпит неудачу.
  #
  #Функции-члены
  #Функции-члены - это функции, объявленные внутри классов или объектов.
  #class Sample {
  #fun foo() { print("Foo") }
  #}
  #Функции-члены вызываются с использованием точки.
  #Sample().foo() // создаёт инстанс класса Sample и вызывает его функцию foo
  #
  #Функции-обобщения
  #Как и в Java, в Kotlin классы могут иметь типовые параметры.
  #class Box<T>(t: T) { var value = t
  #}
  #Для того чтобы создать объект такого класса, необходимо предоставить тип в качестве аргумента.
  #val box: Box<Int> = Box<Int>(1)
  #Но если параметры могут быть выведены из контекста (в аргументах конструктора или в некоторых других случаях), можно опустить указание типа:
  #val box = Box(1) // 1 имеет тип Int, поэтому компилятор отмечает для себя, что тип переменной box — Box<Int>
  #
  #Это функция, записанная в виде выражения, и которую можно передавать как аргумент в другие функции.
  #Фактически лямбды представляют сокращенную запись функций. При этом лямбды могут передаваться в качестве параметра в функции.
  #Лямбда-выражения оборачиваются в фигурные скобки:
  #{ println("Hello")}
  #и может быть как присвоена переменной, так и передана аргументом в другую функцию. Рассмотрим пример с присвоением лямбда- выражения переменной:
  #// присваиваем лямбда-выражение переменной val hello = {println("Hello")}
  #// обращаемся к переменной как к функции hello() к переменной как к функции
  #
  #Лямбда-выражение, как и обычная функция может иметь входные
  #параметры и возвращаемое значение. Входные параметры пишутся сразу после открывающей фигурной скобки, а результат после стрелки. Например, напишем функцию умножения двух чисел как лямбда:
  #// присваиваем лямбда-выражение переменной val sum = {a:Int, b:Int -> a + b}
  #// обращаемся к переменной как к функции sum(5, 8)
  #Лямбда может содержать несколько команд. В таком случае результатом считается значение последнего выражения. Например:
  #fun main() {
  #var res = {x:Int, y:Int -> var result = 2 * x + y
  #result //возвращаемое из лямбда значение
  #}
  #println(res(12, 15))
  #
  #Если в лямбда выражении убрать тело, имена параметров и оставить
  #только типы параметров и тип возвращаемого значения, то мы получим запись, которая и называется типом лямбда-выражения.
  #Например, типом лямбда-выражений из предыдущих примеров будет:
  #(Int, Int) -> Int.
  #Таким образом в типе лямбда-выражения мы указываем какие типы параметров и в каком порядке принимает лямбда и какой тип возвращает как результат.
  #Если лямбда-выражение не возвращает значения, то типом будет Unit, например: (Int, Int) -> Unit, что означает, что параметрами являются два целых числа, а результат не возвращается.
  #
  #
  #Для передачи лямбда-выражения в функцию, необходимо определить у
  #функции параметр, тип которого соответствует типу лямбда-выражения. Такие функции (принимающие параметрами лямбда-выражения) в Котлин называются функциями высших порядков.
  #Рассмотрим пример:
  #fun action (n1: Int, n2: Int, operation: (Int, Int)-> Int){ val result = operation(n1, n2)
  #println(result)
  #}
  #fun main(){
  #action(4, 5, {x:Int, y:Int -> x * y}) var sum = {x:Int, y:Int -> x + y} action(6, 7, sum)
  #}
  #
  #В этом примере функция action() третьим параметром может получить
  #любую функцию, соответствующую шаблону (типу)
  #(Int, Int) -> Int.
  #Из тела функции видно, что полученная под именем operation функция применяется к первым параметрам action().
  #При вызове action() можно как непосредственно написать лямбда- выражение третьим параметром, так и определить его заранее и передать функции имя соответствующей переменной.
  #
  #Выглядят также, как и обычные за одним исключением: они не имеют
  #имени. Анонимные функции по смыслу похожи на лямбда-выражение и применяются практически также, но есть важно отличие: анонимные функции могут использовать ключевое слово return и возвращать результат из любого блока своего кода, например:
  #fun main() {
  #// анонимная функция как параметр operation(9,5, fun(x: Int, y: Int): Int { return x + y } ) operation(9,5, fun(x: Int, y: Int): Int = x - y)
  #}
  #fun operation(x: Int, y: Int, op: (Int, Int) ->Int ){ val result = op(x, y)
  #println(result)
  #}
  #
  #fun main() {
  #// возвращение анонимной функции из функции val action1 = selectAction(1)
  #val result1 = action1(4, 5) println(result1)	// 9
  #val action2 = selectAction(2) val result2 = action2(4, 5) println(result2)	// 20
  #}
  #fun selectAction(key: Int): (Int, Int) -> Int { when(key){
  #1	-> return fun(x: Int, y: Int): Int = x + y
  #2	-> return fun(x: Int, y: Int): Int = x * y else -> return fun(x: Int, y: Int): Int = 0
  #}
  #}
  #
  #В Котлин структуры вида (Int, Int) -> Double используются довольно часто и называются функциональными выражениями.
  #Kotlin использует семейство функциональных типов, таких как (Int) -> String, для объявлений, которые являются частью функций: val onClick: () -> Unit = ....
  #Эти типы имеют специальные обозначения, которые соответствуют сигнатурам функций, то есть их параметрам и возвращаемым значениям:
  #
  #1.	У всех функциональных типов есть список с типами параметров и возвращаемый тип. Например: `(A, B) -> C` обозначает тип, который предоставляет функции два принятых аргумента типа A и B, а также возвращает значение типа C. Список с типами параметров может быть пустым, как, например, в () -> A. Возвращаемый тип Unit (необходимый, если функция ничего не возвращает) не может быть опущен.
  #
  #2.	У функциональных типов может быть дополнительный тип - получатель (receiver), который указывается в объявлении перед точкой: тип A.(B) -> C описывает функции, которые могут быть вызваны для объекта-получателя A с параметром B и возвращаемым значением C, например:
  #val repeatFun: String.(Int) -> String = { times -> this.repeat(times) } println(repeatFun("Test",2)) // TestTest
  #
  #Основные принципы ООП
  #С точки зрения ООП каждую сущность можно описать как совокупность:
  #полей класса — переменных для хранения данных, описывающих класс. Это те свойства, параметры, характеристики, которые описывают состояние сущности;
  #методов класса — функций для работы с полями класса. Это те действия, которые можно производить с этой сущностью.
  #В основе ООП лежат три принципа:
  #1.	инкапсуляция (от слова encapsulation или incapsulation) — объединение данных и процедур для работы с этими данными в единое целое;
  #2.	наследование (от слова inheritance) — средство получения новых классов из существующих;
  #3.	полиморфизм (от слова polymorphism) — создание общего интерфейса для группы близких по смыслу действий.
  #
  #Инкапсуляция (encapsulation) — это механизм, который объединяет данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. Инкапсуляция означает, что методы и поля класса рассматриваются в качестве единого целого.
  #В связи с чем инкапсуляция требует соблюдения следующих принципов:
  #•	все характеристики, которые описывают состояние объекта, должны храниться в его полях;
  #•	все действия, которые можно осуществлять с объектом, должны описываться его методами;
  #•	нельзя извне менять поля объекта.
  #Обратиться к полям объекта можно только при помощи методов.
  #
  #Например, объект реального мира — наручные часы. Для того чтобы ими пользоваться, нужно уметь их заводить и знать, какое время они показывают. Пользователю не нужно знать, как работает часовой механизм.
  #Если пользователю позволить менять местами шестеренки, то часы он, скорее всего, сломает.
  #С другой стороны, если часовщик изменит принцип внутренней работы наручных часов, пользователь этого не почувствует — в его распоряжении все также останется циферблат со стрелками, которые показывают время.
  #Наручные часы в этом примере (как и инкапсулированный объект) — это «черный ящик» для пользователя. Таким образом, ООП дает возможность пользователю работать с объектами, не задумываясь об их внутреннем устройстве.
  #
  #Наследование
  #Наследование — механизм языка, позволяющий описать новый класс на основе уже существующего (родительского, базового) класса. Класс- потомок может добавить собственные методы и свойства, а также пользоваться родительскими методами и свойствами. Позволяет строить иерархии классов.
  #Некоторые объекты являются частным случаем более общей категории объектов. Например, вы разрабатываете компьютерную игру. В игре должны быть предусмотрены различные персонажи: люди, роботы, волшебники и т. д. С одной стороны, каждый из объектов обладает отдельными характеристиками. С другой стороны, они имеют общие свойства (например, поля «Имя», «Здоровье», «Броня»).
  #
  #Хотелось бы иметь возможность рассматривать их как объект общей категории «Юнит», так как для всех этих объектов применимы общие действия (например, «Атаковать» и «Защищаться»), но при этом уметь хранить для каждого в отдельности его особенные свойства и применять к ним присущие каждому специфические методы.
  #
  #Полиморфизм
  #Полиморфизм — это реализация одинакового по смыслу действия различным способом в зависимости от типа объекта.
  #Например, в предыдущем разделе мы рассмотрели метод «Атаковать», общий для всех юнитов компьютерной игры.
  #Несмотря на то что действие общее, каждый наследник реализует его по-своему. Например, человек использует для атаки меч, робот использует лазер, а волшебник — магическое заклинание. В этом заключается идея полиморфного поведения наследников по отношению к родительскому объекту.
  #При вызове метода «Атаковать» родительского класса для объектов разного типа компилятор сам понимает, какой метод нужно использовать.
  #
  #Объявление классов
  #Классы в Kotlin объявляются с помощью использования ключевого слова class:
  #class Invoice {
  #}
  #Объявление класса состоит из имени класса, заголовка (указания типов его параметров, основного конструктора и т.п) и тела класса, заключённого в фигурные скобки. И заголовок, и тело класса являются необязательными составляющими: если у класса нет тела, фигурные скобки могут быть опущены.
  #class Empty
  #
  #Первичный конструктор
  #Классы в Kotlin могут иметь один первичный конструктор (primary constructor) и один или несколько вторичных конструкторов (secondary constructor).
  #Первичный конструктор является частью заголовка класса и определяется сразу после имени класса:
  #class Car constructor(_name: String){
  #}
  #При этом первичный конструктор в отличие от функций не определяет никаких действий, он только может принимать данные извне через параметры. Если первичный конструктор не имеет никаких аннотаций или модификаторов доступа, как в данном случае, то ключевое слово constructor можно опустить:
  #class Car(_name: String){
  #}
  #
  #Блок инициализации
  #Что делать с полученными через конструктор данными? Мы их можем
  #использовать для инициализации свойств класса. Для этого применяются блоки инициализаторов:
  #class Car(_name: String){ val name: String
  #init{
  #name = _name
  #}
  #}
  #В классе Car определено свойство name, которое хранит наименование автомобиля. Чтобы передать эту свойству значение параметра _name из первичного конструктора, применяется блок инициализатора. Блок инициализатора определяется после ключевого слова init. Цель инициализатора состоит в инициализации объекта при его создании. Стоит отметить, что здесь свойству name не задается начальное значение, потому это свойство в любом случае будет инициализировано в блоке инициализатора, и при создании объекта оно в любом случае получит значение.
  #
  #Создание объекта
  #fun main() {
  #val bmw = Car(“BMW") val volvo = Car(“Volvo") val toyota = Car(“Toyota") println(bmw.name) println(volvo.name) println(toyota.name)
  #}
  #class Car(_name: String){ val name: String
  #init{
  #name = _name
  #}
  #}
  #
  #Вторичный конструктор
  #Класс также может определять вторичные конструкторы. Они применяются в основном, чтобы определить дополнительные параметры, через которые можно передавать данные для инициализации объекта.
  #Вторичные конструкторы определяются в теле класса. Если для класса определен первичный конструктор, то вторичный конструктор должен вызывать первичный с помощью ключевого слова this:
  #class Car(_name: String){ val name: String = _name var power: Int = 0
  #constructor(_name: String, _power: Int) : this(_name) { power = _power
  #}
  #}
  #
  #Создание объекта 2
  #fun main() {
  #val bmw = Car(“BMW")
  #val volvo = Car(“Volvo“,150)
  #println("Name: ${bmw.name} Power: ${bmw.power}") println("Name: ${volvo.name} Power: ${volvo.power}")
  #}
  #class Car(_name: String){ val name: String = _name var power: Int = 0
  #constructor(_name: String, _power: Int) : this(_name) { power = _power
  #}
  #}
  #При необходимости мы можем определять и больше вторичных конструкторов.
  #
  #В Java считается, что публичные поля использовать плохо, поэтому в Kotlin полей нет, но есть свойства. Свойство можно объявить на уровне файла или внутри класса. При компиляции в байт-код, для него автоматически сгенерируются геттер и сеттер. То есть с точки зрения Java, это будет приватное поле. Также геттеры и сеттеры
  #можно переопределить:
  #class Test {
  #val className: String get() = ”Test class”
  #}
  #Такой подход лучше публичных полей, потому что, если вдруг понадобится добавить в геттер или сеттер более сложную логику (логирование, кеширование, и т.д.), то не придется менять код в тех местах, где было обращение к свойству. То есть с точки зрения использование это всё еще будет выглядеть как просто обращение к полю класса.
  #
  #Классы в Kotlin могут иметь свойства: изменяемые (mutable) и
  #неизменяемые (read-only) — var и val соответственно.
  #public class Address {
  #public var name: String = ... public var street: String = ... public var city: String = ... public var state: String? = ... public var zip: String = ...
  #}
  #Для того, чтобы воспользоваться свойством, мы просто обращаемся к его имени (как в Java):
  #fun copyAddress(address: Address): Address {
  #val result = Address() // нет никакого слова new result.name = address.name // вызов методов доступа result.street = address.street
  #// ...
  #return result
  #}
  #
  #Полный синтаксис объявления свойства выглядит так:
  #var <propertyName>[: <PropertyType>] [= <property_initializer>] [<getter>]
  #[<setter>]
  #Инициализатор property_initializer, геттер и сеттер можно не указывать. Также необязательно указывать тип свойства, если он может быть выведен из инициализатора или из возвращаемого типа геттера.
  #var allByDefault: Int? // ошибка: необходима явная инициализация,
  #// предусмотрены стандартные геттер и сеттер var initialized = 1 // имеет тип Int, стандартный геттер и сеттер
  #
  #Синтаксис объявления констант имеет два отличия от синтаксиса объявления изменяемых переменных: во-первых, объявление константы начинается с ключевого слова val вместо var, а во-вторых, объявление сеттера запрещено:
  #val simple: Int? // имеет тип Int, стандартный геттер,
  #// должен быть инициализирован в конструкторе val inferredType = 1 // имеет тип Int и стандартный геттер
  #Мы можем самостоятельно описать методы доступа, как и обычные функции, прямо при объявлении свойств. Например, пользовательский геттер:
  #val isEmpty: Boolean get() = this.size == 0
  #
  #Теневые поля
  #Классы в Kotlin могут иметь свойства и для них неявно реализуются методы get и set. А сама переменная, в которой находится значение свойства, называется теневое поле (backing field). Однако, иногда, при использовании пользовательских методов доступа, необходимо иметь доступ к теневому полю. Для этих целей Kotlin предоставляет автоматическое теневое поле, к которому можно обратиться с помощью идентификатора field:
  #
  #var counter = 0 set(value) {
  #if (value >= 0) field = value // значение при инициализации записывается прямиком в backing field
  #}
  #Идентификатор field может быть использован только в методах доступа к свойству.
  #
  #Теневые свойства
  #Если вы хотите предпринять что-то такое, что выходит за рамки предыдущего примера неявного теневого поля, вы всегда можете использовать теневое свойство (backing property):
  #private var _table: Map<String, Int>? = null public val table: Map<String, Int>
  #get() {
  #if (_table == null) {
  #_table = HashMap() // параметры типа вычисляются автоматически
  #// (ориг.: "Type parameters are inferred")
  #}
  #return _table ?: throw AssertionError("Set to null by another thread")
  #}
  #Такой подход ничем не отличается от подхода в Java, так как доступ к приватным свойствам со стандартными геттерами и сеттерами оптимизируется таким образом, что вызов функции не происходит.
  #
  #Модификаторы visibility (видимости) бывают public, private, protected и internal (package-private).
  #По умолчанию видимость всегда public.
  #private: классы, объекты, интерфейсы, а также функции и свойства, определенные вне класса, с этим модификатором видны только в том файле, в котором они определены. Члены класса с этим модификатором видны только в рамках своего класса
  #protected: члены класса с этим модификатором видны в классе, в котором они определены, и в классах-наследниках
  #
  #internal: классы, объекты, интерфейсы, функции, свойства, конструкторы с этим модификатором видны в любой части модуля, в котором они определены. Модуль представляет набор файлов Kotlin, скомпилированных вместе в одну структурную единицу. Это может быть модуль IntelliJ IDEA или проект Maven
  #public: классы, функции, свойства, объекты, интерфейсы с этим модификатором видны в любой части программы. (При этом если функции или классы с этим модификатором определены в другом пакете их все равно нужно импортировать)
  #Для установки уровня видимости модификатор ставится перед ключевыми словами var/val/fun в самом начале определения свойства или функции.
  #
  #Modality-модификаторы бывают abstract, open и final.
  #По умолчанию все классы, свойства и функции имеют модификатор final (кроме интерфейсов и их содержимого). Это значит, что по умолчанию нельзя наследоваться от не абстрактных классов и переопределять методы. Чтобы это можно быть сделать, надо использовать модификатор open. Модификатор final для свойств означает, что их нельзя переопределить в классах наследниках (чтобы свойство было иммутабельным, его надо объявить ключевым словом val).
  #
  #class FinalBaseClass { ... }
  #open class OpenBaseClass { var x: Int = 42
  #fun finalFoo() { ... }
  #open fun openFoo() { ... }
  #}
  #class MyClass : FinalBaseClass() { ... } // Ошибка компиляции, наследование от финального класса
  #class MyClass : OpenBaseClass() {
  #override var x: Int = 43 // Ошибка компиляции, переопределение финальной проперти
  #override fun finalFoo() { ... } // Ошибка компиляции, переопределение финальной функции
  #override fun openFoo() { ... } // OK
  #}
  #
  #Модификаторы
  #open class Person(protected val name:String, private val age: Int) {
  #protected fun printPerson(){ printName()
  #printAge()
  #}
  #private fun printName(){ println("Name: $name")
  #}
  #private fun printAge(){ println("Age: $age")
  #}
  #}
  #class Employee(name:String, age: Int) : Person(name, age){ fun printEmployee(){
  #println("Employee $name. Full information:") printPerson()
  #// printName() // нельзя - printName - private
  #// println("Age: $age")	// нельзя age - private
  #}
  #
  #Data классы
  #Бывает необходимость завести класс, который будет просто хранить
  #какие-то значения. При этом для него надо писать конструктор, equals, hashCode, toString, и при добавлении новых свойств, не забывать это всё менять. Для удобства, в Котлин, были введены data-классы, которые делают это автоматически:
  #// Котлин:
  #data class Client(val name: String, val email: String)
  #// Java:
  #public class Client {
  #private final String name; private final String email;
  #public Client(String name, String email) { this.name = name;
  #this.email = email;
  #}
  #public String getName() { return name; } public String getEmail() { return email; } public boolean equals(Client other) { ... }
  #…
  #
  #Основы языка Kotlin
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #stepanov_p@mirea.ru
  #
  #Тема 3. Обобщенное программирование в Kotlin. Коллекции. Списки, множества.
  #
  #Классы, определенные с модификатором abstract. Отличительной особенностью
  #абстрактных классов является то, что мы не можем создать объект подобного класса. Например:
  #abstract class Human(val name: String)
  #Абстрактный класс, как и обычный, может иметь свойства, функции, конструкторы, но создать его объект напрямую вызвав его конструктор мы не можем:
  #val olga: Human	// норм, просто определение переменной
  #val maria: Human = Human(“Maria")	// ! ошибка, создать объект нельзя
  #Такой класс мы можем только унаследовать:
  #abstract class Human(val name: String){ fun hello(){
  #println("My name is $name")
  #}
  #}
  #class Person(name: String): Human(name)
  #
  #Абстрактные классы могут иметь абстрактные методы и свойства. Это такие функции и свойства, которые определяются с ключевым словом abstract. Абстрактные методы не содержат реализацию, то есть у них нет тела. А для абстрактных свойств не указывается значение. При этом абстрактные методы и свойства можно определить только в абстрактных классах:
  #abstract class Human(val name: String) { abstract var age: Int
  #abstract fun hello()
  #}
  #class Person(name: String): Human(name) { override var age : Int = 1
  #override fun hello(){ println("My name is $name")
  #}
  #}
  #
  #Интерфейсы
  #Интерфейсы в Kotlin могут содержать объявления абстрактных методов, а также
  #методы с реализацией. Главное отличие интерфейсов от абстрактных классов заключается в невозможности хранения переменных экземпляров. Они могут иметь свойства, но те должны быть либо абстрактными, либо предоставлять реализацию методов доступа, например:
  #interface MyInterface { fun test1()
  #fun test2() {
  #// необязательное тело
  #}
  #}
  #Класс или объект могут реализовать любое количество интерфейсов:
  #class MyClass: MyInterface { override fun test1() {
  #// тело
  #}
  #}
  #
  #Интерфейсы, свойства
  #Cвойство, объявленное в интерфейсе, может быть либо абстрактным, либо иметь свою реализацию методов доступа. Свойства в интерфейсах не могут иметь теневых полей, соответственно, методы доступа к таким свойствам не могут обращаться к теневым полям, например:
  #interface MyInterface {
  #val prop: Int // абстрактное свойство val propertyWithImplementation: String
  #get() = "foo" fun foo()
  #print(prop)
  #}
  #}
  #class MyClass : MyInterface { override val prop: Int = 29
  #}
  #
  #Наследование интерфейсов
  #Интерфейс может быть производным от других интерфейсов, что означает, что он может как предоставлять реализации для их членов, так и объявлять новые функции и свойства:
  #interface Named { val name: String
  #}
  #interface Person : Named { val firstName: String val lastName: String
  #override val name: String get() = "$firstName $lastName"
  #}
  #data class Worker(
  #// реализация 'name' не требуется override val firstName: String, override val lastName: String,
  #val position: String
  #) : Person
  #
  #Интерфейсы только с одним абстрактным методом называются функциональными интерфейсами или Single Abstract Method (SAM) интерфейсами. Функциональный интерфейс может иметь несколько неабстрактных членов, но только один абстрактный.
  #Для функциональных интерфейсов вы можете использовать SAM преобразования, которые помогают сделать ваш код более лаконичным и читаемым,
  #используя лямбда-выражения.
  #Вместо создания класса, который реализует функциональный интерфейс вручную, вы можете использовать лямбда-выражения. Вместе с SAM преобразованиями Kotlin может преобразовывать лямбда-выражения, сигнатура которых совпадает с сигнатурой единственного метода интерфейса, в код, динамически создающий экземпляр реализации интерфейса.
  #
  #fun main() {
  #val calc = object: Calc {
  #override fun calc(a: Int, b: Int): Int { return a+b
  #}
  #}
  #val calc2 = Calc { a, b -> a+b }
  #}
  #fun interface Calc {
  #fun calc(a: Int, b: Int): Int
  #}
  #
  #В Kotlin классы и интерфейсы могут быть определены в других классах и интерфейсах. Такие классы (вложенные классы или nested classes) обычно выполняют какую-то вспомогательную роль, а определение их внутри класса или интерфейса позволяет разместить их как можно ближе к тому месту, где они непосредственно используются:
  #class Car{
  #class Wheel(val material: String, val type: String) { fun printInfo(){
  #println("material: $material type: $type")
  #}
  #}
  #}
  #fun main() {
  #val obj = Car.Wheel("Leather", "Sport") obj.printInfo()
  #}
  #
  #Чтобы ограничить область применения вложенного класса только внешним классом, то следует определить вложенный класс с модификатором private:
  #class Car(m: String, t: String) { private val wheel = Wheel(m, t)
  #private class Wheel(val material: String, val type: String)
  #fun printInfo(){
  #println("material: ${wheel.material} type: ${wheel.type}")
  #}
  #}
  #fun main() {
  #val obj = Car("Leather", "Classic") obj.printInfo()
  #}
  #
  #Вложенный класс по умолчанию не имеет доступа к свойствам и функциям внешнего класса. Например, в следующем случае при попытке обратиться к свойству внешнего класса мы получим ошибку:
  #class BankAccount(private var sum: Int) { fun display(){
  #println("sum = $sum")
  #}
  #class Transaction{ fun pay(s: Int){
  #sum -= s // <- ошибка display() // <- ошибка
  #}
  #}
  #}
  #
  #Чтобы вложенный класс мог иметь доступ к свойствам и функциям внешнего
  #класса, необходимо определить вложенный класс с ключевым словом inner. Такой класс еще называют внутренним классом (inner class), чтобы отличать от обычных вложенных классов:
  #fun main() {
  #val acc = BankAccount(3400); acc.Transaction().pay(2500)
  #}
  #class BankAccount(private var sum: Int){ fun display(){
  #println("sum = $sum")
  #}
  #inner class Transaction{ fun pay(s: Int){
  #sum -= s display()
  #}
  #}
  #
  #Enums или перечисления представляют тип данных, который позволяет определить набор логически связанных констант. Для определения перечисления применяются ключевые слова enum class. Например, определим перечисление:
  #enum class Day{
  #MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
  #}
  #fun main() {
  #val day: Day = Day.FRIDAY println(day)	// FRIDAY println(Day.MONDAY)	// MONDAY
  #}
  #
  #Классы перечислений как и обычные классы также могут иметь конструктор.
  #Кроме того, для констант перечисления также может вызываться конструктор для их инициализации.
  #enum class Day(val value: Int) { MONDAY(1), TUESDAY(2), WEDNESDAY(3),
  #THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(100500)
  #}
  #fun main() {
  #val day: Day = Day.FRIDAY println(day.value)	// 5
  #println(Day.MONDAY.value) // 1
  #}
  #Через конструктор определяется свойство value. Соответственно при определении констант перечисления необходимо каждую из этих констант инициализировать, передав значение для свойства value.
  #
  #Также перечисления могут определять свойства и функции. Но если класс
  #перечисления содержит свойства или функции, то константы должны быть отделены точкой с запятой:
  #enum class Day(val value: Int) { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);
  #fun getDuration(day: Day): Int{ return value - day.value;
  #}
  #}
  #fun main() {
  #val day1: Day = Day.FRIDAY val day2: Day = Day.MONDAY
  #println(day1.getDuration(day2))	// 4
  #}
  #
  #Делегирование
  #Делегирование один из паттернов ООП, который позволяет одному объекту
  #делегировать/перенаправить все запросы другому объекту. Является хорошей альтернативой наследованию, и Kotlin поддерживает его нативно, освобождая вас от необходимости написания шаблонного кода, например:
  #
  #
  #interface Base { fun print()
  #}
  #class BaseImpl(val x: Int) : Base { override fun print() { print(x) }
  #}
  #class Derived(b: Base) : Base by b fun main() {
  #val b = BaseImpl(10) Derived(b).print()
  #}
  #
  #Ключевое слово by в оглавлении Derived, указывает, что b будет храниться внутри экземпляра Derived, и компилятор сгенерирует все методы из Base, которые при вызове будут переданы объекту b.
  #Для чего? Изменяем поведение конкретного экземпляра объекта вместо создания нового класса путём наследования.
  #
  #Иногда необходимо создать класс только для одного объекта. В этом случае мы,
  #конечно, можем, как и обычно, определить класс и затем создать объект этого класса. Но Kotlin для таких ситуаций предоставлять возможность определить объект анонимного класса.
  #Анонимные классы не используют ключевое слово class для определения. Они не имеют имени, но как и обычные классы могут наследовать другие классы или применять интерфейсы. Объекты анонимных классов называют анонимными объектами.
  #Для определения анонимного объекта применяется ключевое слово object:
  #
  #fun main() {
  #val barsik = object { val name = “Barsik" var age = 2
  #fun sayMau(){ println(“Mau, mau…")
  #}
  #}
  #println("Name: ${barsik.name} Age: ${barsik.age}") barsik.sayMau()
  #}
  #
  #Анонимный объект может содержать свойства, функции. И далее по имени переменной мы можем обращаться к свойствам и функциям этого объекта.
  #
  #Анонимный объект как аргумент
  #Анонимный объект может передаваться в качестве аргумента в вызов функции:
  #
  #
  #fun main() { printMessage(
  #object : Student("Oleg"){ val age = 18
  #override fun printInfo(){ println("Name = $name, age = $age")
  #}
  #})
  #}
  #fun printMessage(student: Student){ student.printInfo()
  #
  #
  #
  #
  #
  #
  #Т.к. класс анонимного объекта наследуется от класса Student, мы можем передавать этот анонимный объект параметру функции, который имеет тип Student.
  #
  #}
  #open class Student(val name: String){
  #open fun printInfo() = println("Name = $name")
  #}
  #
  #Анонимный объект как результат
  #Функция может возвращать анонимный объект:
  #fun main() {
  #val tom = createAnimal("Tom", 3) tom.printInfo()
  #}
  #private fun createAnimal(_name: String, _age: Int) = object { val name = _name
  #val age = _age
  #fun printInfo() = println("Name = $name, age = $age")
  #}
  #Чтобы мы могли обращаться к свойствам и функциям анонимного объекта, функция, которая возвращает этот объект, должна быть приватной, как в примере выше.
  #
  #Generics
  #Generics или обобщения - способ, посредством которого функции и классы могут использовать объекты, типы которых на момент их определения неизвестны.
  #Обобщения позволяют определять шаблоны, в которые можно подставлять различные типы, например:
  #
  #
  #class SomeGenericClass <T> { private var mSomeField: T? = null fun setSomeField(someData: T?) {
  #mSomeField = someData
  #}
  #fun getSomeField(): T? { return mSomeField
  #
  #
  #K - не любой класс, а только удовлетворяющий условию (в данном случае
  #— Number или класс, его наследующий).
  #
  #}
  #}
  #fun <K : Number> makeSomething(someData : K) : K { var localData = someData
  #//...
  #return localData
  #}
  #
  #Generics в классах
  #class Student<T>(val id: T, val name: String)
  #Класс Student использует параметр T. Параметры указываются после имени класса в угловых скобках. Этот параметр будет представлять некоторый тип данных, который на момент определения класса неизвестен.
  #В первичном конструкторе определяется свойство id, которое представляет идентификатор. Оно представляет тип, который передается через параметр T. На момент определения класса Student мы не знаем, что это будет за тип.
  #Само название параметра произвольное (если оно не совпадает с ключевыми словами). Но нередко используется T как сокращение от слова type.
  #fun main() {
  #val petr: Student<Int> = Student(123, “Petr")
  #val ivan: Student<String> = Student(“I734", “Ivan") println("${petr.id} - ${petr.name}")
  #println("${ivan.id} - ${ivan.name}")
  #}
  #
  #Generics в функциях
  #fun main() {
  #val maria = Student(“tt12", “Maria") tom.checkId(“tt12")	// The same tom.checkId(“tt345")		// Different
  #}
  #class Student<T>(val id: T, val name: String){ fun checkId(_id: T){
  #if(id == _id){ println("The same")
  #}
  #else{
  #println("Different")
  #}
  #}
  #}
  #
  #Generics, несколько параметров
  #В данном случае класс Word применяет два параметра - K и V. При создании объекта Word эти параметры могут представлять один и тот же тип, а могут представлять и разные типы:
  #fun main() {
  #var word1: Word<String, String> = Word("one", "один") var word2: Word<String, Int> = Word("two", 2)
  #println("${word1.source} - ${word1.target}")	// one - один println("${word2.source} - ${word2.target}")	// two - 2
  #}
  #class Word<K, V>(val source: K, var target: V)
  #
  #Generic constraints
  #Ограничения обобщений (generic constraints) ограничивают набор типов,
  #которые могут передаваться вместо параметра.
  #fun <T> getBiggest(a: T, b: T): T{ if(a > b) return a	// ! Ошибка else return b
  #}
  #На этапе компиляции будет ошибка, потому что вместо параметра типа T могут передаваться самые различные типы, в том числе такие, которые не поддерживают операцию сравнения, поэтому:
  #
  #
  #fun main() {
  #val result1 = getBiggest(1, 2) println(result1)
  #val result2 = getBiggest("Ivan", "Maria") println(result2)
  #}
  #fun <T: Comparable<T>> getBiggest(a: T, b: T): T { return if(a > b) a else b
  #
  #Однако все типы, которые по умолчанию поддерживают эту операцию сравнения, применяют интерфейс Comparable.
  #
  #}
  #
  #Операторный блок
  #Операторным блоком (scope) во многих языках программирования
  #называется фрагмент программы внутри которого определяются переменные. Типичными примерами блоков являются цикл и определение функции:
  #for (w in words) {
  #if (w.length in lengths) { print(w)
  #}
  #}
  #fun area(a: Int = 0, b: Int) { print("area: ${a * b}")
  #}
  #Переменные, определённые внутри таких блоков недоступны извне, поэтому часто операторный блок называют ещё областью видимости (scope).
  #Обратите внимание, что лямбда-выражения тоже являются операторным блоком. В языке Kotlin определены пять функций для операций над операторным блоком в целом.
  #
  #Функция let()
  #Может быть вызвана у любого объекта, в качестве параметра в фигурных
  #скобках она принимает лямбда-выражение, которое будет применено к нему. При этом имя переменной в которой будет храниться ссылка на этот объект можно задать явно или опустить (тогда переменная будет называться it)
  #val name = "Petya" name.let {
  #n ->	println("$n")
  #}
  #Применение let() позволяет более гибко работать с nullable-типами. Если объект, у которого вызвана let() содержит null, то лямбда-выражение вызвано не будет.
  #val age: Int? = null age?.let {
  #println("Your age is $it")
  #}
  #
  #Функция apply()
  #Она позволяет упростить обращения к объектам с вложенной структурой и сократить объем кода. Часто в создании мобильных приложений приходится обращаться ко вложенным полям и методам, например:
  #val intent = Intent(this, SecondActivity::class.java) intent.putExtra("name", “Ivan") intent.putExtra("age", 21) intent.putExtra("password", "Bender789")
  #Последние 3 строки можно более лаконично переписать, применив функцию
  #apply()
  #intent.apply() { putExtra("name", "Vasya") putExtra("age", 21)
  #putExtra("password", "Bender789")
  #}
  #
  #Функция run()
  #Функции let() и apply() сочетается в run(): вызываемый объект, как и в случае с apply(), доступен как this в лямбда-выражении, а результат последней операции возвращается как значение всего лямбда-выражения. Тем не менее, поведение run() также похоже на let(), так как возвращает в качестве значения результат последнего выражения. Вызов run() полезен в случае вызова множества методов для одного объекта, но в результате возвращает не собственно объект, а результат последнего выражения. В примере ниже мы добавляем в список несколько строк и возвращаем строковое представление объекта:
  #
  #data class Message(val text: MutableList<String> = mutableListOf()) { fun add(s: String) { text.add(s) }
  #}
  #fun main() {
  #val msg = Message().run { add("This")
  #add("is")
  #add("text") toString()
  #
  #}
  #println(msg)
  #}
  #
  #
  #Результат работы: Message(text=[This, is, text])
  #
  #Функция with()
  #Функция with() очень похожа на run(): обе передают вызываемый объект параметром в лямбда-выражение и обе возвращают значение, полученное в блоке. Отличие лишь в форме вызова функций: run() вызывается как функция самого объекта, а в with() объект передаётся в виде параметра. Сравните с примером выше для run() (используемый класс и вывод программ идентичен).
  #fun main() {
  #val msg = with(Message()) { add("This")
  #add("is")
  #add("text") toString()
  #}
  #println(msg)
  #}
  #
  #Функция with()
  #Функция with() очень похожа на run(): обе передают вызываемый объект параметром в лямбда-выражение и обе возвращают значение, полученное в блоке. Отличие лишь в форме вызова функций: run() вызывается как функция самого объекта, а в with() объект передаётся в виде параметра. Сравните с примером выше для run() (используемый класс и вывод программ идентичен).
  #fun main() {
  #val msg = with(Message()) { add("This")
  #add("is")
  #add("text") toString()
  #}
  #println(msg)
  #}
  #
  #Функция also()
  #Как и функция run(), also() сочетает в себе свойства apply() и let(). Объект, для которого вызвана also() становится доступен в качестве параметра в лямбда- выражении в виде переменной it. Как и apply(), also() возвращает полученный объект. Используем тот же пример, что для with() и run(), заметим, что отличие лишь в синтаксисе обращения к передаваемому объекту (используемый класс и вывод программ идентичен):
  #fun main() {
  #val msg = Message().also { it.add("This")
  #it.add("is")
  #it.add("text") toString()
  #}
  #println(msg)
  #}
  #
  #Коллекции
  #Все коллекции в Kotlin располагаются в пакете kotlin.collections. Полный список интерфейсов и классов, которые представляют коллекции, можно найти по ссылке: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html
  #
  #
  #
  #
  #
  #
  #Неизменяемые коллекции
  #На вершине иерархии находится интерфейс Iterable, который определяет функцию итератор для перебора коллекции.
  #Основным интерфейсом, который позволяет работать с коллекциями, является kotlin.Collection.
  #Данный интерфейс определяет функциональность для перебора элементов, проверки наличия элементов, чтения данных. Однако он не предоставляет возможности по добавлению и удалению данных.
  #Этот интерфейс расширяется другими интерфейсами, которые представляют неизменяемые коллекции - List, который представляет обычный список, и Set, который представляет неупорядоченную коллекцию элементов, не допускающую дублирования элементов.
  #Особняком стоит интерфейс Map. Он не расширяет Collection и представляет набор пар ключ-значение, где каждому ключу сопоставляет некоторое значение. Все ключи в коллекции являются уникальными.
  #
  #Изменяемые коллекции
  #Все изменяемые коллекции реализуют интерфейс MutableIterable. Он представляет функцию итератора для перебора коллекции.
  #Для изменения данных в Kotlin также определен интерфейс kotlin.MutableCollection, который расширяет интерфейс kotlin.Collection и предоставляет методы для удаления и добавления элементов.
  #Этот интерфейс расширяется интерфейсами MutableList, который представляет изменяемый список, и MutableSet, который представляет изменяемую неупорядоченную коллекцию уникальных элементов.
  #И еще одна изменяемая коллекция представлена интерфейсом MutableMap - изменяемая карта, где каждый элемент представляет пару ключ-значение.
  #
  #Массивы и списки (Arrays, Lists). Массивы - это упорядоченные наборы данных одного типа, удобных для выборки по индексу (номеру) элемента.
  #Множества и ассоциативные массивы (Maps, Sets). В ряде случаев удобно обращаться к элементам не по индексу, а по произвольному ключу. Так организованы ассоциативные массивы (или словари), состоящие из пар ключ- значение. Ключи в ассоциативном массиве могут быть произвольного типа и не могут повторятся (уникальны), но необязательно упорядочены. Для множества характерны: уникальность элементов, наличие порядка зависит от реализации.
  #
  #Для каждого типа коллекции определена пара интерфейсов: только для чтения и изменяемый (mutable).
  #Будьте внимательны при объявлении переменной для коллекции. Переменная указывает на один и тот же объект даже когда вы изменяете элементы коллекции, поэтому ссылка на саму коллекцию не изменяется. В то же время, если переменную, объявленную как val попытаться задать заново, получите ошибку компиляции.
  #
  #// простой способ создать массив, при этом типы элементов определяются компилятором
  #val items = arrayOf(1, 2, 3.14, "36.6")
  #// так же, как в Java, существует специальный класс для работы с массивами print(Arrays.toString(items))
  #// создадим список изменяемого размера val numbers = mutableListOf ("X", "Y", "Z", "?")
  #numbers.add ("Q") // можно добавлять и удалять элементы
  #Основа иерархии коллекций - Collection<T>. Этот интерфейс представляет собой обычное поведение коллекции только для чтения: получение размера, выборка, поиск элемента и пр. Collection<T> наследуется от интерфейса Iterable
  #<T>. Удобно использовать Collection как параметр функции, которая применяется к разным типам коллекций. Для более конкретных случаев используйте наследников Collection: List, Map и Set.
  #
  #Массивы и списки удобны, если вы храните элементы в определённом порядке. Поиск в них может быть не очень быстрым, т.к. требует перебора всех элементов (в худшем случае) или предварительной сортировки элементов (что затратно).
  #// примеры создания массивов
  #val vowels = arrayOf("a", "i", "e", "o", "u") // неизменяемый массив
  #val allFives = Array(5, { 5 }) // пять пятёрок, мы изучим синтаксис подобных лямбда-выражений позже
  #Массивы, получаемые с помощью функции arrayOf() являются наборами объектов. Это требует расхода памяти и снижает производительности. Для оптимизации быстродействия существуют специализированные массивы, например:
  #val myBytes = byteArrayOf(1, 2, 3)
  #val toBeOrNotToBe = booleanArrayOf(true, false, false, true)
  #
  #List хранит элементы в указанном порядке и предоставляет к ним доступ по
  #индексу (начинаются с нуля). Существуют также удобные методы last(), first() и поле lastIndex (firstIndex = 0 по определению):
  #val numbers = listOf("one", "two", "three", "four") println("Number of elements: ${numbers.size}") println("Third element: ${numbers.get(2)}") println("Fourth element: ${numbers[3]}")
  #println("Index of element \"two\" ${numbers.indexOf("two")}")
  #Элементы списка (включая нули) могут дублироваться: список может содержать любое количество одинаковых объектов или вхождений одного объекта. Два списка считаются равными, если они одинакового размера и имеют одинаковые элементы в одинаковых позициях:
  #val petya = User("Petya", 30)
  #val users = listOf(User("Vasya", 40), petya , petya )
  #val users2 = listOf(User("Vasya", 40), User("Bob", 30), petya) println(users == users2) // true
  #petya.age = 123
  #println(users == users2) // false
  #
  #Для добавления или удаления элементов существует отдельный интерфейс
  #MutableList<T> список с возможностью записи, например:
  #val numbers = mutableListOf(10, 20, 30, 40) numbers.add(100)
  #numbers.removeAt(1) numbers.shuffle() numbers[0] = -10 println(numbers)
  #Для выборки нескольких значений (диапазона) удобно использовать метод slice(), в качестве параметра которому передаётся диапазон (включая его границы), например:
  #val bookIds = arrayListOf(10, 20, 30, 40) println(bookIds.slice(1..2))
  #Проверить принадлежность элемента к коллекции можно оператором in
  #(инверсия - !in) или с помощью метода contains()
  #
  #Для работы с множествами существует интерфейс Set<T>. В такой коллекции все элементы уникальные, но их порядок в общем случае не определен (для TreeSet элементы упорядочены). Значение null считается уникальным и множество может содержать только один null. Множества считаются равным, если содержат идентичный набор элементов.
  #fun main() {
  #val intSet = setOf(1, 2, 3, 4)
  #println("Number of elements: ${intSet .size}")
  #if (intSet .contains(3)) println("3 есть во множестве intSet ") val intSetInverted = setOf(4, 3, 2, 1)
  #println("Множества идентичны: ${intSet == intSetInverted }")
  #}
  #
  #По умолчанию множество реализуется через LinkedHashSet, в котором порядок добавления элементов сохраняется. Функции, знакомые вам по работе со списками, такие как first() или last(), работают аналогично и возвращают первый и последний элементы соответственно:
  #fun main() {
  #val intSet = setOf(1, 2, 3, 4) // LinkedHashSet is the default implementation val intSetInverted = setOf(4, 3, 2, 1)
  #println(intSet.first() == intSetInverted.first()) println(intSet.first() == intSetInverted.last())
  #}
  #Альтернативная реализация - HashSet - ничего не говорит о порядке элементов, поэтому на вызов функций first() или last() полагаться не стоит. Однако HashSet требует меньше памяти для хранения того же количества элементов.
  #
  #Последовательности (sequences)
  #Предоставляют похожую функциональность, что и интерфейс Iterable, который реализуется типами коллекций. Ключевая разница состоит в том, как обрабатываются элементы последовательности при применении к ним набора операций.
  #
  #Последовательности представляют интерфейс Sequence<T>. Для создания объекта данного типа можно использовать встроенную функцию sequenceOf(). В качестве параметра она принимает набор элементов, которые будут входить в последовательность:
  #val people = sequenceOf(“Maria", “Olga", “Natalia")	//тип Sequence<String> println(people.joinToString()) // Maria, Olga, Natalia
  #В данном случае определяется последовательность типа Sequence<String>, которая содержит три элемента. Для вывода последовательности на консоль применяется ее преобразование в строку с помощью функции joinToString()
  #
  #Функция asSequence()
  #Также можно создать последовательность из объекта Iterable (например, из объектов типа List или Set), используя метод asSequence():
  #val students = listOf(“Ivan”, “Alex", “Petr") // объект List<String> val peoples = students.asSequence()  //тип Sequence<String> println(peoples.joinToString())  // Ivan, Alex, Petr
  #
  #Функция generateSequence()
  #fun main() {
  #var number = 0
  #val numbers = generateSequence{ number += 3; number} println(numbers.take(5).joinToString())	// получаем первые 5 элементов
  #последовательности - 3, 6, 9, 12, 15
  #}
  #В качестве параметра функция generateSequence() принимает функцию, которая возвращает некоторое значение. Это значение затем станет элементом последовательности. В этом случае увеличиваем значение переменной number на 3 и возвращаем ее значение.
  #
  #В этой функции можно генерировать элементы последовательности с помощью функций yield() и yieldAll():
  #fun main() {
  #val numbers = sequence { yield(10)
  #yield(20) yield(30)
  #}
  #println(numbers.joinToString())	// 10, 20, 30
  #}
  #Функция yield() фактически возвращает во вне некоторое значение, которое ей передается через параметр. То есть при первом обращении к функции sequence сработает вызов yield(10), который возвратит значение 10. При втором обращении сработает вызов yield(20), который возвратит 20. И при третьем обращении сработает вызов yield(30). Таким образом, последовательность будет содержать 3 элемента: 10, 20, 30.
  #
  #Создаем бесконечную последовательность:
  #fun main() {
  #val numbers = sequence { var start = 0
  #while(true) yield(start++)
  #}
  #println(numbers.take(10).joinToString()) // 0...9
  #}
  #Если надо создать последовательности на основе другой последовательности или коллекции, то удобнее источник данных передать в функцию yieldAll():
  #val personal = sequence {
  #val data = listOf(“Max", "Kate", “Olga") yieldAll(data)
  #}
  #println(personal.joinToString())	// Max, Kate, Olga
  #
  #Основы языка Kotlin
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #stepanov_p@mirea.ru
  #
  #Тема 4. Ассоциативные массивы. Класс Map.
  #
  #Часто бывает удобно обращаться к элементам не по номеру (индексу), а по ключу. Для этой цели существует интерфейс Map<K, V>. Хотя он не является наследником интерфейса Collection, его относят к коллекциям в Kotlin.
  #Ассоциативный массив (словарь) хранит пары ключ-значение (пары или записи); ключи уникальны, но разные ключи могут иметь одинаковые значения. Важным элементом языка являются пары (Pair), из которых удобно формировать словари:
  #fun main() {
  #val countryCodes = mapOf("RU" to "Russia", "FR" to "France", "PL" to "Poland") val codes = countryCodes.keys
  #val players = mapOf ("Peter" to 1, "Paul" to 2, "Tom" to 3, "Bob" to 1) println ("Все ключи: $ {players.keys}")
  #println ("Все значения: $ {players.values}")
  #if ("Peter" in players ) println ("Значение по ключу Peter: ${players["Peter"]}") if (1 in players.values) println ("Значение 1 есть в словаре")
  #if (players.containsValue (1)) println ("Значение 1 есть в словаре") // то же, что и предыдущее
  #}
  #
  #Два словаря, содержащие идентичные пары, равны независимо порядка этих пар:
  #fun main() {
  #val moneyMap = mapOf ("USD" to "Dollar", "RUR" to "Ruble", "EUR" to "Euro") val anotherMap = mapOf ("RUR" to "Ruble", "USD" to "Dollar", "EUR" to "Euro") println ("Коллекции равны: ${moneyMap == anotherMap}")
  #}
  #Стандартная библиотечная функция mapOf() создаёт неизменяемую коллекцию. Для добавления/удаления пар и изменения значений используйте MutableMap - словарь с операциями записи, например, вы можете добавить новую пару ключ- значение или обновить значение, связанное с данным ключом:
  #val moneyMap = mutableMapOf ("USD" to "Dollar", "RUR" to "Ruble", "EUR" to "Euro")
  #moneyMap.put ("USD", "Доллар") moneyMap["RUR"] = "Рубль" // аналогично println (moneyMap)
  #
  #Коллекции vs последовательности
  #Отличие состоит в том, как эти операции обрабатывают элементы при применении сразу нескольких операций.
  #При применении набора операций к коллекции Iterable каждая отдельная операция возвращает промежуточный результат - промежуточную коллекцию. А при обработке последовательности весь набор операций выполняется только тогда, когда требуется конечный результат обработки.
  #Также меняется порядок применения операций. Коллекция применяет каждую операцию последовательно к каждому элементу. То есть сначала выполняет первую операцию для всех элементов, потом вторую операцию для элементов коллекции, полученных после первой операции. И так далее.
  #Последовательность применяет весь набор операций отдельно к каждому элементу. То есть сначала весь набор операций применяется к первому элементу, потом ко второму элементу и так далее.
  #
  #Таким образом, последовательность позволяет избежать создания промежуточных коллекций и в тоже время повышают производительность при выполнении набора операций особенно для большого набора данных. Однако при небольших наборах данных и малом количестве операций может быть эффективнее использовать коллекции Iterable.
  #Например:
  #fun main(){
  #var students = listOf( Student("Ivan", 22),
  #Student("Olga", 19),
  #Student("Andrey", 21)
  #)
  #students = students.filter { println("Age filter: ${it}"); it.age > 18 }
  #.filter{ println("Name filter: ${it}"); it.name.length == 4} println("Result:")
  #for(st in students) println(st)
  #}
  #data class Student(val name: String, val age: Int)
  #
  #Сначала получаем все объекты Student, у которых свойство age больше 18:
  #students.filter { println("Age filter: ${it}"); it.age > 18 }
  #Эта операция filter() возвратит промежуточную коллекцию, которая содержит все объекты Students с возрастом больше 18.
  #Затем выполняется вторая операция filter() - она возвращает из промежуточной коллекции те объекты Student, у которых длина свойства name равна 4.
  #filter{ println("Name filter: ${it}"); it.name.length == 3 }
  #Сама фильтрация является одной из распространенных операций. Для фильтрации по условию применяется функция filter(), которая в качестве параметра принимает условие-предикат в виде функции (T) -> Boolean.
  #Для коллекций List и Set эта функция возвращает объект List, для Map - объект Map, для последовательностей Sequence - также объект Sequence.
  #
  #Результат работы:
  #Age filter: Student(name=Ivan, age=22)  Age filter: Student(name=Olga, age=19) Age filter: Student(name=Andrey, age=21) Name filter: Student(name=Ivan, age=22) Name filter: Student(name=Olga, age=19) Name filter: Student(name=Andrey, age=21) Result:
  #Student(name=Ivan, age=22) Student(name=Olga, age=19)
  #
  #Рассмотрим теперь для последовательности:
  #fun main(){
  #var students = sequenceOf( Student("Ivan", 22),
  #Student("Olga", 19),
  #Student("Andrey", 21)
  #)
  #students = students.filter { println("Age filter: ${it}"); it.age > 18 }
  #.filter{ println("Name filter: ${it}"); it.name.length == 4 } println("Result:")
  #for(st in students) println(st)
  #}
  #data class Student(val name: String, val age: Int)
  #
  #Результат работы для последовательности:
  #Result:
  #Age filter: Student(name=Ivan, age=22) Name filter: Student(name=Ivan, age=22) Student(name=Ivan, age=22)
  #Age filter: Student(name=Olga, age=19) Name filter: Student(name=Olga, age=19) Student(name=Olga, age=19)
  #Age filter: Student(name=Andrey, age=21) Name filter: Student(name=Andrey, age=21)
  #
  #1)	строка "Result:" выводится до выполнения всех операций. Потому что получение результата фактически происходит в цикле for при обращении к последовательности.
  #2)	Сначала обрабатывается первый элемент - Student(name=Ivan, age=22). Поскольку он соответствует обоим фильтрам, то он в конечном счете выводится на консоль в цикле for.
  #3)	Второй элемент - Student(name=Olga, age=19), тоже соответствует обоим фильтрам, то он в конечном счете выводится на консоль в цикле for.
  #4)	В конце обрабатывается третий элемент - Student(name=Andrey, age=21), к нему применяются две операции filter(), но затем его обработка завершается, поскольку он не соответствует условию второго фильтра.
  #
  #Фильтрация
  #Одна из самых популярных задач при работе с коллекциями. Условия фильтра задаются с помощью предикатов — лямбда-функций, которые принимают элемент коллекции, а возвращают логическое значение (boolean): true означает, что элемент соответствует предикату, false - не соответствует.
  #В стандартной библиотеке есть группа функций-расширений, с помощью которых можно фильтровать коллекции за один вызов такой функции. Они не изменяют исходную коллекцию, поэтому их можно использовать как для mutable, так и для immutable коллекций. Чтобы использовать результат фильтрации, вы должны либо присвоить его переменной, либо использовать его в цепочке вызовов.
  #
  #
  #fun main() {
  #val names = listOf("Ivan", "Olga", "Max", "Alex") val more3 = names.filter { it.length > 3 } println(more3) // [Ivan, Olga, Alex]
  #val nums = mapOf("key1" to 1, "key2" to 2, "key31" to 31, "key11" to 11) val filtered = nums.filter { (key, value) -> key.endsWith("1") && value > 10} println(filtered) // {key31=31, key11=11}
  #}
  #
  #
  #fun main() {
  #val names = listOf("Ivan", "Olga", "Max", "Alex") val more3 = names.filter { it.length > 3 } println(more3) // [Ivan, Olga, Alex]
  #val nums = mapOf("key1" to 1, "key2" to 2, "key31" to 31, "key11" to 11) val filtered = nums.filter { (key, value) -> key.endsWith("1") && value > 10} println(filtered) // {key31=31, key11=11}}
  #
  #В функции filter() предикаты могут проверять только значения элементов. Если при фильтрации вы хотите использовать индексы элементов, то вам нужна функция filterIndexed(). Она принимает предикат с двумя аргументами: индекс и значение элемента.
  #Если вы хотите отфильтровать элементы, которые не соответствуют заданному условию, то используйте функцию filterNot(). Она возвращает те элементы, для которых предикат вернул значение false.
  #
  #fun main() {
  #val students = listOf("Maria", "Julia", "Petr", "Oleg")
  #val filterId = students.filterIndexed { index, s -> (index != 0) && (s.length < 5) } val filterNot = students.filterNot { it.length <= 4 }
  #println(filterId) // [Petr, Oleg] println(filterNot) // [Maria, Julia]
  #}
  #
  #Фильтрация с разделением
  #Другая функция для фильтрации - partition() - фильтрует коллекцию по предикату и сохраняет элементы, которые ему не соответствуют, в отдельном списке. Возвращает объект типа Pair<List, List>, где первый список содержит элементы, соответствующие предикату, а второй — все остальные элементы из исходной коллекции.
  #
  #fun main() {
  #val persons = listOf("Max", "Andrey", "Nikolay", "Nata") val (match, rest) = persons.partition { it.length > 4 } println(match) // [Andrey, Nikolay]
  #println(rest) // [Max, Nata]
  #}
  #
  #•	any() - возвращает true, если хотя бы один элемент соответствует предикату.
  #•	none() - возвращает true, если ни один элемент не соответствует предикату.
  #•	all() - возвращает true, если все элементы соответствуют предикату.
  #
  #fun main() {
  #val persons = listOf("Max", "Andrey", "Nikolay", "Nata") println(persons.any { it.endsWith("x") }) // true println(persons.none { it.endsWith("z") }) // true println(persons.all { it.endsWith("e") }) // false
  #}
  #
  #any() и none() могут использоваться без предиката. В этом случае они просто проверяют пуста ли коллекция. any() возвращает true, если в коллекции есть элементы, а none() наоборот, возвращает true, если коллекция пуста.
  #
  #fun main() {
  #val numbers = listOf("one", "two", "three", "four") val empty = emptyList<String>()
  #println(numbers.any()) // true println(empty.any()) // false
  #println(numbers.none()) // false println(empty.none()) // true
  #}
  #
  #Трансформации – map()
  #Для трансформации одной коллекции/последовательности применяется функция map(). В качестве параметра она принимает функцию преобразования. Функция преобразования получает текущий элемент коллекции/последовательности и возвращает результат преобразования, например:
  #
  #fun main(){
  #val students = listOf(Student("Oleg"), Student("Ivan"), Student("Petr")) val names = students.map { it.name }
  #println(names) // [Oleg, Ivan, Petr]
  #}
  #data class Student(val name: String) fun main(){
  #val numbers = listOf(10, 20, 30, 40, 50)
  #val squares = numbers.map { it/10 } println(squares) // [1, 2, 3, 4, 5]
  #}
  #
  #Передает в функцию преобразования индекс текущего элемента
  #fun main(){
  #val students = listOf(Student("Oleg"), Student("Ivan"), Student("Petr")) val names = students.mapIndexed{ index, p-> "${index+1}.${p.name}"} println(names) // [1.Oleg, 2.Ivan, 3.Petr]
  #}
  #data class Student(val name: String)
  #
  #Если необходимо отсеять значения null, которые могут возникать при преобразовании, то можно применять функции - mapNotNull() и mapIndexedNotNull():
  #
  #fun main(){
  #val students = listOf(Student("Max"), Student("Ivan"), Student("Petr"))
  #// элементы длина имени > 3 преобразуем в null
  #val names1 = students.mapNotNull{ if(it.name.length>3) null else it.name }
  #// элементы на нечетных позициях преобразуем в null
  #val names2 = students.mapIndexedNotNull{ index, p -> if(index%2==1) null else p.name }
  #println(names1) // [Max] println(names2) // [Max, Petr]
  #}
  #data class Student(val name: String)
  #
  #В стандартной библиотеке Kotlin есть функции-расширения для группировки элементов коллекции. Основная функция для группировки - groupBy(), которая принимает лямбда-функцию и возвращает Map. В этой Map каждый ключ — это результат вычисления лямбда-функции, а соответствующее ему значение — это List из элементов, значения которых сходятся с полученным результатом от лямбда- функции.
  #
  #Также groupBy() может быть передана вторая лямбда-функция — функция преобразования значений. В этом случае ключи, созданные первой лямбдой keySelector, будут отражать результаты второй лямбды valueTransform, вместо исходных элементов.
  #
  #
  #fun main(){
  #val numbers = listOf("moscow", "berlin", "paris", "london", "perm", "baku")
  #println(numbers.groupBy { it.first().uppercase() })
  #// {M=[moscow], B=[berlin, baku], P=[paris, perm], L=[london]}
  #println(numbers.groupBy( keySelector = { it.first() }, valueTransform = { it.uppercase() }
  #))
  #// {m=[MOSCOW], b=[BERLIN, BAKU], p=[PARIS, PERM], l=[LONDON]}
  #}
  #
  #Если вам требуется сгруппировать элементы, а затем применить какую-либо операцию ко всем группам одновременно, то используйте функцию groupingBy(). Она возвращает экземпляр типа Grouping. В свою очередь Grouping позволяет "лениво" применять операции ко всем группам: фактически группы будут создаваться прямо перед выполнением операции.
  #Grouping поддерживает следующие операции:
  #•	eachCount() - подсчитывает количество элементов в каждой группе;
  #•	fold() и reduce() - выполняют операции fold и reduce для каждой группы как для отдельной коллекции, после чего возвращают результат;
  #•	aggregate() - последовательно применяет данную операцию ко всем элементам в каждой группе, после чего возвращает результат. Это общий способ выполнения любых операций с объектом Grouping.
  #
  #fun main() {
  #val numbers = listOf("one", "two", "three", "four", "five", "six") println(numbers.groupBy { it.first() })
  #// {o=[one], t=[two, three], f=[four, five], s=[six]} println(numbers.groupingBy { it.first() }.eachCount())
  #// {o=1, t=2, f=2, s=1}
  #}
  #fun main() {
  #val intList: List<Int> = listOf(1, 2, 3, 4)
  #val agg = intList.groupingBy { "key" }.aggregate({ key, acc: String?, element, isFirst -> println("acc: $acc, value: $key, element: $element, isFirst: $isFirst")
  #when (acc) {
  #null -> "$element"
  #else -> acc + "$element"
  #}
  #})
  #println(agg) // {key=1234}
  #}
  #
  #Разница между этими двумя функциями состоит в том, что fold() принимает начальное значение и использует его как накопленное значение на первом шаге, тогда как reduce() на первом шаге в качестве аргументов операции использует первый и второй элементы.
  #fun main() {
  #val numbers = listOf(1, 2, 3, 4)
  #val sumred = numbers.reduce { a, b -> println("a: $a, b: $b")
  #a + b
  #
  #}
  #println(sumred)
  #// a: 1, b: 2
  #// a: 3, b: 3
  #// a: 6, b: 4
  #// 10
  #}
  #
  #При первом запуске в функции в reduce() параметр a равен 1, а параметр b равен 2. При втором запуске параметр a содержит результат предыдущего выполнения функции, то если число 1 + 2 = 3, а параметр b равен 3 - следующее число в потоке.
  #
  #Функция fold() также сводит все элементы потока в один. Но в отличие от оператора reduce оператор fold() в качестве первого параметра принимает начальное значение:
  #fun main() {
  #val numbers = listOf(1, 2, 3, 4)
  #val sumfold = numbers.fold(100) { a, b -> println("a: $a, b: $b")
  #a + b
  #
  #}
  #println(sumfold)
  #// a: 100, b: 1
  #// a: 101, b: 2
  #// a: 103, b: 3
  #// a: 106, b: 4
  #// 110
  #}
  #
  #
  #
  #
  #В данном случае начальным значением является значение 100, к которому затем прибавляются остальные элементы потока данных.
  #
  #Аггрегатные операции
  #Минимальное и максимальное значение
  #Функции minOrNull() и maxOrNull() возвращают соответственно минимальное и максимальное значение (если коллекция/последовательность пуста, то возвращается null). Причем для работы этих функций элементы коллекции/последовательности должны реализовать интерфейс Comparable:
  #fun main() {
  #val numbers = listOf(40, -5, 30, 511, 0, 22)
  #val students = listOf("Maxim", "Konstantin", "Petr", "Oleg", "Kate")
  #println(numbers.minOrNull())	// -5
  #println(numbers.maxOrNull())	// 511
  #println(students.minOrNull())	// Kate println(students.maxOrNull())		// Petr
  #}
  #
  #Функции minByOrNull() и maxByOrNull() в качестве параметра принимают функцию селектора, которая позволяет определить критерий сравнения объектов:
  #fun main() {
  #val students = listOf( Student("Ivan", 17),
  #Student("Oleg",18),
  #Student("Olga", 20))
  #val minage = students.minByOrNull { it.age } println(minage)	// Ivan (17)
  #val maxage = students.maxByOrNull { it.age } println(maxage)	// Olga (20)
  #}
  #data class Student(val name: String, val age: Int){ override fun toString(): String = "$name ($age)"
  #}
  #
  #fun main() {
  #val numbers = listOf(1, 2, 3, 4, 5)
  #// среднее значение
  #val avg = numbers.average() println(avg)	// 3.0
  #// сумма
  #val sum = numbers.sum() println(sum)	// 15
  #val persons = listOf("Ivan", "Petr", "Kate", "Alice")
  #// количество
  #val count = persons.count() println(count)	// 4
  #// количество строк, у которых длина равна 4 val count2 = persons.count{it.length == 4} println(count2)	// 3
  #}
  #
  #fun main() {
  #val students = listOf("Ivan", "Max", "Konstantin")
  #// добавляем один объект
  #val result1 = students.plus("Kate") println(result1) // [Ivan, Max, Konstantin, Kate]
  #val new = listOf("Petr", "Oleg")
  #// добавляем коллекцию объектов val result2 = students.plus(new)
  #println(result2) // [Ivan, Max, Konstantin, Petr, Oleg]
  #val new3 = listOf("Kate")
  #val result3 = students.minus(new) println(result3) // [Ivan, Max, Konstantin]
  #}
  #Вместо функции plus(), minus() можно использовать оператор + и – соответственно.
  #
  #Для объединения двух разных коллекций/последовательностей в одну применяется функция zip(). В качестве параметра она принимает другую коллекцию/последовательность и возвращает набор из объектов типа Pair:
  #fun main() {
  #val english = listOf("red", "blue", "green")
  #val russian = listOf("красный", "синий", "зеленый") val words = english.zip(russian)
  #for(word in words)
  #println("${word.first}: ${word.second}")
  #}
  #Также в Kotlin есть обратная функция – unzip(), которая позволяет обратно получить две коллекции.
  #val dict = listOf("red", "blue", "green").zip(listOf("красный", "синий", "зеленый")) val words = dict.unzip()
  #println(words.first)	// [red, blue, green] println(words.second)	// [красный, синий, зеленый]
  #
  #Функция slice() возвращает часть коллекции, элементы которой располагаются на определенных индексах. Индексы передаются в функцию либо в виде диапазона IntRange, либо коллекции значений Iterable<Int>. Результатом функции является список List<T>, который содержит элементы по указанным индексам:
  #
  #fun main() {
  #val students = listOf("Maxim", "Konstantin", "Petr", "Oleg", "Kate") println(students.slice(1..3))	// [Konstantin, Petr, Oleg] println(students.slice(0..5 step 2)) // [Maxim, Petr, Kate] println(students.slice(listOf(1, 3, 4, 1)))	// [Konstantin, Oleg, Kate, Konstantin]
  #}
  #
  #Функция take() извлекает из начала коллекции/последовательности определенное количество элементов.
  #Функция takeWhile() отбирает элементы с начала коллекции/последовательности, которые соответствуют условию предиката.
  #fun main() {
  #val students = listOf("Maxim", "Konstantin", "Petr", "Oleg", "Kate") println(students.take(3)) // [Maxim, Konstantin, Petr] println(students.takeLast(3)) // [Petr, Oleg, Kate]
  #val part = students.takeWhile{it.length == 4} println(part)	// []
  #}
  #takeWhile() отбирает строки, пока они соответствуют этому условию. Так, в данном случае, в списке первый элемент уже не соответствует условию предиката, то функция возвратит пустой список.
  #
  #Функция drop() позволяет пропустить определенное количество элементов в коллекции/последовательности:
  #Функция dropWhile() пропускает элементы с начала коллекции/последовательности, которые соответствуют условию предиката.
  #fun main() {
  #val students = listOf("Petr", "Konstantin", "Petr", "Oleg", "Kate") val part = students.drop(3)
  #println(part) // [Oleg, Kate]
  #val part2 = students.dropWhile{it.length == 4} println(part2)	// [Konstantin, Petr, Oleg, Kate]
  #}
  #
  #Функция chuncked() позволяет разбить коллекцию/последовательность на списки определенной длины:
  #fun main() {
  #val students = listOf("Konstantin", "Petr", "Oleg", "Kate") val part = students.chunked(2)
  #println(part) // [[Konstantin, Petr], [Oleg, Kate]]
  #val parts = students.chunked(3){it.last()} println(parts)	// [Oleg, Kate]
  #}
  #
  #Исключение – некое событие, которое возникает при выполнении программы и нарушает ее нормальной ход. Например, при передаче файла по сети может оборваться сетевое подключение, и в результате чего может быть сгенерировано исключение. Если исключение не обработано, то программа падает и прекращает свою работу. Поэтому при возникновении исключений их следует обрабатывать.
  #
  #try {
  #// код, генерирующий исключение
  #}
  #catch (e: Exception) {
  #// обработка исключения
  #}
  #finally {
  #// постобработка
  #}
  #
  #fun main() { try{
  #val a : Int = 0 val b : Int = 0 / a println(“123")
  #}
  #catch(e: Exception){ println("Exception") println(e.message)
  #}
  #}
  #Действие, которое может вызвать исключение, то есть операция деления, помещается в блок try. В блоке catch перехватываем исключение. При этом каждое исключение имеет определенный тип. В данном случае используется общий тип исключений - класс Exception.
  #Если необходимы какие-то завершающие действия, то можно добавить блок
  #finally.
  #
  #В данном случае при доступе по недействительному индексу в массиве будет генерироваться исключение типа ArrayIndexOutOfBoundsException.
  #Если в программе будут другие исключения, которые не представляют тип ArrayIndexOutOfBoundsException, то они будут обрабатываться вторым блоком catch, так как Exception - это общий тип, который подходит под все типы исключений.
  #try {
  #val nums = arrayOf(1, 2, 3, 4) println(nums[10])
  #}
  #catch(e:ArrayIndexOutOfBoundsException){ println(“Index out of bounds Exception!")
  #}
  #catch (e: Exception){ println(e.message)
  #}
  #
  #Для генерации исключения применяется оператор throw, после которого указывается объект исключения
  #Например, в функции проверки возраста мы можем генерировать исключение, если возраст не укладывается в некоторый диапазон:
  #fun main() {
  #val check1 = checkAge(5) val check2 = checkAge(-11)
  #}
  #fun checkAge(age: Int): Int{
  #if(age < 1 || age > 110) throw Exception("Invalid value of $age!") println("Age $age is valid")
  #return age
  #}
  #
  #Конструкция try может возвращать значение:
  #fun main() {
  #val check1 = try { checkAge(50) } catch (e: Exception) { "Undefined" } val check2 = try { checkAge(-1) } catch (e: Exception) { "Undefined" } println(check1)  // 50
  #println(check2)  // Undefined
  #}
  #fun checkAge(age: Int): Int{
  #if(age < 1 || age > 110) throw Exception("Invalid value of $age!") println("Age $age is valid")
  #return age
  #}
  #
  #Основы разработки Android приложений
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Список тем дисциплины
  #1.	ОС Android. Состав Android проекта. Жизненный цикл Activity. Макет активности.
  #2.	Элементы пользовательского интерфейса UI.
  #3.	Архитектурные компоненты ViewModel и LiveData. Графические ресурсы.
  #4.	Отладка и тестирование Android приложений.
  #
  #Литература
  #
  #
  #Тема 1. ОС Android. Состав
  #Android проекта. Жизненный цикл Activity. Макет активности.
  #
  #Официальные источники
  #
  #
  #
  #
  #
  #https://developer.android.com/
  #
  #
  #
  #
  #https://developer.android.com/courses/android-basics-kotlin/course
  #
  #Про Android
  #
  #
  #Плюсы:
  #•	70 % от всех мобильных устройств на ОС Android
  #•	Платформа с открытым исходным кодом
  #•	Дешевые устройства
  #•	Доступность средств разработки
  #•	Большое сообщество разработчиков
  #•	Разрабатывается и поддерживается компанией Google
  #•	…
  #
  #Минусы:
  #•	Большое количество разных производителей устройств и их размеров
  #•	Проблемно осуществить тестирование приложения на всех целевых устройствах
  #•	Большое количество вендорных UI оболочек
  #•	Не все производители устройств готовы поддерживать их в дальнейшем
  #•	…
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #Android 12
  #18 февраля 2021 года Google выпустила Android 12 Developer Preview для Pixel 3 и новее. Стабильная версия Android 12 вышла 4 октября 2021 года. Дизайн был сменён на Material You.[49][50] 7 марта 2022 года вышла версия Android 12.1 под кодовым названием Android 12L.[51]
  #Android 13 — и снова десертное название
  #10 февраля 2022 года Google выпустила Android 13 Developer Preview 1 для Pixel 4 и новее. Android 13 получило кодовое название Tiramisu, в честь десерта Тирамису (версии Android с 10-й по 12-ю не имели десертных наименований).
  #Релиз стабильной версии состоялся 15 августа 2022 г.
  #
  #
  #Что нужно для работы?
  #•	JDK – для Kotlin;
  #•	Android SDK – устанавливается вместе с Android Studio. Включает API OS Android, документация, AVD эмуляторы и библиотеки;
  #•	Android Studio – основная IDE для разработки приложений на Android, как вариант Intellij IDEA с Android SDK;
  #•	Git – система контроля версий;
  #•	Gradle – система сборки, входит в Android Studio;
  #•	Android-устройство – для удобства отладки приложений или Remote Test Lab: https://developer.samsung.com/remote-test-lab
  #
  #Gradle
  #•	Система автоматической сборки, построенная на принципах Apache Ant и Apache Maven, но предоставляющая DSL на
  #языках Groovy и Kotlin вместо традиционной XML-образной формы представления конфигурации проекта;
  #•	Позволяет расширять сборку собственными функциями;
  #•	Можно создавать разные сценарии сборки приложения;
  #•	Считается наиболее гибким и пригодным для сборки Android- приложений
  #
  #/app/build.gradle
  #plugins {
  #// Apply the application plugin to add support for building a CLI application in Java. id 'application'
  #}
  #repositories {
  #// Use Maven Central for resolving dependencies. mavenCentral()
  #}
  #dependencies {
  #// Use JUnit test framework. testImplementation 'junit:junit:4.13.1'
  #// This dependency is used by the application. implementation 'com.google.guava:guava:30.0-jre'
  #}
  #application {
  #// Define the main class for the application. mainClass = 'mainProject.App'
  #}
  #
  #Структура OS Android
  #Изначально разрабатывалась компанией Android, Inc., которую затем приобрела Google. Основана на ядре Linux и собственной реализации JVM компании Go ogle. Впоследствии Google инициировала создание альянса Open Handset Alliance (OHA), который занимается поддержкой и дальнейшим развитием платформы.
  #
  #Загрузка OS Android
  #
  #https://nurlandroid.com/?p=321
  #
  #Устройство файла приложения
  #
  #
  #
  #•	Основной файл конфигурации Android-приложения
  #•	Содержит:
  #o	описание всех компонентов приложения
  #o	информацию о приложении: название, иконка и пр.
  #o	запрашиваемые permission
  #o	регистрируемые действия, на которые приложение может ответить
  #•	Используется ОС Android при обработке системных событий и работе с приложением
  #
  #
  #
  #Тег <manifest>
  #Атрибуты:
  #•	package – имя корневого пакета приложения в стиле Java, должно быть уникальным;
  #•	android:versionCode – версия приложения, повышение говорит об обновлении;
  #•	android:versionName – строковое представление версии приложения, например, 1.1.0
  #•	android:installLocation – куда ставить приложение – внутреннее хранилище/SD-карта
  #
  #Тег <permission>
  #Атрибуты:
  #•	Android:name – например, android.permission.INTERNET;
  #•	Android:icon – иконка для пользователя;
  #•	Android:label – название для пользователя;
  #•	Android:description – описание для пользователя;
  #•	Android:permissionGroup – разрешение группы;
  #•	Android:protectionLevel – описывает группу риска разрешения
  #
  #Тег <application>
  #Некоторые из атрибутов:
  #•	android:name – подкласс Application, создаваемый при старте приложения перед созданием других компонентов;
  #•	android:theme – ссылка на общий стиль приложения, который может быть переопределён на уровне отдельных компонентов;
  #•	android:icon – иконка для компонентов приложения;
  #•	android:label – описание приложения. Чаще всего тут используется локализуемая строка для корректного перевода на разные языки.
  #
  #Тег <activity>
  #Некоторые из атрибутов:
  #•	android:name – класс Activity;
  #•	android:screenOrientation – в каких положениях устройства может быть показано;
  #•	android:launchMode – режим запуска;
  #•	android:label – описание
  #
  #Основные компоненты приложения
  #•	Application соответствует единственному запущенному экземпляру нашего приложения
  #•	Activity (Активность)
  #o	Точка входа в приложение
  #o	Основной компонент
  #o	Экран с интерфейсом
  #o	Взаимодействует с другими Activity с помощью сообщений
  #•	Service (Сервис)
  #o	Без интерфейса
  #o	Для выполнения задач в фоновом режиме
  #o		Удобный архитектурный слой для общения между разными компонентами приложения
  #•	Content Provider (Контент провайдер)
  #o	Организует связь между разными приложениями
  #o	Позволяет делиться данными между приложениями
  #o	Удобный архитектурный слой для общения с хранилищами данных
  #•	Broadcast Receiver (Броадкаст ресивер)
  #o	Позволяет подписываться на системные события
  #o	Создаёт пользовательские notification
  #
  #
  #
  #•	Android проект состоит из модулей;
  #•	По умолчанию создаётся один модуль;
  #•	Settings.gradle - тут вы определяете все модули своего приложения по имени, используя ключевое слово «include». В процессе сборки Gradle проверит содержимое файла settings.gradle вашего проекта и определите все модули, которые необходимо включить в процесс сборки:
  #
  #
  #•	Build.gradle уровня проекта - для определения любых подключаемых модулей, репозиториев, зависимостей и параметров конфигурации, которые применяются к каждому модулю в вашем проекте:
  #
  #
  #•	Build.gradle уровня модуля - который присутствует в каждом модуле вашего проекта. Если ваш проект Android состоит из нескольких модулей, он также будет состоять из нескольких файлов build.gradle уровня модуля. Каждый файл build.gradle уровня модуля содержит имя пакета вашего проекта, имя версии и код версии, а также минимальный и целевой SDK для этого конкретного модуля.
  #
  #
  #Build.gradle уровня модуля
  #•	Первым подключается базовый Android application-плагин
  #•	compileSdkVersion – это основная версия API OS Android, для которой создается приложение;
  #•	defaultConfig - минимальная версия, а также настройки, аналогичные тем, что есть в секции <manifest>;
  #•	buildTypes – позволяет задать разные конфигурации сборки, например, для release и debug;
  #•	minifyEnabled – минификация идентификаторов с помощью Proguard (это инструмент командной строки с открытым исходным кодом, который сокращает, оптимизирует и запутывает код Java. Он способен оптимизировать байт-код, а также обнаруживать и удалять неиспользуемые инструкции);
  #•	В dependencies указываются зависимости. Можно указать какие библиотеки необходимо скачать из maven-репозитория.
  #
  #
  #
  #
  #
  #
  #
  #Основные моменты:
  #•	Android запускает все приложения в отдельных процессах;
  #•	При долгой работе главного потока (UI) приложение считается зависшим с появлением диалога о его закрытии;
  #•	Android может уничтожить определённые процессы при нехватке памяти на устройстве;
  #•	При убийстве приложения OS Android некоторые фазы жизненного цикла могут быть не вызваны, но OS сама освобождает необходимые ресурсы.
  #
  #
  #
  #Точки входа в Android приложение
  #•	Точки входа могут быть: прямой запуск разных экранов, восстановление из фона, открытие по push notification и т.д.. Нужно учитывать все варианты и корректно обрабатывать запуск приложения;
  #•	Также важно обрабатывать изменения ориентации устройства, так как при этом все графические компоненты уничтожаются и создаются заново;
  #•	Основным компонентом приложения является Activity. Жизненный цикл приложения вызывает определённые функции-обработчики у системных компонентов, которые может переопределить в наследниках разработчик, реализуя жизненный цикл Activity;
  #•	Первый метод, который вызывается после старта приложения – метод onCreate() – здесь удобно инициализировать сторонние библиотеки или ресурсы;
  #•	Метод onConfigurationChanged() вызывается каждый раз при изменениях конфигурации OS – смена ориентации или локали и т.п.
  #
  #Активность (Activity)
  #•	Activity – фактически, это одно окно приложения;
  #•	Может занимать весь экран или какую-то его часть;
  #•	Может быть запущена из других компонентов приложения или из другого приложения;
  #•	Может возвращать результат работы;
  #•	Создаётся OS асинхронно;
  #•	Конфигурацию создания получает из файла: AndroidManifest.xml
  #
  #
  #
  #
  #•	onCreate() – вызывается тогда, когда Activity создана. Обычно устанавливается разметка;
  #•	Далее идет вызов onStart() – Activity появляется на экране и видима
  #•	onResume() – Activity работает/возобновляет работу;
  #•	При частичном перекрытии Activity (например, диалог) –
  #onPause();
  #•	Activity уходит на задний план – onStop();
  #•	onDestroy() вызывается при уничтожении Activity ОС Android. Может быть и не вызван вообще;
  #•	Желательно размещать логику симметрично: onCreate() – onDestroy(), onStart() – onStop(), onResume() – onPause().
  #
  #Жизненный цикл активности
  #Приложения Android не могут контролировать свой жизненный цикл, OS сама управляет всеми процессами и, как следствие, активностями внутри них. При этом, состояние активности помогает ОС определить приоритет родительского для этой активности Приложения (Application). А приоритет приложения влияет на то, с какой вероятности его работа (и работа дочерних активностей) будет прервана системой.
  #Стеки активностей
  #Состояние каждой активности определяется ее позицией в стеке (LIFO) активностей, запущенных в данный момент. При запуске новой активности представляемый ею экран помещается на вершину стека. Если пользователь нажимает кнопку «назад» или эта активность закрывается каким-то другим образом, на вершину стека перемещается (и становится активной) нижележащая активность.
  #
  #На приоритет приложения влияет его самая приоритетная активность. Когда диспетчер памяти ОС решает, какую программу закрыть для освобождения ресурсов, он учитывает информацию о положении активности в стеке
  #
  #Состояния активности
  #Активности могут находиться в одном из четырех возможных состояний:
  #1)	Активное (Active). Активность находится на переднем плане (на вершине стека) и имеет возможность взаимодействовать с пользователем. Android будет пытаться сохранить ее работоспособность любой ценой, при необходимости прерывая работу других активностей, находящихся на более низких позициях в стеке для предоставления необходимых ресурсов. При выходе на передний план другой активности работа данной активности будет приостановлена или остановлена.
  #
  #2)	Приостановленное (Paused). Активность может быть видна на экране, но не может взаимодействовать с пользователем: в этот момент она приостановлена. Это случается, когда на переднем плане находятся полупрозрачные или плавающие (например, диалоговые) окна. Работа приостановленной активности может быть прекращена, если ОС необходимо выделить ресурсы активности переднего плана. Если активность полностью исчезает с экрана, она останавливается.
  #
  #Состояние активности
  #3)	Остановленное (Stopped). Активность невидима, она находится в памяти, сохраняя информацию о своем состоянии. Такая активность становится кандидатом на преждевременное закрытие, если системе потребуется память для чего-то другого. При остановке активности разработчику важно сохранить данные и текущее состояние пользовательского интерфейса (состояние полей ввода, позицию курсора и т. д.). Если активность завершает свою работу или закрывается, он становится неактивным.
  #
  #4)	Неактивное (Inactive). Когда работа активности завершена, и перед тем, как она будет запущена, данная активности находится в неактивном состоянии. Такие активности удаляются из стека и должны быть (пере)запущены, чтобы их можно было использовать.
  #Изменение состояния приложения — недетерминированный процесс и управляется исключительно менеджером памяти Android. При необходимости Android вначале закрывает приложения, содержащие неактивные активности, затем остановленные и, в крайнем случае, приостановленные.
  #
  #
  #Сохранение состояния Activity
  #•	Когда уничтожается Activity:
  #o	Вызван метод finish();
  #o	Пользователь нажал кнопку «Назад» на устройстве;
  #o	Нехватка памяти, система освобождает ресурсы;
  #o	Поворот экрана;
  #•	Не очень хорошая идея хранить данные внутри Activity, так как они могут быть утеряны в разные моменты времени;
  #•	Объект типа Bundle – временное хранилище типа «ключ-значение»;
  #•	Сохранение состояния – метод onSaveInstanceState(Bundle state);
  #•	Восстановление состояния – метод onRestoreInstanceState(Bundle state);
  #
  #Схема работы приложения
  #•	Когда уничтожается Activity:
  #o	Вызван метод finish();
  #o	Пользователь нажал кнопку «Назад» на устройстве;
  #o	Нехватка памяти, система освобождает ресурсы;
  #o	Поворот экрана;
  #•	Не очень хорошая идея хранить данные внутри Activity, так как они могут быть утеряны в разные моменты времени;
  #•	Объект типа Bundle – временное хранилище типа «ключ-значение»;
  #•	Сохранение состояния – метод onSaveInstanceState(Bundle state);
  #•	Восстановление состояния – метод onRestoreInstanceState(Bundle state);
  #
  #Логирование
  #•	В Android есть удобное средство для работы с логами – панель: Logcat;
  #•	Для его использования есть класс Log со следующими статическими методами:
  #•	v() – verbose
  #•	d() – debug
  #•	i() – info
  #•	w() – warning
  #•	e() – error
  #•	Для удобства фильтрации стоит выбрать тэг – строку, которая передаётся первым аргументом. Второй аргумент – само сообщение;
  #•	Далее необходимо создать фильтр в панели Logcat, и будут видны только необходимые логи приложения:
  #
  #
  #
  #Основы разработки Android приложений
  #
  #
  #
  #Степанов Павел Валериевич
  #stepanov_p@mirea.ru
  #
  #Тема 2. Элементы пользовательского интерфейса UI.
  #
  #Простые View элементы
  #•	View – базовый класc всех View элементов
  #•	PlainText – поле для ввода текста
  #•	Button – кнопка
  #•	ImageView – изображение
  #•	ImageButton – ImageView + Button
  #•	TextView – текстовая метка
  #•	RadioButton – точки выбора (один из вариантов)
  #•	CheckBox – галочки выбора (множество вариантов)
  #•	Switch – переключатель (вкл/выкл)
  #•	ProgressBar – индикатор состояние
  #•	WebView – окно браузера
  #•	Spinner – выпадающий список
  #
  #
  #Элементы разметки
  #1.	Определяют порядок следования элементов интерфейса;
  #2.	Создаются с помощью XML/Drag & Drop;
  #3.	Разделение представления и логики;
  #4.	Типы layout-ов:
  #ConstraintLayout – каждый элемент обязан иметь привязку;
  #LinearLayout – элементы располагаются линейно; FrameLayout – элементы накладываются друг на друга в виде слоев;
  #TableLayout – элементы расположены в виде таблицы, по строкам и столбцам;
  #MotionLayout – фактически это подкласс ConstraintLayout, который позволяет с помощью XML описывать движения и анимацию расположенных на нём элементов.
  #RelativeLayout (legacy) – не используем;
  #GridLayout (legacy) – не используем;
  #
  #Constraints (привязка) — по факту это линии, на основе которых располагается View элементы внутри ConstraintLayout. Constraints могут быть привязаны
  #к сторонам самого ConstraintLayout или к сторонам других View элементов внутри ConstraintLayout.
  #Их можно разделить на вертикальные и горизонтальные.
  #Горизонтальные constraints:
  #-	правой стороны (Right), левой стороны (Left);
  #-	начальной стороны (Start), конечной стороны (End).
  #Вертикальные constraints:
  #-	верхней стороны (Top), нижней стороны (Bottom);
  #-	базовой линии (Baseline).
  #
  #<?xml version="1.0" encoding="utf-8"?>
  #<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
  #xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity">
  #<Button android:id="@+id/button"
  #android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="56dp" android:layout_marginTop="68dp" android:text="Button" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" />
  #
  #
  #
  #
  #<?xml version="1.0" encoding="utf-8"?>
  #<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
  #xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity">
  #<Button android:id="@+id/button"
  #android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.5" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintVertical_bias="0.5" />
  #</androidx.constraintlayout.widget.ConstraintLayout>
  #https://habr.com/ru/company/touchinstinct/blog/326814/
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #За горизонтальное расположение отвечает атрибут layout_constraintHorizonta l_bias, за вертикальное — layout_constraintVertical_b ias. Указывается относительное расположение значением от 0 до 1.
  #
  #Layout, при котором область вёрстки делится на строки, и в каждую строку помещается один элемент. Разбиение может быть вертикальное или горизонтальное, тип разбиения указывается в атрибуте android:orientation (по умолчанию – horizontal)
  #<?xml version="1.0" encoding="utf-8"?>
  #<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  #xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent“ android:layout_height="match_parent" android:orientation="vertical“ tools:context=".MainActivity">
  #<Button
  #android:id="@+id/button2“ android:layout_width="wrap_content" android:layout_height="wrap_content"  android:layout_weight="1"
  #android:text="Button" />
  #<Button android:id="@+id/button3"
  #android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" android:text="Button" />
  #</LinearLayout>
  #
  #Выравнивание элементов:
  #•	атрибут: android:gravity – расположение контента внутри элемента;
  #•	атрибут: android:layout_gravity – расположение элемента внутри родительского контейнера
  #
  #
  #•	обязательные атрибуты - android:layout_width/android:layout_height:
  #-	значение: wrap_content – по содержимому контента;
  #-	значение: match_parent – по размеру родителя;
  #
  #FrameLayout
  #Layout внутри которого может отображаться только один элемент в строке. Если внутри FrameLayout поместить несколько элементов, то следующий будет отображаться поверх предыдущего (по слоям). FrameLayout занимает всю доступную для него область.
  #<?xml version="1.0" encoding="utf-8"?>
  #<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
  #xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical“ tools:context=".MainActivity">
  #<View
  #android:layout_width="300dp" android:layout_height="300dp" android:background="#cc00ff"/>
  #<View
  #android:layout_width="200dp" android:layout_height="200dp" android:background="#00ffcc"/>
  #<View
  #android:layout_width="100dp"
  #
  #android:layout_height="100dp" android:background="#ffcc00"/>
  #</FrameLayout>
  #
  #https://www.geeksforgeeks.org/framelayout-in-android/
  #
  #Layout в виде табличной вёрстки:
  #•	Организация элементов в строки и столбцы таблицы;
  #•		Для организации строк служит тег <TableRow>, а количество столбцов определяется максимальным количеством элементов внутри одного из
  #<TableRow>;
  #•		В случае, если элемент должен занимать несколько ячеек, используется атрибут android:layout_span;
  #•		По умолчанию <TableRow> организует строки таблицы. Если нужны столбцы, то нужно использовать атрибут android:layout_column.
  #
  #
  #
  #
  #
  #
  #https://developer.android.com/guide/topics/ui/layout/grid
  #
  #<?xml version="1.0" encoding="utf-8"?>
  #<TableLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"
  #android:orientation="vertical" tools:context=".MainActivity">
  #<TableRow>
  #<TextView android:text="First Name"
  #android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_column="1" />
  #<EditText android:width="200px"
  #android:layout_width="wrap_content" android:layout_height="wrap_content" />
  #</TableRow>
  #</TableLayout>
  #
  #Layout, который расширяет ConstraintLayout и позволяет анимировать layouts между различными состояниями. А для создания анимации в большинстве случаев достаточно только вёрстки в файле XML.
  #MotionLayout был объявлен Google в Google I/O 2018, и это решение для уменьшения сложности создания сложных анимаций.
  #Благодаря внутреннему использованию ConstraintLayout MotionLayout может анимировать изменения цвета, альфа-переходы и представления, используя всего лишь один XML-файл.
  #
  #https://developer.android.com/develop/ui/views/animations/motionlayout
  #
  #https://developer.android.com/reference/android/support/constraint/motion/Mo tionLayout
  #
  #<androidx.constraintlayout.motion.widget.MotionLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/motionLayout" android:layout_width="match_parent" android:layout_height="match_parent" app:layoutDescription="@xml/scene_01" tools:showPaths="true">
  #<View
  #android:id="@+id/button" android:layout_width="64dp" android:layout_height="64dp" android:background="@color/colorAccent" android:text="Button" />
  #</androidx.constraintlayout.motion.widget.MotionLayout>
  #
  #Разметка:
  #<androidx.constraintlayout.motion.widget.MotionLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/motionLayout" android:layout_width="match_parent" android:layout_height="match_parent" app:layoutDescription="@xml/scene_01" tools:showPaths="true">
  #<View
  #android:id="@+id/button" android:layout_width="64dp" android:layout_height="64dp" android:background="@color/colorAccent" android:text="Button" />
  #</androidx.constraintlayout.motion.widget.MotionLayout>
  #
  #В этом файле лежит всё, что необходимо для создания анимации:
  #•	Root элемент MotionScene;
  #•	ConstraintSets — настройки для описания состояния экрана;
  #•	Transition — переход между состояниями;
  #•	KeyFrames и другие атрибуты.
  #<?xml version="1.0" encoding="utf-8"?>
  #<MotionScene xmlns:android="http://schemas.android.com/apk/res/android" xmlns:motion="http://schemas.android.com/apk/res-auto">
  #<Transition motion:constraintSetStart="@+id/start" motion:constraintSetEnd="@+id/end" motion:duration="1000">
  #<OnSwipe motion:touchAnchorId="@+id/button" motion:touchAnchorSide="right" motion:dragDirection="dragRight" />
  #</Transition>
  #
  #Файл сцены (часть 2)
  #<ConstraintSet android:id="@+id/start">
  #<Constraint android:id="@+id/button" android:layout_width="64dp" android:layout_height="64dp" android:layout_marginStart="8dp"
  #motion:layout_constraintBottom_toBottomOf="parent" motion:layout_constraintStart_toStartOf="parent" motion:layout_constraintTop_toTopOf="parent" />
  #</ConstraintSet>
  #<ConstraintSet android:id="@+id/end">
  #<Constraint android:id="@+id/button" android:layout_width="64dp" android:layout_height="64dp" android:layout_marginEnd="8dp"
  #motion:layout_constraintBottom_toBottomOf="parent" motion:layout_constraintEnd_toEndOf="parent" motion:layout_constraintTop_toTopOf="parent" />
  #</ConstraintSet>
  #</MotionScene>
  #
  #Инструмент для создания анимаций - MotionEditor. На экране редактора можно увидеть состояния start и end. Между ними стрелка, которая показывает переход между состояниями или Transiton.
  #Состояние до создания анимации:
  #
  #После создания анимации:
  #
  #
  #Файл сцены с изменениями. Начальное значение цвета блока View:
  #<?xml version="1.0" encoding="utf-8"?>
  #<MotionScene xmlns:android="http://schemas.android.com/apk/res/android" xmlns:motion="http://schemas.android.com/apk/res-auto">
  #….
  #<ConstraintSet android:id="@+id/start">
  #<Constraint android:id="@+id/button" android:layout_width="64dp" android:layout_height="64dp" android:layout_marginStart="8dp"
  #motion:layout_constraintBottom_toBottomOf="parent" motion:layout_constraintStart_toStartOf="parent" motion:layout_constraintTop_toTopOf="parent">
  #<CustomAttribute motion:attributeName="backgroundColor" motion:customColorValue="#D81B60" />
  #</Constraint>
  #</ConstraintSet>
  #
  #Файл сцены с изменениями. Конечное значение цвета блока View:
  #
  #<ConstraintSet android:id="@+id/end">
  #<Constraint android:id="@+id/button" android:layout_width="64dp" android:layout_height="64dp" android:layout_marginEnd="8dp"
  #motion:layout_constraintBottom_toBottomOf="parent" motion:layout_constraintEnd_toEndOf="parent" motion:layout_constraintTop_toTopOf="parent">
  #<CustomAttribute motion:attributeName="backgroundColor" motion:customColorValue="#9999FF" />
  #</Constraint>
  #</ConstraintSet>
  #</MotionScene>
  #
  #Больше MotionLayout
  #
  #https://www.kodeco.com/8883-motionlayout-tutorial-for-android-getting-started
  #
  #
  #
  #https://arsfutura.com/magazine/introduction-to-motionlayout-on-android/
  #
  #
  #
  #https://codelabs.developers.google.com/codelabs/motion- layout#6
  #
  #Основы разработки Android приложений
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Тема 3. Архитектурные компоненты ViewModel и LiveData. Графические ресурсы.
  #
  #Разметка ConstraintLayout предусматривает большое количество экранных элементов. Это значит, что в коде будет создано такое же количество переменных (под каждое активное представление) и все эти переменные необходимо будет связать с объектом экрана из xml- описания. То есть в методе onCreate() появляется малофункциональный блок вида:
  #
  #val view1 = findViewById<Type_view1>(R.id.view1)
  #...
  #val viewn = findViewById<Type_viewn>(R.id.viewn)
  #
  #Библиотека DataBinding производит "упаковку" экрана приложения в экземпляр класса, построенного на основании xml-описания макета экрана, тем самым инкапсулируя все экранные элементы в один объект.
  #
  #1.	Подключение библиотеки
  #Добавление библиотеки происходит в файле сборщика текущего модуля
  #build.gradle(Module) в разделе android { ... }
  #android {
  #...
  #buildFeatures { dataBinding true
  #}
  #}
  #2.	Описание класса по макету экрана
  #
  #Полями класса являются данные, которые будут изменяться в процессе работы приложения и выводиться в качестве значений экранных элементов. Все поля должны иметь начальную инициализацию, которая будет значением по умолчанию на случай, если в какое-либо поле не будет передано значение.
  #По разметке из трёх текстовых полей вывода и кнопке:
  #
  #….
  #<TextView android:id="@+id/textView"
  #android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" />
  #<Button android:id="@+id/button"
  #android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="168dp" android:layout_marginTop="68dp" android:text="Button" app:layout_constraintStart_toStartOf="parent"
  #app:layout_constraintTop_toBottomOf="@+id/textView" />
  #…
  #
  #один из вариантов описания класса следующий:
  #package ru.samsung.itschool.mdev.myapplication class UsingData(tf1: String) {
  #var tfield1 = tf1
  #}
  #
  #По факту полей в классе может быть и больше, так как в текстовые представления можно в качестве данных передавать вычислимые выражения: конкатенацию строк, арифметические выражения, логические выражения и т.п. Поскольку кнопка выступает управляющим элементом и не предназначается для вывода данных на экран, то её в поля класса добавлять не нужно.
  #
  #3.	Изменение макета
  #
  #Когда класс готов, можно перестраивать макет экрана под структуру класса. Для этого нужно:
  #•	Сделать корневым элементом объект <layout> и перенести в него все пространства имён;
  #•	Добавить в корневой элемент объект <data> и определить в нём переменную связываемого класса;
  #•	Установить выражения-связывания для подстановки в свойство android:text из полей объявленной в <data> переменной.
  #Для автоматического перевода файла макета экрана в формат data-binding нужно у корневой разметки вызвать контекстное меню и выбрать последовательность пунктов Show Context Actions (Alt+Enter) -> Convert to data binding layout.
  #В формате связывания данных файл разметки выглядит так:
  #
  #<?xml version="1.0" encoding="utf-8"?>
  #<layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools">
  #<data>
  #</data>
  #<androidx.constraintlayout.widget.ConstraintLayout
  #… ">
  #<TextView
  #... />
  #<Button
  #…/>
  #</androidx.constraintlayout.widget.ConstraintLayout>
  #</layout>
  #https://developer.android.com/topic/libraries/data-binding/expressions?hl=ru#expression_language
  #
  #Объект <data> содержит описание переменных и необходимых импортов пакетов. Каждая переменная и каждый импорт представляются отдельным объектом контейнера <data>.
  #Переменная служит для связывания макета с данными, по этому имеет тип построенного ранее класса. Для указания типа нужно прописать полный путь к этому классу:
  #<variable
  #name="mydata" type="ru.samsung.itschool.mdev.myapplication.UsingData" />
  #Можно создать переменные других типов:
  #<variable name="text" type="String" />
  #<variable name="number" type="Double" />
  #
  #4.	Связывание макета с данными
  #Теперь в методе onCreate() нужно заменить вызов setContentView() на объявление и инициализацию объекта связывания, тип данных которого будет иметь имя, составленное из имени xml-файла макета с приписанным окончанием Binding. Если xml-описание экрана размещается в файле sample.xml, то класс связывания будет именоваться SampleBinding.
  #То есть при создании data binding layout файла для него генерируется класс ИмяXMLфайлаBinding, на основании которого создаётся java-класс ИмяXMLфайлаBindingImpl, содержащий определения всех методов, применимых к объекту связывания.
  #Само связывание создаётся методом setContentView() вспомогательного класса DataBindingUtil:
  #
  #class MainActivity : AppCompatActivity() {
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState)
  #val bind: ActivityMainBinding = DataBindingUtil.setContentView(this,R.layout.activity_main)
  #bind.button.setOnClickListener {
  #}
  #bind.mydata = UsingData("Result")
  #}
  #}
  #
  #Библиотека DataBinding
  #Следующий пример при нажатии кнопки перечисляет месяцы первой
  #половины года с их порядковыми номерами
  #без использования библиотеки DataBinding
  #class MainActivity : AppCompatActivity() {
  #val tf1: Array<String> = arrayOf("jan", "feb", "mar","apr","may","jun") val tf2: Array<String> = arrayOf("январь", "февраль",
  #"март","апрель","май","июнь") var index = 0
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #val text1 = findViewById<TextView>(R.id.textView1) val text2 = findViewById<TextView>(R.id.textView2) val text3 = findViewById<TextView>(R.id.textView3) val button = findViewById<Button>(R.id.button) button.setOnClickListener({text2.text = tf1[index%6]
  #text3.text = tf2[index%6]
  #text1.text = ((index++)%6+1).toString()
  #})
  #} }
  #
  #Библиотека DataBinding
  #с использования библиотеки DataBinding
  #class MainActivity : AppCompatActivity() {
  #val tf1: Array<String> = arrayOf("jan", "feb", "mar","apr","may","jun") val tf2: Array<String> = arrayOf("январь", "февраль",
  #"март","апрель","май","июнь") var index = 0
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState)
  #val bind: ActivityMainBinding = DataBindingUtil.setContentView(this,R.layout.activity_main)
  #bind.button.setOnClickListener({ bind.mydata = UsingData(tf1[index%6],tf2[index%6],(index++)%6+1)})
  #}
  #}
  #Пример наглядно демонстрирует двукратное сокращение кода при небольшом количестве экранных элементов. Когда же речь идёт о сложных графических интерфейсах, применение библиотеки DataBinding оказывается более эффективным.
  #
  #Архитектурные компоненты в Android - набор библиотек, которые помогают разрабатывать легкие в поддержке, надежные и тестируемые приложения.
  #
  #https://developer.android.com/topic/architecture
  #
  #Архитектурные компоненты включают множество новых классов, таких как: LifecycleObserver, LiveData, ViewModel, LifecycleOwner, а также библиотеку Room для работы с базой данных приложения.
  #
  #Эти компоненты помогают разработчикам следовать надлежащему архитектурному шаблону проектирования, а также позволяют легко и безболезненно вносить изменения, избегая утечек памяти и обновлять пользовательский интерфейс при смене данных.
  #
  #В рамках данной темы мы рассмотрим два ключевых архитектурных компонента ViewModel и LiveData:
  #
  #LiveData — это наблюдаемый объект для хранения данных, он уведомляет наблюдателей, когда данные изменяются. Этот компонент также является связанным с жизненным циклом LifecycleOwner (Activity или Fragment), что помогает избежать утечек памяти и других неприятностей. Компонент LiveData — предназначен для хранения объекта и разрешает подписаться на его изменения.
  #
  #ViewModel — предназначен для хранения и управления данными, связанными с пользовательским интерфейсом, с учетом жизненного цикла. Класс ViewModel позволяет данным сохраняться при изменении конфигурации, например при повороте экрана.
  #Перед тем как рассмотреть названные архитектурные компоненты рассмотрим шаблон проектирования MVVM.
  #
  #Model-View-ViewModel (MVVM) — шаблон проектирования архитектуры приложения. Предложен в 2005 году Джоном Госсманом как модификация шаблона Presentation Model. Шаблон ориентирован на современные платформы разработки, в том числе Android.
  #Является альтернативой шаблонам MVC и MVP при использовании связывания данных Data Binding. Его суть состоит в отделении логики представления данных от логики приложения путем вынесения последней в отдельный класс для большего разграничения.
  #
  #https://www.thirdrocktechkno.com/blog/architecture-presentation-patterns-mvc-vs-mvp-vs- mvvm/
  #
  #Model - это логика, которая связанная с данными приложения. Другими словами - это POJO, классы для работы с API, базами данных и др.
  #View - это разметка экрана (layout), в которой расположены необходимые представления для отображения данных.
  #ViewModel - объект, в котором описана логика поведения View в зависимости от результата работы Model. В некоторой литературе этот объект называют моделью поведения View. Это может быть логика управления видимостью представлений, форматирование текста, отображение разнообразных состояний, таких как ошибки, загрузка и т.д. Также в ней описано поведение пользователей (свайпы, нажатия клавиш, касания и т.д.)
  #
  #
  #В итоге мы имеем гибкость разработки и рост эффективности работы в
  #команде, т.к. пока один разработчик описывает логику получения данных и их обработки, другой в это время работает над стилизацией экрана. Кроме этого такая структура значительно упрощает написание. В большинстве случаев исчезает потребность в автоматическом UI-тестировании, поскольку можно снабдить Unit-тестами сам ViewModel.
  #Используя архитектуру MVVM, код становится более простым, читабельным и легким в сопровождении, поскольку каждый программный модуль имеет свое конкретное назначение.
  #Кроме вышеперечисленных плюсов имеются и недостатки. Например, для небольших проектов этот подход может быть неоправданным. Если логика привязки данных слишком сложная - отлаживать приложение будет труднее.
  #Если MVVM реализован грамотно то это хороший способ разбить код и сделать его более тестируемым, это помогает следовать принципам SOLID, поэтому код легче поддерживать на всех этапах жизненного цикла приложения.
  #
  #Класс ViewModel
  #Одним из ключевых компонентов шаблона проектирования MVVM выступает класс ViewModel. Его основное предназначение - хранение и управление данными, связанными с интерфейсом пользователя, с учетом жизненного цикла Активности или Фрагмента.
  #Класс ViewModel позволяет данным отслеживать и адаптироваться к изменениям конфигурации устройств, таких например, как смена ориентации экрана.
  #
  #Чтобы импортировать ViewModel в проект Android, см. инструкции по объявлению зависимостей:
  #https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=ru#decla ring_dependencies
  #
  #Жизненный цикл ViewModel
  #
  #
  #
  #
  #
  #
  #
  #
  #
  #Из картинки видно, что ViewModel жизнеспособен, пока Activity окончательно не закроется .
  #При новом запуске Activity класс ViewModel все еще живет и задействован во вновь созданном Activity.
  #
  #Класс LiveData - хранилище информации, работающий по принципу шаблона проектирования Observer (наблюдатель). Данное хранилище играет две ключевые роли:
  #•	в него можно поместить какой-либо объект;
  #•	на него можно подписаться и получать изменения.
  #То есть во-первых пользователь может поместить объект в хранилище, во- вторых подписанные стороны могут получить эти изменения.
  #В качестве аналога можно привести, например, каналы в социальных сетях. Автор пишет сообщение, отправляет его , а все его подписчики получают это сообщение.
  #
  #Класс LiveData умеет определять активен подписчик или нет, и отправлять информацию будет только активным. Предполагается, что рассылка LiveData будет проводиться Activity и фрагментам. А их состояние активности будет определяться с помощью их жизненного цикла.
  #Он имеет ряд интересных характеристик:
  #•	предотвращает утечку памяти, когда наблюдатель привязан к жизненному циклу;
  #•	предотвращает сбои из-за остановки активности;
  #•	автоматически обрабатывает жизненный цикл;
  #•	при использовании LiveData код становится значительно проще для тестирования.
  #
  #Для статических изображений в приложениях можно задействовать класс
  #Drawable и его подклассы для.
  #Drawable - это общая абстракция для рисования. Различные его подклассы помогают в определенных ситуациях. Их можно расширить, чтобы задать собственные объекты рисования, которые ведут себя специальным образом.
  #Существует два способа создания экземпляра класса Drawable (кроме использования конструкторов):
  #1.	Обратиться к ресурсу изображения в проекте.
  #2.	Использовать ресурс XML, который определяет свойства для рисования.
  #Кроме растровых изображений возможно использование векторного рисования, что позволяет масштабировать рисунки для разных размеров без потери качества.
  #
  #В Android-приложения возможно добавить графику в ваше приложение, ссылаясь на файл изображения из ресурсов проекта. При этом поддерживаются следующие типы:
  #•	PNG (предпочтительно);
  #•	JPG (приемлемо);
  #•	GIF (не рекомендуется)
  #Таким образом удобно хранить иконки приложений, логотипы и т.п.
  #Чтобы задействовать изображения из ресурсов, нужно добавить картинку в каталог res/drawable/, а затем в коде приложения можно ссылаться на графический ресурс файла без расширения.
  #Если рисунок назывался test.png, то код может выглядеть следующим образом:
  #val myImage: Drawable = ResourcesCompat.getDrawable(context.resources, R.drawable.test, null)
  #
  #Следующий фрагмент кода демонстрирует, как создать ImageView, который использует изображение из ресурсов и размещает его в разметку:
  #class MainActivity : AppCompatActivity() {
  #private lateinit var constraintLayout: ConstraintLayout override fun onCreate(savedInstanceState: Bundle?) {
  #super.onCreate(savedInstanceState)
  #val bind: ActivityMainBinding = DataBindingUtil.setContentView(this,R.layout.activity_main)
  #// Создание экземпляра ImageView и определение его свойств val i = ImageView(this).apply {
  #setImageResource(R.drawable.ic_android_black_24dp) contentDescription = resources.getString(R.string.app_name)
  #//устанавливаем границы ImageView adjustViewBounds = true
  #layoutParams = ViewGroup.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
  #}
  #// Создаем ConstraintLayout, в который нужно добавить ImageView constraintLayout = ConstraintLayout(this).apply {
  #// Добавляем ImageView в разметку. addView(i)
  #}
  #// Добавляем в существующую разметку ImageView bind.root.addView(constraintLayout)
  #}
  #
  #При использовании графических ресурсов следует убедиться, что изображения имеют подходящий размер в пикселях. Для этого можно ознакомиться с рекомендациями:
  #https://developer.android.com/training/multiscreen/screendensities
  #Кроме указанного выше примера в приложениях возможно рисунков из XML- ресурсов: https://developer.android.com/reference/android/graphics/drawable/TransitionDr awable
  #использование форм для рисунков Shape Drawables: https://developer.android.com/reference/android/graphics/drawable/ShapeDrawa ble
  #использование растровых изображений, которое вы можете использовать в качестве фона представления NinePatch drawables: https://developer.android.com/reference/android/graphics/drawable/NinePatchDr awable
  #
  #Основы разработки Android приложений
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Тема 4. Отладка и тестирование Android приложений
  #
  #Отладка — это процесс определения и устранения причин ошибок. Чтобы понять, где возникла ошибка, приходится: узнавать текущие значения переменных; выяснять, по какому пути выполнялась программа. Отладка включает поиск дефекта и его исправление, причем поиск дефекта и его понимание обычно составляют 90% работы. В некоторых проектах процесс отладки занимает до 50% общего времени разработки. Существуют две взаимодополняющие технологии отладки:
  #
  #1)	Отладочный вывод и логирование (от англ. log — журнал событий, протокол). Текущее состояние программы логируется с помощью расположенных в критических точках программы операторов вывода.
  #
  #2)	Использование отладчиков. Отладчики позволяют пошагового выполнять программы оператор за оператором и отслеживать состояние переменных.
  #
  #Тестирование программного обеспечения — процесс исследования, испытания программного продукта, имеющий своей целью проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов, выбранных определённым образом.
  #
  #Тестирование - это проверка того, что программа или код работают правильно и надежно в различных условиях: вы «тестируете» свой код, предоставляя входные данные, стандартные правильные входные данные, преднамеренно неправильные входные данные, граничные значения, изменяющуюся среду.
  #
  #По сути, мы можем сказать, что вы пытаетесь обнаружить ошибки и в конечном итоге «отладить» их в процессе тестирования.
  #
  #Преимущества тестирования
  #•	Экономия ресурсов
  #Без грамотного подхода к тестированию количество ресурсов, необходимых для поддержания проекта в долгосрочной перспективе значительно больше, чем затраты на него.
  #•	Безопасность
  #При командной работе обеспечивается безопасность кода: разные разработчики с течением времени меняют один и тот же фрагмент кода, при этом наличие тестов делает это более безопасным, так как никто не сможет что-то «испортить», не узнав об этом.
  #•	Улучшенная архитектура
  #При тестировании приложений их создают обычно с
  #использованием шаблонов проектирования, чтобы сделать приложения максимально простым и тестируемым.
  #•	Качество кода
  #Приложение в меньшей степени подвержено сбоям в работе так как тесты помогают писать более надёжный код.
  #•	Улучшенный рефакторинг
  #Наличие хороших тестов позволяет модифицировать определённый код, проверяя, что тесты все ещё успешно проходят.
  #
  #Логирование основано на включении в программу дополнительных отладочных выводов в местах, где меняются значения переменных (узловые точки).
  #Например, если вы пишите консольную программу, то для ее отладки можно выводить промежуточные значения переменных. Зачастую это помогает найти ошибки в коде и исправить их. В Android для логирования есть специальный класс android.util.Log.
  #class MainActivity : AppCompatActivity() { private val LOG_TAG = "MyActivity"
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(LOG_TAG, "Creating view..") setContentView(R.layout.activity_main) Log.d(LOG_TAG, "View created!")
  #}
  #}
  #
  #Для просмотра этой информации нужно запустить проект и открыть вкладку с
  #LogCat.
  #
  #
  #Класс Log разбивает сообщения по категориям в зависимости от важности. Для этого используются специальные методы, которые легко запомнить по первым буквам, указывающим на категорию:
  #•	Log.e() – ошибки (error);
  #•	Log.w() – предупреждения (warning);
  #•	Log.i() – информация (info);
  #•	Log.d() – отладка (debug);
  #•	Log.v() – подробности (verbose).
  #В первом параметре представленных методов класса Log используется строка, называемая тегом. В качестве тега обычно задают имя класса, название библиотеки или название приложения. Обычно принято объявлять глобальную статическую строковую переменную, и уже в любом месте вашей программы вы вызываете нужный метод записи в Log с этим тегом, например:
  #Log.d(LOG_TAG, "View created!")
  #
  #Если в коде использовать метод Log.e(), то строчка будет выделена красным цветом. Также мы можем отображать сообщения по уровням: VERBOSE, DEBUG, INFO, WARN, ERROR и ASSERT.
  #Если выбрать уровень сообщений ERROR, то будут выводиться сообщения, сгенерированные c уровнем ERROR и ASSERT. Если выбрать VERBOSE, то будут выводиться все сообщения.
  #Как правило, в серьезных приложениях в режиме тестирования постоянно логируется информация об обращении к сторонним сервисам API, обращении к базе данных, при возникновении нестандартных ситуаций и т.д. При выкладывании приложения в маркеты рекомендуется отключать всю отладочную информацию.
  #
  #Например, в onCreate() установим точку останова (breakpoint). Для этого нужно поместить курсор на нужную строчку метода и щелкнуть левой кнопкой мыши слева от номера строки.
  #
  #На строке кода, где установлен breakpoint, появится кружок. Теперь запустим выполнение в режиме отладки. Для этого нужно нажать на кнопку с жучком, либо выбрать из меню Run -> Debug ‘app’, либо нажать на клавиатуре Shift + F9. После запуска приложения Android Studio автоматически откроет вид отладки.
  #
  #
  #
  #
  #Идея модульного тестирования заключается в написании тестов для всех нетривиальных методов, что позволяет оперативно проверять корректность уже протестированного кода после очередной его модификации. Цель модульного тестирования — исключить из поиска ошибок отдельные части программы путем их автоматической проверки на заранее написанных тестах.
  #Локальные модульные тесты (unit-тесты) проверяют работу метода, класса, компонента. По сути вы тестируете код, который можно проверить без применения устройства или эмулятора. Подобные тесты находятся в папке Test проекта. Для создания для юнит-тестов можно использовать следующие инструменты:
  #
  #
  #JUnit – это фреймворк, предназначенный для тестирования программ, разработанных с использованием технологии Java.
  #Ключевая идея фреймворка – “сначала тесты, потом код”. Поэтому сначала необходимо определить результат работы того или иного раздела приложения и написать тесты, которые проверяют идентичность результата с требуемым, а только после этого написать сам код, который и будет тестироваться. Такой подход увеличивает эффективность работы разработчика и позволяет писать более стабильный код, особенно при работе в команде над большими проектами.
  #
  #Тестовый случай (Test Case) в юнит тестировании – это код, который проверяет работу другого кода (класса, метода и т.п.) в соответствии с заданными требованиями. Тестовый случай характеризуется известными входными данными и ожидаемым выводом программы. При разработке необходимо предусмотреть как минимум, два тестовых случая для каждого требования – отрицательный и положительный.
  #
  #Например, создадим класс Calculator, который выполняет сложение чисел. Для простоты будем использовать тип Int.
  #class Calculator {
  #fun add(a: Int, b: Int): Int { return a + b
  #}
  #}
  #В папке Test создадим файл CalculatorTest.kt и добавим в него следующий код, импортировав необходимые библиотеки.
  #
  #import org.junit.Assert import org.junit.Before import org.junit.Test
  #class CalculatorTest {
  #private var calculator: Calculator? = null @Before
  #fun setUp() {
  #calculator = Calculator()
  #}
  #@Test
  #fun addition() {
  #Assert.assertEquals(3, calculator!!.add(1, 2).toLong())
  #}
  #@After
  #fun tearDown() { calculator = null
  #}
  #}
  #
  #Любая функция с аннотацией @Test в JUnit считается отдельным тестом. Функция addition() будет вызвана при запуске тестирования для проверки работы add() класса Calculator.
  #Код функции с аннотацией @Before будет выполняться перед выполнением каждой тестовой функции. Соответственно, код с аннотацией @After будет выполняться после каждой функции. Эти функции нужны для того, чтобы подготовить какие-то параметры или объекты к тестам (например, вынести тестируемый объект в поле класса и инициализировать его в setUp() вместо того, чтобы выполнять инициализацию в каждой тестовой функции) или же очистить ресурсы после окончания тестовой функции.
  #
  #Чтобы запустить модульный тест по умолчанию, выберите CalculatorTest в студии Android, щелкните правой кнопкой мыши по нему и затем нажмите « Run CalculatorTest».
  #
  #
  #
  #Запустив тест, мы получим сообщение о том, что
  #тест успешно пройден
  #
  #
  #Если поменять код и вместо цифры 3 поставить цифру 4:
  #
  #@Test
  #fun addition() {
  #Assert.assertEquals(4, calculator!!.add(1, 2).toLong())
  #}
  #
  #
  #Кроме функции addition(), мы можем в тестовом классе создать и другие
  #@Test функции для тестирования. Так, можно настроить тест на ожидаемое исключение используя параметр expected:
  #@Test(expected = NullPointerException::class) fun nullStringTest() {
  #val str: String? = null assertTrue(str!!.isEmpty())
  #}
  #В таком случае тест выполнится, т.к. это исключение мы ожидали. Если поменяем исключение, например на IOException, тест будет провален. Для длинных операций можно также указать параметр timeout и установить значение в миллисекундах. Если метод не выполнится в течение заданного времени, тест будет считаться проваленным:
  #@Test(timeout = 1000) fun requestTest() {}
  #
  #Mockito
  #Фреймворк Mockito предназначен для создание заглушек, которые можно использовать при написании Unit тестов вместо реальных классов или интерфейсов.
  #Официальный сайт: https://site.mockito.org/
  #С помощью Mockito разработчик создает имитатор — мок, указывает библиотеке, что делать при вызове определенных методов, а затем использует экземпляр имитатора в своем тесте вместо реального объекта. По умолчанию Mockito предоставляет реализацию для каждого метода mock. После тестирования можно запросить mock, чтобы узнать, какие конкретные методы были вызваны, или проверить побочные эффекты в виде изменения состояния.
  #Примеры: https://github.com/mockito/mockito-kotlin
  #
  #Это тестирование не отдельных компонентов системы, а результата их взаимодействия между собой в какой-либо среде.
  #Упор делается именно на тестировании взаимодействия. Так как интеграционное тестирование производится после модульного, то все проблемы, обнаруженные в процессе объединения модулей, скорее всего, связаны с особенностями их взаимодействия.
  #Вначале описывается план тестирования, подготавливаются тестовые данные, создаются и исполняются тест-кейсы (пошаговые действия для тестирования определенного функционала системы). Найденные ошибки исправляют и снова запускают тестирование. Цикл повторяется до тех пор, пока взаимодействие всех компонентов не будет работать без ошибок.
  #
  #Для того чтобы автоматизировать интеграционное тестирование, используются системы непрерывной интеграции (англ. continuous Integration System, CIS). CIS проводит мониторинг исходных кодов.
  #Как только разработчики выкладывают обновление кода, выполняются различные проверки и модульные тесты. Далее проект компилируется и проходит интеграционное тестирование. Выявленные ошибки включаются в отчет тестирования.
  #Автоматические интеграционные тесты выполняются сразу после внесения изменений. Это существенно сокращает время поиска и устранения ошибок.
  #
  #
  #Разделяется на 2 этапа:
  #Альфа-тестирование — имитация реальной работы с системой разработчика, либо реальная работа с системой, ограниченной кругом потенциальных пользователей.
  #Бета-тестирование — в некоторых случаях выполняется распространение предварительной версии для некоторой группы лиц с тем, чтобы убедиться, что продукт содержит достаточно мало ошибок. Иногда бета-тестирование выполняется для того, чтобы получить обратную связь о продукте от его будущих пользователей.
  #
  #Кроме тестирования по этапам выделяют также классификацию по объектам тестирования:
  #1.	Тестирование удобства пользования продуктом;
  #2.	Оценка уязвимости программного обеспечения к различным атакам;
  #3.	Проверка перевода пользовательского интерфейса, документации и сопутствующих файлов программного обеспечения на различных языках;
  #4.	Проверка скорости работы системы под определенной нагрузкой.
  #
  # тестировании производительности выделяют следующие направления:
  #•	Нагрузочное тестирование. Оценивают поведение программы под заданной ожидаемой нагрузкой. Такой нагрузкой зачастую выступает, например, ожидаемое число одновременно работающих пользователей, которые совершают определенное количество действий за заданный интервал времени.
  #•	Стресс-тестирование. С его помощью обычно исследуют пределы пропускной способности программы. Стресс-тестирование позволяет определить «узкие места» системы, которые вероятнее всего приведут к сбоям системы в пиковой ситуации. Проверка правильности работы программы осуществляется на большом количестве случайно сгенерированных данных.
  #
  #Дополнительные материалы
  #https://vc.ru/dev/199012-bystryy-start-gayd-po-avtomatizirovannomu- testirovaniyu-dlya-android-razrabotchika-jvm
  #
  #
  #https://kotest.io/ https://habr.com/ru/company/nspk/blog/520380/
  #
  #
  #https://gb.ru/posts/testirovanie-v-android-chast-1-vvedenie
  #
  #Основы разработки пользовательского интерфейса Android приложений
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Список тем дисциплины
  #1.	Понятие Activity и Intent. Фрагменты в Android.
  #2.	Списки в Android. Создание списков элементов с помощью RecyclerView. Навигация в Android приложениях.
  #3.	Тестирование пользовательского интерфейса в Android приложениях. Часть 1.
  #4.	Тестирование пользовательского интерфейса в Android приложениях. Часть 2.
  #
  #Тема 1. Понятие Activity и Intent. Фрагменты в Android.
  #
  #Активность (Activity)
  #•	Activity – фактически, это одно окно приложения;
  #•	Может занимать весь экран или какую-то его часть;
  #•	Может быть запущена из других компонентов приложения или из другого приложения;
  #•	Может возвращать результат работы;
  #•	Создаётся OS асинхронно;
  #•	Конфигурацию создания получает из файла: AndroidManifest.xml
  #
  #Жизненный цикл активности
  #
  #
  #Класс android.context.Context представляет из себя интерфейс для доступа к
  #глобальной информации об окружении приложения. Это абстрактный класс, реализация которого обеспечивается системой Android. Например:
  #Toast.makeText(applicationContext, text, duration)
  #Context позволяет получить доступ к ресурсам и классам данного приложения, а также необходим для вызова операций на уровне приложения, таких как запуск активностей (Activity), отправка широковещательных сообщений, получение намерений (Intent) и прочее. Например, вы можете получить доступ к локальному хранилищу настроек (SharedPreferences) используя контекст:
  #val sharedPreferences: SharedPreferences = context.getSharedPreferences("MY_PREFS", Context.MODE_PRIVATE)
  #Получить ссылку на текущую активность можно несколькими способами:
  #•	с помощью ключевого слова this (если обращаетесь из метода активности)
  #•	функцией getApplicationContext()
  #
  #Intents
  #Намерения (Intents) в Android позволяют передавать сообщения, вызывать другие активности и приложения. Этот механизм может работать как внутри одного приложения, так и между приложениями, например:
  #•	запуск какой-либо активности или сервиса для выполнения определенных действий
  #•	извещение о событии
  #•	явный запуска указанного сервиса или активности
  #Явное намерение содержит вызов определённого (заранее известного) класса. При использовании явного намерения указываются:
  #•	контекст, из которого будет сделан вызов
  #•	класс вызываемого компонента (сервис или активность)
  #•	дополнительные сведения (extras), если это необходимо
  #Вызов активности осуществляется методом startActivity(), которому передаётся экземпляр Intent.
  #Передача данных между активностями напрямую не рекомендуется (хотя это возможно). Для этого стоит использовать методы getExtra()/putExtra() в намерении.
  #
  #Явные намерения
  #
  #
  #
  #Android даёт широкие возможностями для использования "внешних"
  #приложений, например: /
  #
  #•	телефонная книга,
  #•	географическая карта,
  #•	выбор изображения из галереи
  #•	камеры.
  #
  #Направления вызова (интента) вовне вашего приложения реализуется с помощью неявных интентов. Удобно, что каждому разработчику не нужно создавать с нуля требуемую функциональность, например, реализовывать телефонный вызов.
  #
  #Неявные намерения
  #При создании объекта Intent вместо класса компоненты вы указываете тип действия, категорию и адрес (или дополнительные сведения) для вызова стороннего приложения.
  #
  #Система проводит поиск приложений, которые смогут обработать такой вызов. Если находится несколько соответствующих условию активностей, пользователю предоставляют выбор, какой именно программой вы хотите воспользоваться.
  #
  #Android сверяет набор параметров вызываемого объекта Intent и наборы параметров Intent Filter для каждой активности. Если наборы совпадают, то активность считается подходящей. Схематично вызов неявного интента можно изобразить следующим образом:
  #
  #
  #
  #
  #Механизм вызова неявного интента очень похож на запрос web-страницы: вы так же указываете Uri и действие (action), которое нужно выполнить. В вашем распоряжении сотни различных констант вида ACTION_..., например:
  #•	ACTION_VIEW - показать или обработать содержимое произвольного Uri (веб- страница, гео-точка, номер телефона),
  #•	ACTION_PICK - выбор объекта из хранилища или коллекции
  #•	ACTION_SEND - передача объекта в другое приложение, например, отправка SMS или публикация фото в Instagram
  #
  #Возврат результата из активности
  #В ряде случаев требуется не только вызвать другую активность или приложение,
  #но и получить из него сведения: контакты, изображения, файл, ссылку и т.п. Для возврата результата в исходную активность мы используем асинхронный механизм, т.е. после вызова активности приложение может продолжить работу ожидая возвратного вызова.
  #fun openSomeActivityForResult() {
  #val intent = Intent(this, MainActivity2::class.java) resultLauncher.launch(intent)
  #}
  #var resultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
  #if (result.resultCode == Activity.RESULT_OK) { val data: Intent? = result.data doSomeOperations()
  #}
  #}
  #
  #Введение в фрагменты
  #
  #Фрагменты — одно из главных нововведений Android 3 (начиная с API 11). Их главное назначение — обеспечение большей динамичности
  #и гибкости пользовательских интерфейсов на больших экранах, например, у планшетов. Можно рассматривать их как встроенные в активности элементы, которые располагаются
  #в основном Activity и имеют свой жизненный цикл, немного отличающийся от обычного, уже знакомого нам жизненного цикла Activity.
  #
  #Фрагмент (класс Fragment) — это часть пользовательского интерфейса в Activity. Разработчик может размещать в одной активности несколько фрагментов для построения удобного пользовательского интерфейса.
  #Возможно повторное использование фрагментов в нескольких активностях. Фрагменты можно добавлять или удалять непосредственно во время выполнения:
  #
  #Рассмотрим приложение, которое отображает список, при этом пользователь при выборе элемента списка получает дополнительную информацию в виде детализации к элементу списка.
  #Одним из вариантов реализации интерфейса такого приложения является использование двух активностей: одна активность — для управления списком, другая — для детализации.
  #Однако, если мы возьмем планшет в альбомной ориентации, то представление одного лишь списка на экране будет неэстетично и нерационально, потому что образуется много нефункционального пространства.
  #Второй вариант построения интерфейса более логичен: список и его детализацию выводить на один экран в следующем виде
  #
  #
  #
  #Проще всего, фрагменты разместить статически, то есть прописать их прямо в XML-
  #коде активности. Делается это при помощи:
  #<androidx.fragment.app.FragmentContainerView>
  #В xml разметке:
  #<?xml version="1.0" encoding="utf-8"?>
  #<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical">
  #<androidx.fragment.app.FragmentContainerView android:id="@+id/fragment" android:name="ru.samsung.itschool.mdev.myapplication.BlankFragment" android:layout_width="match_parent"
  #android:layout_height="0dp" android:layout_weight="1">
  #</androidx.fragment.app.FragmentContainerView>
  #</LinearLayout>
  #
  #
  #
  #
  #Все преимущества фрагментов раскрываются при их динамическом изменении в процессе работы приложения.
  #Динамически фрагмент размещается практически как обычный View.
  #Для удобного управления фрагментами, каждый помещают в свой контейнер. Часто для размещения фрагментов используют контейнеры FrameLayout:
  #В разметке:
  #<FrameLayout android:id="@+id/fragment" android:layout_width="match_parent" android:layout_height="match_parent" />
  #Для динамической смены фрагментов используют объект supportFragmentManager,
  #который есть у каждой активности.
  #
  #Работа с фрагмент-менеджером обычно начинается с команды beginTransaction()
  #и заканчивается командой commit().
  #Обратите внимание: стоит проверять savedInstanceState на null, то есть проверять, что активность создается первый раз, а не восстанавливается. В ином случае фрагменты будут добавляться повторно.
  #Самые часто используемые методы supportFragmentManager:
  #•	add()/remove() добавляет/удаляет фрагмент к/из активности,
  #•	replace() заменяет один фрагмент на другой,
  #•	hide()/show() делает невидимым и видимым
  #Методы remove()и replace() не применимы к статичным фрагментам.
  #
  #Создадим еще один простейший фрагмент:
  #class ImageFragment : Fragment() { override fun onCreateView(
  #inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
  #): View? {
  #// Inflate the layout for this fragment
  #return inflater.inflate(R.layout.fragment_test_image, container, false)
  #}
  #}
  #
  #Разметка с изображением:
  #<?xml version="1.0" encoding="utf-8"?>
  #<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".TestImageFragment">
  #
  #<ImageView android:id="@+id/imageView" android:layout_width="match_parent" android:layout_height="match_parent" android:src="@mipmap/ic_launcher" />
  #</FrameLayout>
  #
  #В onCreate() разместим первый фрагмент:
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #if (savedInstanceState == null) { supportFragmentManager.beginTransaction()
  #.add(R.id.fragment, DefaultFragment())
  #.commit()
  #}
  #findViewById<FrameLayout>(R.id.fragment).setOnClickListener{ supportFragmentManager.beginTransaction()
  #.replace(R.id.fragment, ImageFragment()).commit()
  #}
  #}
  #}
  #
  #Теперь при нажатии на экран текстовый фрагмент заменяется на фрагмент с картинкой:
  #
  #
  #Основы разработки пользовательского интерфейса Android приложений
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Тема 2. Списки в Android.
  #Создание списков элементов с помощью RecyclerView.
  #Навигация в Android приложениях.
  #
  #Отображение информации в виде прокручиваемого списка или
  #сетки элементов – один из наиболее часто встречающихся элементов UI на платформе Android. Списки встречаются в подавляющем большинстве приложений. Это могут быть достаточно простые списки: контактов в телефонном справочнике, покупок в приложении какого-либо интернет магазина, фотографий. Или более сложные списки, которые отображают много дополнительной информации
  #Из-за повсеместного использования списков крайне важно, чтобы:
  #•	их отображение было быстрым;
  #•	задействование ресурсов устройства было минимально необходимым;
  #•	при изменении элементов не происходило обновление всего списка, а лишь тех элементов, которым действительно необходимо обновление.
  #
  #Все «пожелания» учтены в виджете RecyclerView:
  #•	по умолчанию RecyclerView выполняет работу по отрисовке только тех элементов списка, которые видны на экране в данные момент времени. Например, если Ваш список состоит из нескольких тысяч элементов, но в текущий момент времени на экране видны лишь 10, RecyclerView выполнит работу достаточную для отображения именно видимых на данный момент 10 элементов;
  #•	одной из самых «дорогих» операций является создание элементов интерфейса и процесс надувания разметки в объект класса, который отвечает за эту разметку. В тот момент, когда элемент списка исчезает с экрана устройства, RecyclerView не уничтожает элементы интерфейса участвующие в отображении элемента списка, а, как следует из названия виджета, «перерабатывает» их. Это значит, что эти элементы могут быть использованы повторно в будущем при отображении других элементов набора данных;
  #•	при изменении элементов набора данных, RecyclerView позволяет обновлять лишь те элементы списка, которые в этом действительно нуждаются.
  #
  #RecyclerView
  #
  #
  #https://www.topcoder.com/thrive/articles/android-recyclerview-and-cardview
  #
  #
  #•	RECYCLERVIEW.ITEMANIMATOR
  #используется для анимации элементов или view-компонентов внутри RecyclerView
  #•	RECYCLERVIEW.ITEMDECORATOR
  #используется для декорирования элементов списка в RecyclerView
  #•	RECYCLERVIEW.VIEWHOLDER
  #для хранения данных в классе адаптера определен статический класс ViewHolder, который использует определенные в разметке элементы управления
  #
  #RecyclerView classes
  #•	RECYCLERVIEW.LAYOUTMANAGER
  #менеджер компоновки представляет объект, который представлен этим классом. По умолчанию библиотека RecyclerView предоставляет три реализации данного менеджера:
  #1.	LinearLayoutManager: упорядочивает элементы в виде списка с одной колонкой
  #2.	GridLayoutManager: упорядочивает элементы в виде сетки со столбцами и строками. Сетка может упорядочивать элементы по горизонтали или по вертикали.
  #3.	StaggeredGridLayoutManager: аналогичен GridLayoutManager, однако не требует установки для каждого элемента в строке имели одну и ту же высоту (для вертикальной сетки) и одну и ту же ширину (для горизонтальной сетки).
  #
  #
  #
  #
  #
  #
  #
  #•	RECYCLERVIEW.ADAPTER:
  #связывает данные с компонентом и отслеживает изменения:
  #1.	notifyItemInserted(), notifyItemRemoved(), notifyItemChanged() - методы, отслеживающие добавление, удаление или изменение позиции одного элемента;
  #2.	notifyItemRangeInserted(), notifyItemRangeRemoved(), notifyItemRangeC hanged() - методы, отслеживающие изменение порядка элементов;
  #
  #Общая модель работы RecyclerView
  #
  #
  #
  #
  #Доп. материалы и примеры
  #
  #https://developer.android.com/codelabs/basic-android-kotlin-training-recyclerview- scrollable-list#0
  #
  #https://developer.android.com/develop/ui/views/layout/ recyclerview
  #
  #
  #https://github.com/pavlentytest/RecyclerSample
  #
  #Виды навигации в Android
  #Современные принципы разработки интуитивно понятного мобильного интерфейса, фактически закрепленные в рекомендациях по Material дизайну, также не обошли вниманием и вопросы навигации.
  #Навигация - это процесс замены текущего интерфейса приложения на экране пользователя на другой в процессе взаимодействия пользователя с UI.
  #Иначе говоря это переключение layout-ов в соответствии с действиями пользователя и логики работы программы.
  #Есть разные классификации процессов навигации. В зависимости от точки зрения выделить следующие группы:
  #
  #Навигация между различными экранами и приложениями является основной частью взаимодействия с пользователя с системой. Соответственно пользователь может выполнять следующие управляющие действия:
  #
  #
  #
  #•	Иерархическая навигация. Зачастую это навигация "вниз- вверх". Т.е. из текущего экрана пользователь переходит на экран какой то подзадачи, подчиненной текущей. Нажав кнопку вверх, пользователь осуществляет передвижение к более верхнему в иерархии интерфейса окну. Такую иерархическую навигацию довольно сложно осуществить, поэтому часто иерархическая навигация заменяется навигацией по стеку;
  #
  #•	Боковая навигация используется для перемещения пользователя по экранам находящимся на одном уровне. Т.е. пользователь переходит влево или в право, перебирая экраны один за другим. Обычно переключение производится путем смахивания экрана влево или в право, либо прокручивания панели закладок (Bezel), либо выбора закладки на панели закладок. При этом на панели видно, какую часть информации просматривается в данный момент. Такой метод представления информации рекомендуется либо для представления структурированной одноуровневой информации, которой слишком много чтобы представить в одном окне, но легко можно разделить на последовательный блоки. Также используют для представления master-detail информации;
  #
  #•	Навигация по стеку возврата. При этом виде навигации, при нажатии кнопки назад пользователь последовательно переходит на экраны интерфейса, которые он открывал раньше, в порядке обратном хронологическому;
  #•	Глубокие ссылки - это возможность переходить из экрана одного приложения прямо в конкретно указанный экран другого приложения.
  #
  #С точки зрения пользователя нет никакой разницы, какими именно способами обеспечивается навигация. Ему важно чтобы это было интуитивно понятно, и поэтому важно, чтобы элементы поддерживали принципы Material Design, а также чтобы структура переходов была унифицирована. Например:
  #•	кнопка "домой" - должна всегда приводить на один и тот же начальный экран;
  #•	кнопка "назад" - делает строго обратный по хронологии (backstack) переход по экранам, вне зависимости от их иерархии и при достижении начала цепочки может позволять выход из приложения;
  #
  #•	кнопка "вверх", должна поднимать пользователя по иерархии, но не должна делать выход из приложения, когда достигнут верхний уровень;
  #•	свайп используется либо для перелистывания Bezel (панель прокрутки вкладок) либо для перелистывания master-detail окон;
  #•	использовать нестандартные управляющие элементы нежелательно, как например двойной или тройной клик.
  #
  #С точки зрения разработчика
  #По цели навигации:
  #•	переход на новый фрагмент,
  #•	переход на новую активность,
  #•	переход на другое приложение.
  #По элементам, обеспечивающих навигацию:
  #•	кликабельные UI элементы (Button, ImageButton, пункты списков и т.д.),
  #•	навигационные UI элементы (меню активности, боковая панель Drawer, TopAppBar, ToolBar, BottomNavigation),
  #•	свайпы, управление стеком возврата.
  #
  #Navigation API
  #На ежегодной конференции разработчиков, проводимой Google в Маунтин-Вью, штат Калифорния, в 2018 году был представлен Android Jetpack. Это следующее поколение компонентов Android, которые при сохранении обратной совместимости, позволяет быстро и легко создавать надежные, высококачественные приложения. В его состав в том числе вошли новое Navigation API а также существенно модернизированные стандартные навигационные UI компоненты.
  #В настоящее время можно пользоваться как старыми программными конструкциями для организации навигации так и возможностями нового API навигации. Если о классических приемах было сказано ранее в этом модуле то в этой главе рассмотрим использование именно нового API. Его использование дает множество преимуществ:
  #
  #На ежегодной конференции разработчиков, проводимой Google в Маунтин-Вью, штат Калифорния, в 2018 году был представлен Android Jetpack. Это следующее поколение компонентов Android, которые при сохранении обратной совместимости, позволяет быстро и легко создавать надежные, высококачественные приложения. В его состав в том числе вошли новое Navigation API а также существенно модернизированные стандартные навигационные UI компоненты.
  #В настоящее время можно пользоваться как старыми программными конструкциями для организации навигации так и возможностями нового API навигации. Если о классических приемах было сказано ранее в этом модуле то в этой главе рассмотрим использование именно нового API. Его использование дает множество преимуществ:
  #
  #•	создание единого графического представление всего графа переходов;
  #•	контроль переходов в приложении на соответствии построенной схеме;
  #•	унификация и упрощения перехода к новой активности или фрагменту, а также передаче им данных;
  #•	модифицированные навигационные элементы UI теперь интегрированы с новым механизмом навигации, вследствие чего нужно писать значительно меньше кода при их реализации;
  #•	упрощение описания deeplink;
  #•	за счёт упрощения программирования переходов разрабатывать сложное приложение станет легче и быстрее, особенно это заметно в случае если нужно быстро переделать схему переходов.
  #
  #Доп. материалы и примеры
  #
  #
  #https://developer.android.com/guide/navigation
  #
  #https://developer.android.com/guide/navigation/navigation-getting-started
  #
  #https://github.com/pavlentytest/Navi gationBasicSample
  #
  #Основы разработки пользовательского интерфейса Android приложений
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Тема 3. Тестирование пользовательского интерфейса в Android приложениях.
  #
  #Unit-тесты
  #Это тесты, которые должны проверять всю работу классов и методов класса в максимальном количестве случаев: нормальная работа, работа с ошибками, с нестандартными данными и т. п. Когда вы добавляете новые методы в класс или изменяете существующие — обязательно пишите к ним новые тесты и обновляйте уже написанные. Если тесты используют какие-то части фреймворка Android, для их написания пользуйтесь помощью androidx.test.
  #
  #Robolectric
  #Эта библиотека используется для тестирования кода, завязанного на платформу Android (компоненты Android, ресурсы и т. д.) и запускает их на внутренней эмуляции устройства. Вам даже не нужно запускать приложение на эмуляторе или реальном устройстве, чтобы прогнать тесты, что очень удобно и экономит много времени. Поддерживаются тесты для API 16 и выше. Robolectric позволяет тестировать код платформы Android, касающийся компонентов с жизненным циклом; ресурсов приложения.
  #
  #Инструментальные тесты – это тесты, работающие на реальных
  #устройствах или эмуляторах которые благодаря этому могут использовать все возможности системы Android. Такие тесты нужны в первую очередь для модульных тестов, когда для них требуется использование каких-либо классов Android. Сюда относится тестирование работы с базой данных, с SharedPreferences, с Context и другими классами. Поскольку в нашем курсе пишем Android-приложения, то без классов, которые которые взаимодействуют с классами из Android API не обойтись.
  #Для инструментальных тестов наличие устройства или эмулятора обязательно. Они позволяют тестировать взаимодействие пользователя с UI (нажатие кнопки, ввод текста, прокрутку, касания и другие операции).
  #
  #Инструментальные тесты проекта располагаются в папке
  #/src/androidTest/java/. Поскольку инструментальные тесты располагаются отдельно от вашего приложения APK, они должны иметь свой собственный AndroidManifest.xml файл. Однако Gradle автоматически генерирует этот файл во время сборки, поэтому он не отображается в исходном проекте. При необходимости вы можете добавить свой собственный файл манифеста, например указать другое значение для minSdkVersion. При создании приложения Gradle объединяет несколько файлов манифеста в один манифест.
  #
  #Когда вы создаете новый проект Android Studio создаст пример тестового файла для автоматического тестирования ExampleInstrumentedTest.kt
  #
  #
  #
  #Чтобы создать инструментальный тест подобно локальному Unit-тесту, вы
  #можете создать тест для определенного класса или метода, выполнив следующие действия:
  #1.	Откройте файл, содержащий код, который вы хотите протестировать;
  #2.	Выберете класс или метод, который вы хотите протестировать, затем нажмите Ctrl+Shift+T;
  #3.	В появившемся меню нажмите кнопку "Create New Test"; 4.Появиться диалоговое окно, в котором нужно выбрать необходимые параметры:
  #
  #
  #
  #
  #В итоге на будет создан файл-заготовка для написания инструментальных
  #тестов:
  #import org.junit.After import org.junit.Before import org.junit.Test import org.junit.Assert.*
  #class MainActivityTest { @Before
  #fun setUp() {
  #}
  #@After
  #fun tearDown() {
  #}
  #@Test
  #fun onCreate() {
  #}
  #}
  #
  #Кроме этого нужно убедиться, что в сборщик Gradle были добавлены
  #необходимые зависимости. В AndroidX Test доступны следующие зависимости для Gradle:
  #
  #https://developer.android.com/training/testing/instrumented-tests/androidx-test- libraries/test-setup
  #
  #На сегодняшний день наиболее популярными библиотеками для созданий
  #инструментальных тестов выступают:
  #
  #
  #Espresso
  #
  #
  #
  #
  #
  #
  #UIAutomator
  #
  #
  #
  #Robolectric
  #
  #https://developer.android.com/training/testing/espresso
  #
  #
  #
  #
  #
  #
  #https://developer.android.com/training/testin g/other-components/ui-automator
  #
  #
  #
  #https://robolectric.org/
  #
  #У разработчиков есть четкая шпаргалка, на которую можно использовать при
  #разработке тестовых сценариев. В приведенной ниже шпаргалке содержится большинство методов, которые доступны в Espresso. Эта шпаргалка содержит наиболее доступные экземпляры Matcher, ViewAction и ViewAssertion.
  #
  #В приведенной ниже шпаргалке содержится большинство методов, которые
  #доступны в Espresso: экземпляры Matcher, ViewAction и ViewAssertion.
  #
  #
  #
  #
  #Espresso - это простой, быстрый и настраиваемый фреймворк
  #тестирования Android-приложений, который предназначен для разработки надежных автоматизированных тестов пользовательского интерфейса. На сегодняшний день он является одним из самых популярных тестовых фреймворков для платформы Android.
  #
  #Библиотека Espresso, предоставляемая AndroidX Test, предоставляет API-интерфейсы для написания UI-тестов имитации взаимодействия с пользователем. Тесты Espresso можно запускать на устройствах c Android
  #4.0.1 (уровень API 14) и выше. Ключевым преимуществом использования библиотеки Espresso является то, что она обеспечивает автоматическую синхронизацию тестовых действий с пользовательским интерфейсом приложения.
  #Для создания тестов с помощью фреймворка Espresso в gradle необходимо присутствие следующей зависимости:
  #dependencies {
  #androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0'
  #}
  #
  #Перед тем как перейти к непосредственно к возможностям библиотеки Espresso,
  #давайте подумаем о мобильном приложении с точки зрения конечного пользователя. Что делают пользователи, когда они используют приложение?
  #Сначала они ищут необходимые элементы UI на экране приложения (кнопки, списки, текстовые поля и т.д.), затем выполняют некоторые действия с ними (нажимают кнопки, вводят текст и т.д.), далее проверяют результат работы (привело ли нажатие кнопки или свайп к желаемому результату, введен ли текст и т.д.).
  #
  #Таким образом при инструментальном тестировании возникают следующие задачи:
  #
  #•	поиск элементов пользовательского интерфейса в приложении;
  #•	проверка действий над элементами UI;
  #•	проверка результатов действий над элементами пользовательского интерфейса.
  #
  #Для решения этих задач в Espresso есть три типа методов :
  #1.	ViewMatchers — позволяют найти объект в текущей иерархии представлений
  #2.	ViewActions — эти методы позволяют выполнять различные действия с объектами.
  #3.	ViewAssertions — позволяют проверить состояние объекта и подтвердить, что состояние соответствует критериям
  #
  #Таким образом, общая схема всех тестов с Espresso выглядит так:
  #1.	Найти View, передав в метод onView() объект Matcher.
  #2.	Выполнить какие-то действия над этой View, передав в метод perform объект
  #ViewAction.
  #3.	Проверить состояние View, передав в метод check объект ViewAssertion.
  #
  #Обычно для создания объекта ViewAssertion используют метод matches, который
  #принимает объект Matcher.
  #Espresso – это очень умный фреймворк, который грамотно проверяет все элементы, при этом он может ждать некоторое время, пока выполнится определенное условие, что очень удобно, так как не всегда элементы на экране появляются мгновенно. Для каждого из этих объектов существует большое количество стандартных методов, которые позволяют покрыть подавляющее большинство сценариев проверки:
  #•	withId, withText, withHint, withTagKey, … – Matcher.
  #•	click, doubleClick, scrollTo, swipeLeft, typeText, … – ViewAction.
  #•	matches, doesNotExist, isLeftOf, noMultilineButtons – ViewAssertion.
  #Если вам не хватит стандартных объектов, вы всегда можете создать свои собственные. Далее подробнее рассмотрим ключевые методы библиотеки в Kotlin.
  #
  #В данном разделе показано, как выполнять стандартные задачи автоматического
  #тестирования с помощью Espresso API в Kotlin. Основные компоненты Espresso следующие:
  #Espresso - точка входа для взаимодействия с представлениями (осуществляется с помощью методов onView() и onData()).
  #ViewMatchers - коллекция, реализующих интерфейс Matcher<? super View>. Для поиска представлений в текущей иерархии, можно передать один или несколько объектов коллекции методу onView().
  #ViewActions - коллекция объектов ViewAction, которые можно передать методу ViewInteraction.perform(), например метод click(). Позволяет взаимодействовать с компонентами (click, longClick, doubleClick, swipe, scroll и т.д.).
  #ViewAssertions - объекты ViewAssertion можно передать методу ViewInteraction.check(). Чаще всего используется для подтверждения состояния представления.
  #
  #Приведем пример:
  #// withId(R.id.my_view) объект ViewMatcher
  #// click() объект ViewAction
  #// matches(isDisplayed()) объект ViewAssertion
  #onView(withId(R.id.my_view))
  #.perform(click())
  #.check(matches(isDisplayed()))
  #
  #Найти представление по его id можно следующим образом:
  #onView(withId(R.id.my_view))
  #
  #Кроме того можно найти представление по размещенному в нем тексту. Например найти представление с текстом "Hello" можно следующим образом:
  #onView(allOf(withId(R.id.my_view), withText("Hello!")))
  #
  #После того как необходимое представление найдено в иерархии, можно
  #выполнить для него метод perform класса ViewAction. В нем мы указываем конкретное действие, которое нужно выполнить. Приведем некоторые методы:
  #•	ViewActions.click() - возвращает действие нажатия кнопки;
  #•	ViewActions.typeText() - возвращает действие ввода текста;
  #•	ViewActions.pressKey() - возвращает действие нажатия на клавишу;
  #•	ViewActions.clearText() - возвращает действие, очищающее текст в представлении
  #и т.д.
  #Подробнее с методами класса можно ознакомиться: https://developer.android.com/reference/androidx/test/espresso/matcher/View Matchers
  #
  #Например, для клика по представлению в тесте необходимо написать
  #следующее:
  #onView(...).perform(click())
  #Вы можете выполнить более одного действия за один вызов функции:
  #onView(...).perform(typeText("Hello"), click())
  #Методы класса ViewActions могут применяться к текущему выбранному представлению с помощью метода check(). При этом наиболее часто используемый метод - метод matches(). Например, чтобы проверить, есть ли в представлении текст «Hello!» нужно написать следующее:
  #onView(...).check(matches(withText("Hello!")))
  #
  #Выполнение задач в фоновом режиме
  #
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Список тем дисциплины
  #1.	Многопоточность в Android приложениях. Корутины.
  #2.	Сервисы. Назначение и виды сервисов.
  #3.	Уведомления (notifications) и широковещательные (broadcast) сообщения в Android. Выполнение действий по расписанию. Сенсоры.
  #
  #Тема 1. Многопоточность в Android приложениях.
  #Корутины.
  #
  #Поток можно представить как последовательность команд программы,
  #которая претендует на использование процессора вычислительной системы для своего выполнения. Потоки одной и той же программы работают в общем адресном пространстве и, тем самым, разделяют (совместно используют) данные программы.
  #При запуске в приложении создается создает основной поток выполнения main thread. Он координирует отправку событий в виджеты пользовательского интерфейса, а также отвечает за связь с компонентами
  #Android UI. Важно избегать использование main thread в любых операциях, которые могут привести к его блокировке. Такие операции, как например обращения к базам данных или загрузка определенных компонентов из Интернета, выступают характерными действий, которые не следует выполнять в основном потоке. При запуске таких операций в основном потоке пользовательский интерфейс не будет ни на что реагировать до их завершения. Именно поэтому они обычно выносятся в отдельный поток.
  #
  #В Android существует множество способов создания и управления потоками, а также множество сторонних библиотек, которые делают управление потоками гораздо более удобным и быстрым в разработке. В данном разделе учебника мы познакомимся с некоторыми типичными решениями для многопоточных приложений в Android с использованием языка программирования Kotlin.
  #В Android можно классифицировать потоки на два ключевых типа:
  #•	потоки связанные с активностью или фрагментом (они привязаны к жизненному циклу активности или фрагмента и завершаются сразу после их уничтожения);
  #•	потоки не связанные с активностью или фрагментом (они могут продолжать работу за пределами жизни активности или фрагмента, из которых они были созданы).
  #
  #Поток пользовательского интерфейса (UI-поток) - это основной поток выполнения для приложения. Именно здесь выполняется большая часть кода вашего приложения. Все компоненты вашего приложения (Activity, Service, ContentProvider, BroadcastReceiver) создаются в этом потоке, и все системные вызовы этих компонентов выполняются нем. Кроме этого UI-поток отвечает за обновление элементов разметки приложения.
  #
  #Рабочий поток (Worker-поток) - это поток, в котором можно выполнять обработку, которая не должна прерывать какие-либо изменения, происходящие в UI-потоке. Worker-потоки не владеют пользовательским интерфейсом и не взаимодействует с ним.
  #
  #Для создания новых потоков нам доcтупен стандартный функционал класса Thread из стандартной библиотеки. Обычно первичным потоком будет поток, который владеет и управляет пользовательским интерфейсом. Затем можно запустить один или несколько рабочих потоков, для выполнения определенных задач. Эти потоки не изменяют пользовательский интерфейс напрямую.
  #
  #Если нам нужно изменить компонент пользовательского интерфейса, например изменить текст в текстовом представлении, нам нужно использовать UI-поток.
  #Создание потока в Kotlin аналогично созданию потока в Java. Мы могли бы создать наследник класса Thread следующим образом:
  #
  #
  #class MyThread: Thread() { public override fun run() {
  #println("Running")
  #}
  #}
  #
  #class MyRunnable: Runnable { public override fun run() {
  #println("Running")
  #}
  #}
  #
  #Так же, как в Java, мы можем выполнить запустить его, вызвав метод start():
  #val thread = MyThread() thread.start()
  #val threadWithRunnable = Thread(MyRunnable()) threadWithRunnable.start()
  #
  #В Kotlin есть стандартная библиотечная функция thread:
  #public fun thread( start: Boolean = true,
  #isDaemon: Boolean = false, contextClassLoader: ClassLoader? = null, name: String? = null,
  #priority: Int = -1,
  #block: () -> Unit): Thread
  #Ее можно использовать следующим образом:
  #thread { Thread.sleep(1000) println("test")
  #}
  #
  #В Kotlin есть стандартная библиотечная функция thread:
  #public fun thread( start: Boolean = true,
  #isDaemon: Boolean = false, contextClassLoader: ClassLoader? = null, name: String? = null,
  #priority: Int = -1,
  #block: () -> Unit): Thread
  #Ее можно использовать следующим образом:
  #thread { Thread.sleep(1000) println("test")
  #}
  #
  #Она имеет множество дополнительных параметров:
  #•	start - немедленно запустить поток;
  #•	isDaemon - для создания потока как потока демона;
  #•	contextClassLoader - загрузчик классов, используемый для загрузки классов и ресурсов;
  #•	name - установка имени потока;
  #•	priority - установка приоритета потока.
  #
  #Она имеет множество дополнительных параметров:
  #•	start - немедленно запустить поток;
  #•	isDaemon - для создания потока как потока демона;
  #•	contextClassLoader - загрузчик классов, используемый для загрузки классов и ресурсов;
  #•	name - установка имени потока;
  #•	priority - установка приоритета потока.
  #
  #Если поток запущен и необходимо обновить элемент пользовательского интерфейса, можно воспользоваться функцией runOnUIThread(). Далее приведем пример приложения, где TextView меняется каждую секунду. Сначала на экране необходимо поместить приветственное сообщение. После нажатия кнопки в текстовом представлении будут показывать два сообщения
  #«First message» и «Second message» попеременно каждую секунду:
  #
  #class MainActivity : AppCompatActivity() {
  #override fun onCreate(savedInstanceState: Bundle?)
  #{
  #super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #// элементы разметки
  #val tv = findViewById<TextView>(R.id.tv1)
  #val btn = findViewById<Button>(R.id.btnStart) val msg1 = "First message"
  #val msg2 = "Second message"
  #
  #// слушатель для кнопки btn.setOnClickListener{
  #// объявляем главный поток Thread(Runnable {
  #while (true) {
  #// обновление TextView runOnUiThread{ tv.text = msg1 }
  #// останавливаем поток на одну секунду Thread.sleep(1000)
  #// обновление TextView runOnUiThread{ tv.text = msg2 }
  #// останавливаем поток на одну секунду Thread.sleep(1000)
  #}
  #}).start()
  #}
  #}
  #}
  #
  #Использование асинхронных потоков может привести к ошибочному выполнению. Для разрешения таких проблем используется синхронизация. Механизм синхронизации основывается на концепции монитора.
  #Монитор — это специальный механизм, обеспечивающий управление взаимодействием процессов и их состоянием. Монитор можно представить себе как ключ от комнаты сейфовых ячеек в банке, а потоки можно представить как клиентов в банке. Когда первый клиент получил ключ от комнаты, дверь за ним закрывается, и все остальные желающие работать с сейфами ждут, пока первый клиент не вернет ключ. Это называется «поток захватил монитор». Когда первый клиент вышел, ключ (монитор) может быть передан следующему клиенту. Это называется «поток освободил монитор».
  #
  #В отличие от Java, Kotlin не имеет ключевого слова synchronized. Следовательно, для синхронизации нескольких фоновых потоков используется аннотация @Synchronized или встроенная функция стандартной библиотеки synchronized().
  #
  #// синхронизированная @Synchronized fun myFunction() {
  #}
  #fun myOtherFunction() {
  #// синхронизированный блок synchronized(this) {
  #}
  #}
  #Аннотация @Synchronized и функция synchronized() используют концепцию блокировки монитора. Вы можете рассматривать монитор как особый токен, который поток может получить или заблокировать для получения монопольного доступа к объекту.
  #
  #Корутины (сопрограммы) — это новый способ написания асинхронного, неблокирующего кода. Корутины можно представить как облегчённый поток. Так же как и потоки, корутины могут работать параллельно, взаимодействовать между собой, ожидать друг друга. Ключевым отличием является тот факт, что корутины легковесны. Аналогичный код с созданием и запуском потока потребует много больше памяти. Корутины необходимо использовать в случае, если требуется скачать что-то из сети, извлечь данные из базы данных или просто выполнить долгие вычисления и при этом не заблокировать интерфейс пользователю.
  #
  #Поддержка корутин встроена в Kotlin, но все классы и интерфейсы находятся в отдельной библиотеке. kotlinx.coroutines - это обширная библиотека, разработанная компанией JetBrains, которая содержит в себе множество сопрограмм. Для их использования нужно добавить зависимость в gradle:
  #// x.x.x версия корутин dependencies {
  #implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:x.x.x" implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:x.x.x"
  #}
  #
  #Главным отличительным признаком корутин является то, что они могут быть приостановлены без блокирования потока. Еще одно отличие заключается в том, что они не могут быть приостановлены на произвольной инструкции, а только в так называемых точках остановки (приостановки), которые вызываются в специально маркируемых функциях. Приостановка происходит в случае вызова функции со специальным модификатором suspend:
  #suspend fun doSomething(foo: Foo): Bar {
  #...
  #}
  #https://blog.skillfactory.ru/glossary/coroutine/
  #
  #Такие функции называются функциями остановки (приостановки), поскольку их вызовы могут приостановить выполнение корутин. Функции остановки могут иметь параметры и возвращать значения точно так же, как и все обычные функции, но они могут быть вызваны только из сопрограмм или других функций остановки. Функции остановки не могут быть вызваны из обычной функции, поэтому для них предусмотрено несколько специальных функции запуска сопрограммы, которые позволяют вызывать функцию остановки из обычной области, не требующей приостановки:
  #
  #•	runBlocking: запускает новую сопрограмму и блокирует текущий поток до его завершения,
  #•	launch: запускает новую сопрограмму и возвращает ссылку на нее как на объект класса Job,
  #•	async: запускает новую сопрограмму и возвращает ссылку на нее как объект Deferred <T>. Он должен использоваться вместе с функцией await, которая ожидает результата, не блокируя поток.
  #
  #Сопрограммы используют внутренние фоновые потоки, поэтому по умолчанию они не запускаются в потоке пользовательского интерфейса приложения Android. Следовательно, если вы попытаетесь изменить содержимое пользовательского интерфейса вашего приложения из сопрограммы, вы столкнетесь с ошибкой во время выполнения. К счастью, запустить сопрограмму в потоке пользовательского интерфейса довольно просто: вам просто нужно передать объект UI в качестве аргумента вашему билдеру сопрограмм.
  #
  #Давайте рассмотрим работу сопрограммы на простом примере. Следующий фрагмент кода приводит к тому, что нажатие на кнопку должно изменить текст на экране после определенной задержки, не блокируя поток, в котором он выполняется, во время ожидания.
  #
  #class SimpleCoroutinesActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) {
  #//init stuff
  #fab.setOnClickListener { launch(UI) {
  #setTextAfterDelay(2, "Hello from a coroutine!")
  #}
  #}
  #}
  #private suspend fun setTextAfterDelay(seconds: Long, text: String) { delay(seconds, TimeUnit.SECONDS)
  #textView.text = text
  #}
  #}
  #
  #В OnClickListener мы используем launch и передаем UI типа CoroutineDispatcher в качестве его параметра. Параметр UI обеспечивает выполнение блока кода в основном потоке.
  #Внутри блока launch мы вызываем функцию остановки setTextAfterDelay(), которая определена ниже. Внутри нашей функции остановки вызывается функция delay(), которая задерживает сопрограмму, не блокируя поток. По прошествии определенного времени функция продолжает выполнение и устанавливает текст в TextView.
  #Возвращаемым значением функции launch() является объект Job, который можно использовать для управления сопрограммой. Например, вы можете вызвать его метод join(), чтобы дождаться завершения сопрограммы. Точно так же вы можете вызвать его метод cancel(), чтобы немедленно отменить сопрограмму.
  #
  #Использование функции launch() очень похоже на создание нового потока с объектом Runnable, главным образом потому, что вы не можете вернуть из него никакого значения. Если вы хотите иметь возможность вернуть значение из вашей сопрограммы, вы должны создать его с помощью функции async().
  #Функция async() возвращает объект Deferred, который, как и объект Job, позволяет вам управлять сопрограммой. Однако это также позволяет вам использовать функцию await() для ожидания результата сопрограммы без блокировки текущего потока.
  #
  #Например, рассмотрим следующие сопрограммы, которые используют функцию приостановки fetchWebsiteContents() и возвращают длины содержимого двух разных адресов веб-страниц:
  #val jobForLength1 = async { fetchWebsiteContents("https://myitacademy.ru/partners/").length
  #}
  #val jobForLength2 = async { fetchWebsiteContents("https://myitacademy.ru/news/").length
  #}
  #С помощью приведенного выше кода обе сопрограммы запустятся немедленно и будут работать параллельно.
  #
  #Если вы теперь хотите использовать возвращенные длины, вы должны вызвать метод await() для обоих объектов Deferred. Однако, поскольку метод await() тоже является функцией приостановки, вы должны убедиться, что вызываете его из другой сопрограммы.
  #В следующем коде показано, как вычислить сумму двух длин, используя новую сопрограмму, созданную с помощью функции launch() и отобразить эту сумму в виджете myTextView:
  #launch(UI) {
  #val sum = jobForLength1.await() + jobForLength2.await() myTextView.text = "Downloaded $sum bytes!"
  #}
  #Приведенный выше код на первый взгляд может показаться обыденным, но он не только может ожидать завершения двух фоновых операций без использования обратных вызовов, но и может делать это в потоке пользовательского интерфейса приложения, не блокируя его.
  #
  #Далее приведем пример, где с помощью функции suspend delay(), которая является неблокирующим эквивалентом метода Thread.sleep() организуем движение виджета в цикле. Ниже приведен пример сопрограммы, которая увеличивает координату x виджета TextView каждые 400 мс, создавая эффект, похожий на выделение:
  #launch(UI) { while(myTextView.x < 800) {
  #myTextView.x += 10 delay(400)
  #}
  #}
  #Конечно это далеко не полный перечень применения сопрограмм в программировании Android приложений. Корутины активно задействуются совместно с архитектурными компонентами:
  #https://developer.android.com/topic/libraries/architecture/coroutines
  #
  #Выполнение задач в фоновом режиме
  #
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Список тем дисциплины
  #1.	Многопоточность в Android приложениях. Корутины.
  #2.	Сервисы. Назначение и виды сервисов.
  #3.	Уведомления (notifications) и широковещательные (broadcast) сообщения в Android. Выполнение действий по расписанию. Сенсоры.
  #
  #Тема 2. Сервисы. Назначение и виды сервисов.
  #
  #Сервис в Android — это компонент приложения, который может выполнять
  #длительные операции в фоновом режиме и не содержит пользовательского интерфейса (UI). Сервисы (службы) в Android представляют собой фоновые процессы.
  #Они не имеют интерфейса пользователя (UI) и работают без его вмешательства. Службы являются компонентами приложения, но способны выполнять действия, даже когда приложение невидимо, пассивно или вовсе закрыто. В отличие от активностей, сервисы предназначены для длительного существования и обладают более высоким приоритетом, чем скрытые активности. Тем самым, вероятность закрытия сервиса системой при нехватке ресурсов намного ниже. К тому же, служба может быть настроена таким образом, что будет автоматически запущена, как только найдутся необходимые ресурсы.
  #
  #Мы можем встретить массу приложений, использующих сервисы. Работая в
  #фоновом режиме, сервисы имеют возможность выполнять сетевые запросы, вызывать уведомления, обрабатывать информацию, проигрывать музыку и выполнять множество иных «закулисных» задач.
  #Многие компоненты приложения могут запускать сервисы, обмениваться данными и закрывать их. В роли таких компонентов могут выступать как активности, так и другие сервисы. Стоит подчеркнуть, что сервис может быть закрыт как компонентом приложения, так и самостоятельно инициировать собственное завершение.
  #Обратите внимание, что, несмотря на работу в фоновом режиме, сервисы работают в основном потоке приложения (main UI thread). В случае выполнения «тяжелых» задач их необходимо запускать в отдельном потоке, так как это может привести к «неприятным» задержкам в UI пользователя.
  #
  #https://developer.android.com/guide/components/services
  #
  #Кроме создания собственных сервисов, можно использовать системные
  #сервисы. Приведем некоторые из них:
  #Account Service — сервис для управления пользовательскими учетными записями;
  #Activity Service — сервис для управления активностями;
  #Alarm Service — сервис для отправки разовых или периодических оповещений в заданное время;
  #Bluetooth Service — сервис для Bluetooth;
  #Clipboard Service — сервис для управления буфером обмена; Connectivity Service — сервис для управления сетевыми соединениями; Download Service — сервис для управления загрузками;
  #Input Method Service — сервис для управления текстовым вводом;
  #JobScheduler — сервис для планирования задач;
  #Location Service — сервис для отслеживания координат;
  #
  #Layout Inflater Service — сервис для управления компоновкой экрана при
  #динамическом создании из кода;
  #NFC Service — сервис для управления NFC;
  #Notification Service — сервис для управления уведомлениями; Power Service — сервис для управления энергопотреблением; Search Service — сервис для управления глобальным поиском; Sensor Service — сервис для доступа к датчикам;
  #Telephony Service — сервис для управления телефонными функциями;
  #Vibrator Service — сервис для доступа к виброзвонку;
  #Wallpaper Service — сервис для управления обоями на домашнем экране;
  #Wifi Service — служба для управления соединениями Wi-Fi.
  #
  #Google последовательно борется с ограничениями для служб, урезая их
  #возможности. Делается это для того, чтобы службы не висели в памяти бесконечно долго и тратили заряд батареи. Ограничение возможностей происходит постепенно от версии к версии.
  #В последних версиях уже можно столкнуться с примерами, когда выкидывается исключение при неправильной работе с службами.
  #Для решения проблем следует изучить такие вещи как: https://developer.android.com/reference/android/app/job/JobScheduler
  #https://developer.android.com/guide/background/persistent
  #
  #
  #
  #
  #Все сервисы наследуются от класса Service и проходят следующие этапы жизненного цикла:
  #onCreate() — вызывается при создании сервиса;
  #onStartCommand() — вызывается при получении сервисом команды, отправленной с помощью метода startService();
  #onBind() — вызывается при закреплении клиента за сервисом с помощью метода bindService();
  #onDestroy() — вызывается при завершении работы сервиса.
  #
  #Жизненный цикл сервиса
  #На самом деле, сервис имеет два вложенных цикла во время своей жизни и два различных варианта поведения.
  #
  #
  #
  #Жизненный цикл сервиса
  #Сервисы могут работать в двух режимах:
  #Запущенный (started). Сервис, запущенный с помощью метода startService(). Будучи запущенным, сервис может работать неопределенно долгое время, но чаще служба запускается для выполнение разовой операции, например, загрузки информации по сети. Когда необходимые действия выполнены, сервис должен самостоятельно завершить работу.
  #Привязанный (bound). Сервис, к которому другой компонент приложения привязался с помощью метода bindService(). Привязанный сервис предоставляет клиент-серверный интерфейс, через который с ним можно взаимодействовать: посылать запросы и получать ответы. Привязанный сервис уничтожается, когда от него отвязывается последний привязанный клиент.
  #
  #Жизненный цикл сервиса
  #В реальных приложениях службы могут работать и в «смешанном» режиме: быть запущенными с помощью startService(), чтобы работать неограниченно долго, в то же время разрешая «привязку» (binding) для взаимодействия с клиентами.
  #Можно установить подключение к работающей службе и использовать это подключение для взаимодействия со службой. Подключение устанавливают вызовом метода bindService() и закрывают вызовом unbindService(). Если служба уже была остановлена, вызов метода bindService() может ее запустить.
  #Методы onCreate() и onDestroy() вызываются для всех сервисов независимо от того, запускаются ли они через startService() или bindService().
  #
  #Класс IntentService - это вспомогательный класс (унаследованный от класса Service), который создает рабочий поток для обработки фоновых задач и обрабатывает каждый запрос асинхронным образом. Чтобы сервис можно было использовать, он должен быть сначала объявлен в файле манифеста. Как минимум, элемент должен содержать свойство, объявляющее имя класса службы. По умолчанию службы объявляются общедоступными, поскольку к ним могут обращаться компоненты вне пакета приложения, в котором они находятся.
  #
  #<service android:name="MyService" android:exported="false" android:process=":myprocess">
  #</service>
  #
  #class MyIntentService : IntentService("MyIntentService") {
  #private val TAG = "ServiceExample" override fun onHandleIntent(arg0: Intent?) {
  #Log.i(TAG, "Intent Service started")
  #}
  #}
  #class MainActivity : AppCompatActivity() {
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #val intent = Intent(this, MyIntentService::class.java) startService(intent)
  #}
  #}
  #
  #Мы создали объект Intent с именем класса сервиса для запуска и затем используем его в качестве аргумента метода startService(). После запуска приложения и фильтрации по тэгу "ServiceExample" в Logcat появляется сообщение «Intent Service Started».
  #
  #
  #
  #При использовании Android Studio для создания сервисов можно использовать пункты меню New -> Service -> Service. Это позволит автоматически создать класс наследник Service и задекларировать его в манифесте приложения.
  #
  #Не смотря на то, что использование класса IntentService позволяет реализовать сервис с минимизацией количества кода, бывают случаи, когда необходима гибкость класса Service. Во избежание одновременного введения слишком большого количества правил, связанных с выполнением трудоемких служебных задач в том же потоке, приведем пример создания службы с использованием класса Service в основном потоке приложения.
  #
  #Минимальным требованием для создания работающей службы является реализация в ней метода onStartCommand(), который будет вызываться при запуске службы.
  #Кроме того, метод onBind() должен возвращать null, чтобы указать системе Android, что это не привязанная служба.
  #В примере ниже метод onStartCommand() будет выполнять цикл три раза и каждый раз ждать по 10 секунд, имитируя выполнение трудоемкой операции. Также для нашего сервиса реализуем методы onCreate() и onDestroy(). В них будем выводить соответствующую информацию в лог.
  #
  #class MyService : Service() {
  #private val TAG = "ServiceExample" override fun onCreate() {
  #Log.i(TAG, "Service onCreate")
  #}
  #override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Log.i(TAG, "Service onStartCommand " + startId)
  #var i: Int = 0 while (i <= 3) {
  #try {
  #Thread.sleep(10000) i++
  #} catch (e: Exception) { } Log.i(TAG, "Service running")
  #
  #
  #
  #}
  #...
  #}
  #
  #}
  #return Service.START_STICKY
  #
  #class MainActivity : AppCompatActivity() {
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #}
  #fun buttonClick(view: View) {
  #intent = Intent(this, MyService::class.java) startService(intent)
  #}
  #}
  #
  #Метод buttonClick() создает объект намерения для новой службы, а затем запускает его. Запустите приложение и после загрузки нажмите созданную кнопку. В Logcat появятся сообщения, указывающие, что был вызван метод onCreate() и что в методе onStartCommand() выполняется цикл.
  #
  #
  #
  #
  #
  #Прежде чем появится последнее сообщение цикла, попробуйте второй раз нажать кнопку. Обратите внимание, что UI не отвечает. Это происходит потому, что основной поток приложения занят службой, пока он выполняет цикл.
  #Очевидно, что код службы необходимо изменить, чтобы задачи выполнялись в отдельном потоке.
  #
  #Привязанная служба (Bound service) предоставляет интерфейс типа клиент- сервер. Привязанная служба позволяет компонентам приложения взаимодействовать со службой, отправлять запросы, получать результаты и даже делать то же самое с другими процессами через IPC.
  #Привязанная служба обычно работает, пока другой компонент приложения привязан к ней. Она не работает постоянно в фоновом режиме. Привязанная служба очень похожа на уже запущенную службу за одним исключением: запущенная служба обычно не возвращает результаты и не разрешает взаимодействие с компонентом, из которого она была запущена. При использовании Bound-сервисов возможно взаимодействовать компонентов, запустивших сервис с самим сервисом и получение результатов от него. Это взаимодействие также может происходить между процессами.
  #
  #https://developer.android.com/guide/components/bound-services
  #
  #
  #
  #
  #
  #
  #Например, в активности можно запустить службу для обработки звука, при этом интерфейс активности скорее всего будет содержать элементы управления для приостановки воспроизведения или перехода к следующему треку. Точно так же службе, скорее всего, потребуется передать информацию вызывающей ее активности, чтобы указать, что текущая звуковая дорожка завершена, и предоставить сведения о следующей дорожке, которая вот-вот начнется.
  #
  #Активность или фрагмент (также называемый в этом контексте клиентом) запускается и связывается со службой через метод bindService(). Кроме того, несколько компонентов могут одновременно подключаться к службе. Когда привязка службы больше не требуется клиенту, следует вызвать метод unbindService(). Когда последний связанный клиент отключается от службы, служба будет прекращена системой Android. Важно помнить, что привязанная служба также может быть запущена с помощью вызова startService(). После запуска компоненты приложения могут связываться с ней с помощью метода bindService(). Когда связанная служба запускается с помощью вызова startService(), она будет продолжать свою работу даже после того, как последний клиент "отвяжется" от нее.
  #
  #В привязанной службе должен быть реализован метод onBind(), который вызывается как при первоначальном создании службы, так и при последующей привязке других клиентов к работающей службе. Цель этого метода - вернуть привязанным клиентам объект типа IBinder, содержащий информацию, необходимую клиенту для связи со службой.
  #С точки зрения реализации связи между клиентом и привязанной службой рекомендуемый метод зависит от того, находятся ли клиент и служба в одном или разных процессах и является ли служба приватной для клиента.
  #Локальная связь может быть достигнута путем расширения класса Binder и возврата экземпляра из метода onBind().
  #
  #В привязанной службе должен быть реализован метод onBind(), который вызывается как при первоначальном создании службы, так и при последующей привязке других клиентов к работающей службе. Цель этого метода - вернуть привязанным клиентам объект типа IBinder, содержащий информацию, необходимую клиенту для связи со службой.
  #С точки зрения реализации связи между клиентом и привязанной службой рекомендуемый метод зависит от того, находятся ли клиент и служба в одном или разных процессах и является ли служба приватной для клиента.
  #Локальная связь может быть достигнута путем расширения класса Binder и возврата экземпляра из метода onBind().
  #
  #
  #
  #Связанные службы создаются как подклассы класса Service, в них должен быть реализован метод onBind().
  #Клиентские компоненты связываются со службой посредством вызова метода
  #bindService().
  #Первый запрос привязки к привязанной службе приведет к вызову метода onBind() этой службы (последующие запросы привязки не запускают вызов onBind()).
  #Клиенты, желающие выполнить привязку к службе, также должны реализовать интерфейс ServiceConnection, содержащий методы onServiceConnected() и onServiceDisconnected(), которые будут вызываться, когда соединение клиент- сервер будет установлено или отключено соответственно.
  #В случае метода onServiceConnected() ему будет передан объект IBinder, содержащий информацию, необходимую клиенту для взаимодействия со службой.
  #
  #Существует два рекомендуемых механизма для реализации взаимодействия между клиентскими компонентами и привязанным сервисом.
  #В случае, если привязанная служба является локальной и частной для приложения (она работает в том же процессе и недоступна для компонентов в других приложениях), рекомендуется создать подкласс Binder и расширите его, чтобы обеспечить интерфейс для службы. Затем экземпляр этого объекта Binder возвращается методом onBind() и впоследствии используется клиентским компонентом для прямого доступа к методам и данным, хранящимся в службе.
  #
  #В ситуациях, когда привязанная служба не является локальной для приложения (другими словами, она выполняется в процессе, отличном от клиентского компонента), взаимодействие лучше всего достигается с помощью реализации Messenger / Handler. В оставшейся части будет создан пример с целью демонстрации действий, необходимых для создания, запуска и организации взаимодействия с локальной частной службой.
  #
  #Рассмотрим приложение, которое будет состоять из одной активности и привязанной службы. Назначение службы - получать текущее время от системы и передать эту информацию в активность, где данные будут отображаться пользователю. Добавим в проект класс BoundService - привязанную службу, который будет выглядеть следующим образом:
  #class BoundService : Service() {
  #override fun onBind(intent: Intent): IBinder? {
  #throw UnsupportedOperationException("Not yet implemented")
  #}
  #}
  #
  #Как было отмечено ранее, локальные привязанные службы могут взаимодействовать с клиентами, передавая им объект Binder. Для этого необходимо создать подкласс класса Binder внутри класса службы и его добавить в него методы, которые могут быть вызваны клиентом. В большинстве случаев он просто включает реализацию метода, который возвращает ссылку на связанный экземпляр службы. Далее клиент может затем напрямую обращаться к данным и вызывать методы в привязанной службе.
  #Следовательно, для нам требуется внести некоторые изменения в класс BoundService. В первую очередь необходимо объявить подкласс Binder, который будет содержать единственный метод с именем getService(), возвращающий ссылку на текущий экземпляр объекта сервиса:
  #
  #class BoundService : Service() {
  #private val myBinder = MyLocalBinder() override fun onBind(intent: Intent): IBinder? {
  #throw UnsupportedOperationException("Not yet implemented")
  #}
  #inner class MyLocalBinder : Binder() { fun getService() : BoundService {
  #return this@BoundService
  #}
  #}
  #}
  #Далее изменим метод onBind(), так чтобы он возвращал ссылку на объект myBinder, и новый добавим метод getCurrentTime() для возврата текущего времени:
  #
  #class BoundService : Service() {
  #private val myBinder = MyLocalBinder() override fun onBind(intent: Intent): IBinder? {
  #return myBinder
  #}
  #fun getCurrentTime(): String {
  #val dateformat = SimpleDateFormat("HH:mm:ss MM/dd/yyyy", Locale.US) return dateformat.format(Date())
  #}
  #inner class MyLocalBinder : Binder() { fun getService() : BoundService {
  #return this@BoundService
  #}
  #}
  #}
  #
  #Теперь службу необходимо добавить в файл AndroidManifest.xml:
  #<service
  #android:name=".BoundService" android:enabled="true" android:exported="true" >
  #</service>
  #
  #Для успешного связывания активности со службой и получения объекта IBinder, возвращаемого методом onBind(), требуется создать подкласс ServiceConnection и реализовать в нем методы onServiceConnected() и onServiceDisconnected():
  #
  #class MainActivity : AppCompatActivity() { var myService: BoundService? = null var isBound = false
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #}
  #private val myConnection = object : ServiceConnection {
  #override fun onServiceConnected(className: ComponentName, service: IBinder) {
  #val binder = service as BoundService.MyLocalBinder myService = binder.getService()
  #isBound = true
  #}
  #override fun onServiceDisconnected(name: ComponentName) { isBound = false
  #}
  #}
  #}
  #
  #Метод onServiceConnected() будет вызываться, когда активность успешно привяжется к службе. Метод передается в качестве аргумента объекту IBinder, возвращаемому методом onBind(). Этот аргумент приводится к объекту типа MyLocalBinder, а затем вызывается метод getService() объекта связывания для получения ссылки на экземпляр сервиса. Переменная isBound используется, чтобы указать, что соединение было успешно установлено. Метод onServiceDisconnected() вызывается при завершении соединения и просто устанавливает isBound значение false.
  #
  #После установки соединения нужно изменить код активности для ее привязки к сервису. Для этого необходимо создать намерение и вызвать метод bindService(), который может быть выполнен в методе onCreate():
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #val intent = Intent(this, BoundService::class.java) bindService(intent, myConnection, Context.BIND_AUTO_CREATE)
  #}
  #
  #Далее, отредактируем код в файле MainActivity.kt, в котором реализуем метод showTime(), который просто вызывает метод getCurrentTime() службы (метод доступен изнутри активности через ссылку myService благодаря методу onServiceConnected()) и запишем полученную строку TextView. Полностью код MainActivity.kt будет выглядеть следующим образом:
  #class MainActivity: AppCompatActivity() { var myService: BoundService? = null var isBound = false
  #fun showTime(view: View) {
  #val currentTime = myService?.getCurrentTime() myTextView.text = currentTime
  #}
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #val intent = Intent(this, BoundService::class.java) bindService(intent, myConnection, Context.BIND_AUTO_CREATE)
  #}
  #…
  #
  #private val myConnection = object : ServiceConnection { override fun onServiceConnected(className:
  #ComponentName,
  #service: IBinder) {
  #val binder = service as BoundService.MyLocalBinder myService = binder.getService()
  #isBound = true
  #}
  #override fun onServiceDisconnected(name: ComponentName) {
  #isBound = false
  #}
  #}
  #}
  #
  #Как показано в предыдущем параграфе, взаимодействие между клиентом и
  #локальной службой может быть реализовано путем возврата клиенту объекта IBinder, содержащего ссылку на объект сервиса. Однако в случае удаленных служб данный подход не работает, потому что удаленная служба работает в другом процессе и не может быть доступна напрямую от клиента.
  #В случае удаленных служб необходимо создать конфигурацию Messenger и Handler, которая позволяет передавать сообщения через процессы между клиентом и службой.
  #В частности, служба создает экземпляр класса Handler будет вызываться при получении сообщения от клиента. Задача Handler - создать объект Messenger, который, в свою очередь, создаст объект IBinder, возвращенный клиенту в методе onBind(). IBinder используется клиентом для создания экземпляра объекта класса Messenger и, впоследствии, для отправки сообщений обработчику сервиса. Каждый раз, когда клиент отправляет сообщение, вызывается метод handleMessage(). Рассмотри пример из одной активности и службы, выполняемых в отдельных процессах:
  #
  #class RemoteService: Service() {
  #inner class IncomingHandler : Handler() { override fun handleMessage(msg: Message) {
  #val data = msg.data
  #val dataString = data.getString("MyString") Toast.makeText(applicationContext,
  #dataString, Toast.LENGTH_SHORT).show()
  #}
  #}
  #override fun onBind(intent: Intent): IBinder? {
  #throw UnsupportedOperationException("Not yet implemented")
  #}
  #}
  #
  #class RemoteService: Service() {
  #inner class IncomingHandler : Handler() { override fun handleMessage(msg: Message) {
  #val data = msg.data
  #val dataString = data.getString("MyString") Toast.makeText(applicationContext,
  #dataString, Toast.LENGTH_SHORT).show()
  #}
  #}
  #override fun onBind(intent: Intent): IBinder? {
  #}
  #}
  #Изменим метод onBind() таким образом, чтобы он возвращал объект IBinder, содержащий объект Messenger:
  #private val myMessenger = Messenger(IncomingHandler()) override fun onBind(intent: Intent): IBinder? {
  #return myMessenger.binder
  #}
  #
  #class RemoteService: Service() {
  #inner class IncomingHandler : Handler() { override fun handleMessage(msg: Message) {
  #val data = msg.data
  #val dataString = data.getString("MyString") Toast.makeText(applicationContext,
  #dataString, Toast.LENGTH_SHORT).show()
  #}
  #}
  #override fun onBind(intent: Intent): IBinder? {
  #}
  #}
  #Изменим метод onBind() таким образом, чтобы он возвращал объект IBinder, содержащий объект Messenger:
  #private val myMessenger = Messenger(IncomingHandler()) override fun onBind(intent: Intent): IBinder? {
  #return myMessenger.binder
  #}
  #
  #Для установки взаимодействия между клиентом и удаленной службой, требуется
  #настроить службу для запуска в отдельном процессе от остальной части приложения.
  #Это можно сделать путем добавления свойства android:process в тег <service> в файле манифеста:
  #<service android:name=".RemoteService" android:enabled="true" android:exported="true" android:process=":my_process" >
  #</service>
  #Как и в случае с локальной службой, в клиенте должен быть реализовать экземпляр класса ServiceConnection с методами onServiceConnected() и onServiceDisconnected(). Также, как и в случае с локальными службами, методу onServiceConnected() будет передан объект IBinder, возвращенный методом onBind() удаленной службы, который будет использоваться для отправки сообщений обработчику сервера, код активности будет таким:
  #
  #class MainActivity : AppCompatActivity() {
  #var myService: Messenger? = null var isBound: Boolean = false
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #}
  #private val myConnection = object : ServiceConnection { override fun onServiceConnected(
  #className: ComponentName, service: IBinder) {
  #myService = Messenger(service) isBound = true
  #}
  #override fun onServiceDisconnected( className: ComponentName) {
  #myService = null isBound = false
  #}
  #}
  #}
  #
  #Затем необходимо добавить код для привязки к удаленной службе. Перепишем метод onCreate() следующим образом:
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)
  #val intent = Intent(getApplicationContext(), RemoteService::class.java) bindService(intent, myConnection, Context.BIND_AUTO_CREATE)
  #}
  #Метод sendMessage() в классе MainActivity, который вызывается, когда пользователь нажимает на кнопку. Этот метод проверяет, подключен ли сервис, создает, содержащий строку сообщения, добавляет его в объект сообщения и отправляет его на сервер:
  #
  #fun sendMessage(view: View) {
  #if (!isBound) return
  #val msg = Message.obtain()
  #val bundle = Bundle() bundle.putString("MyString", "Message Received")
  #msg.data = bundle try {
  #myService?.send(msg)
  #} catch (e: RemoteException) { e.printStackTrace()
  #}
  #}
  #
  #Сервис местоположения
  #Для определения места положения в Android существует специальный класс Location. Местоположение может состоять из широты, долготы, отметки времени и другой информации, такой как азимут, высота и скорость. Получить местоположение можно с помощью класса LocationManager.
  #В файл AndroidManifest.xml необходимо добавить:
  #<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
  #для определения местоположения по GPS или
  #<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
  #<uses-permission android:name="android.permission.INTERNET" />
  #для определения местоположения через Интернет.
  #
  #LocationManager - это класс, через который приложение может получать доступ к службам определения местоположения на Android. Как и в случае с другими системными службами, ссылку на него можно получить, вызвав метод getSystemService(). Если ваше необходимо получать обновления местоположения в рамках Activity, следует выполнить этот шаг в методе onCreate().
  #locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager Далее в приложении следует проверить доступ к соответствующим сервисам.
  #Сделать это можно следующим образом:
  #if ((ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED)) {
  #ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), locationPermissionCode)
  #}
  #
  #Для определения расположения пользователя используется несколько
  #технологий. Android использует три поставщика сведений о расположении.
  #•	Поставщик данных GPS – технология GPS обеспечивает наиболее точные сведения о расположении, потребляет больше всего электроэнергии и лучше всего подходит для туризма. Этот поставщик использует сочетание технологии GPS и технологии aGPS, которая возвращает данные GPS, собранные вышками сотовой связи.
  #•	Поставщик данных сети – предоставляет сочетание данных Wi-Fi и сотовой связи, включая данные aGPS, собранные вышками сотовой связи. Он использует меньше электроэнергии, чем поставщик данных GPS, но возвращает данные о расположении переменной точности.
  #•	Пассивный поставщик – дополнительный вариант, при котором другие приложения или службы запрашивают у поставщика создание данных расположения в приложении. Это менее надежный, но более энергосберегающий вариант, который идеально подходит для приложений, для работы которых не требуется постоянное обновление данных расположения.
  #
  #Когда приложение получит ссылку на LocationManager, ему нужно указать требуемый тип сведений о расположении и частоту обновления данных:
  #locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 5000, 5f, this)
  #
  #После того как приложение запросило данные об изменении
  #из LocationManager, оно может получить сведения от службы, реализовав интерфейс LocationListener, в котором четыре метода:
  #•	onLocationChanged(location: Location) - вызывается при изменении местоположения;
  #•	onProviderDisabled(provider: String) - вызывается, когда поставщик отключен пользователем;
  #•	onProviderEnabled(provider: String) - вызывается, когда поставщик активирован пользователем;
  #•	onStatusChanged(provider: String!, status: Int, extras: Bundle!) - вызывается при изменении статуса провайдера.
  #
  #Геокодирование - это процесс перевода описания местоположения в GPSкоординаты (широта, долгота, высота над уровнем моря) и обратный процесс. В Android для геокодирования есть специальный класс Geocoder:
  #•	Geocoder(context: Context!, locale: Locale!) - геокодер, с локализацией для данной местности;
  #•	Geocoder(context: Context!) - геокодер, с локализацией по умолчанию;
  #•	getFromLocation() - метод возвращает массив адресов, которые, как известно, описывают область, непосредственно окружающую заданные широту и долготу. Результаты являются приблизительными и не гарантируют значимости или правильности. Параметрами метода являются: latitude - широта, longitude - долгота, maxResults - максимальное количество адресов;
  #•	getFromLocationName() - метод возвращает массив адресов, которые описывают местоположение. Параметрами метода являются: locationName - предоставленное пользователем описание местоположения (например, название места, например "Dalvik, Iceland", адрес "1600 Amphitheatre Parkway, Mountain View, CA", код аэропорта, например "SFO"), maxResults - максимальное количество адресов.
  #
  #В приложении функция получения адреса местоположения по координатам широты и долготы может выглядеть следующим образом:
  #private fun getAddress(lat: Double, lng: Double): String { val geocoder = Geocoder(this, Locale.getDefault()) val list = geocoder.getFromLocation(lat, lng, 1) return list[0].getAddressLine(0)
  #}
  #
  #Для определения местоположения вы можете использовать как стандартный requestLocationUpdate, так и Fused Location Provider, который является частью Google play services API. Плюсами решения на основе Fused Location Provider является то, что вам не надо самому подыскивать наиболее точный источник координат, он сделает это за вас. Если запускать его с критериями для определения наиболее точного местоположения, то он будет работать по следующему принципу:
  #
  #•	Если GPS доступен и включен, то выбирается GPS_PROVIDER в качестве источника.
  #•	Если GPS недоступен то выбирается NETWORK_PROVIDER. В данном случаи координаты определяются при помощи вышек сотовой связи и WI-FI.
  #•	Если не того не другого нет то используется PASSIVE_PROVIDER. Система пытается использовать любой способ получить хоть какое-то местоположение в том числе и при использовании акселерометра. Этот провайдер наименее точный.
  #
  #Fused Location Provider включает в себя все три и переключается между ними в зависимости от ситуации для получения наиболее точного место положения, так же при его использовании заряд батареи жрется медленнее. Его главными минусами является то, что для его работы необходим Google play services и то, что вы не сможете отследить какой именно тип провайдера используется в данный момент.
  #
  #https://developer.android.com/training/location/request-updates
  #https://developers.google.com/android/reference/com/google/android/gms/lo cation/FusedLocationProviderClient.html
  #
  #Fused Location Provider включает в себя все три и переключается между ними в зависимости от ситуации для получения наиболее точного место положения, так же при его использовании заряд батареи жрется медленнее. Его главными минусами является то, что для его работы необходим Google play services и то, что вы не сможете отследить какой именно тип провайдера используется в данный момент.
  #
  #Что касается стандартного LocationManager, то вам придется самому определять какой провайдер использовать и переключаться между ними в ручную. Плюсом является то, что вы полностью контролируете весь процесс.
  #
  #Рассмотрим приложение, в котором отобразим текущее местоположение и выведем его адрес.
  #
  #
  #Выполнение задач в фоновом режиме
  #
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Тема 3. Уведомления (notifications) и широковещательные (broadcast) сообщения в Android. Выполнение действий по расписанию. Сенсоры.
  #
  #Назначение уведомлений
  #Кроме Toast-сообщений, в Android существует также другой тип уведомлений, который выводится в строке состояния в виде значка с кратким пояснением.
  #Если открыть окно уведомлений, можно увидеть более подробную информацию об уведомлении. Когда пользователь открывает расширенное сообщение, Android запускается объект Intent, который определяется в соответствии с уведомлением. Можно также создавать уведомление с использованием звука, вибрации и т.д. Такой вид уведомлений используется в том случае, когда приложение работает в фоновом режиме и должно оповестить пользователя о каком-либо событии. Уведомление будет отображаться в строке состояния до тех пор, пока пользователь не отреагирует на него.
  #
  #
  #Основные части уведомлений
  #Стиль и структура Android-уведомлений определяются системой и могут
  #различаться в зависимости от версии ОС и производителя. Поэтому можно определять только содержание уведомлений, а не их внешний вид и дизайн. Ниже приведены основные части уведомления:
  #•	маленький значок: обязателен и устанавливается с помощью метода
  #setSmallIcon();
  #•	большой значок: необязателен и устанавливается с помощью метода
  #setLargeIcon();
  #•	заголовок: необязателен и устанавливается с помощью метода
  #setContentTitle();
  #•	текст уведомления: необязательный и устанавливается с помощью метода
  #setContentText();
  #•	имя приложения: предоставляется системой;
  #•	Отметка времени: предоставляется системой, но может быть отменена с помощью метода setWhen().
  #
  #Класс NotificationCompat
  #Для создания уведомлений в Android существует класс NotificationCompat - помощник для доступа к функциям в уведомлений. API-интерфейсы класса NotificationCompat из библиотеки поддержки Android позволяют добавлять функции, доступные для версий Android 4.0 и выше.
  #
  #Для создания уведомлений используется билдер класса NotificationCompat, в котором указываем иконку, заголовок и текст для уведомления. Уведомления могут отображаться в разных областях экрана и в разных форматах, например, в виде значка в строке состояния или более подробной записи в панели уведомлений.
  #
  #Уведомление в строке состояния
  #Это основной тип уведомления. Сначала оно отображается в виде значка, и
  #его можно просмотреть более подробно с помощью панели уведомлений. Далее приведен код создания уведомления, в котором мы определяем небольшую иконку, заголовок и текст содержимого.
  #val CHANNEL_ID = "CHANNEL_ID"
  #val builder = NotificationCompat.Builder(this, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My title")
  #.setContentText("My content for this notification")
  #.setPriority(NotificationCompat.PRIORITY_DEFAULT)
  #Обратите внимание, что нам нужно передать строку CHANNEL_ID конструктору NotificationCompat, чтобы убедиться, что наше уведомление совместимо с Android 8.0 или выше.
  #
  #Всплывающее уведомление
  #Всплывающие уведомления на короткое время появляются в верхней части
  #экрана в плавающем окне. Они появляются в тот момент, когда приложение отправляет запрос, и могут отображаются только если устройство разблокировано. В программном коде они не сильно отличаются от обычных уведомлений. Необходимо установить Priority значение PRIORITY_HIGH и запросить разрешение на вибрацию. В примере ниже функция отключается, поэтому не нужно запрашивать разрешение на вибрацию.
  #val builder = NotificationCompat.Builder(this, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My title")
  #.setContentText("My content for this notification")
  #.setPriority(NotificationCompat.PRIORITY_HIGH)
  #if (Build.VERSION.SDK_INT >= 21) builder.setVibrate(LongArray(0))
  #
  #Уведомление на экране блокировки
  #Для отображения уведомлений на экране блокировки устройства, можно
  #использовать параметр Visibility. Он может принимать одно из следующих значений:
  #•	VISIBILITY_PUBLIC показывает полное содержание уведомления
  #•	VISIBILITY_PRIVATE показывает значок и заголовок.
  #•	VISIBILITY_SECRET не показывает уведомление на экране блокировки.
  #Ниже приведен пример уведомления, которое отображается на экране блокировки.
  #val builder = NotificationCompat.Builder(this, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My lock screen Notification")
  #.setContentText("My content for this notification")
  #.setPriority(NotificationCompat.PRIORITY_DEFAULT)
  #.setVisibility(VISIBILITY_PUBLIC)
  #
  #Уведомление на экране блокировки
  #Мы также можем создать уведомление, в котором скрыты определенные
  #детали. В примере ниже показано уведомление, которое скрывает содержимое обычного уведомления на экране блокировки.
  #val publicBuilder = NotificationCompat.Builder(this, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My alternative notification")
  #.setPriority(NotificationCompat.PRIORITY_DEFAULT)
  #val builder = NotificationCompat.Builder(this, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My lock screen notification")
  #.setContentText("My content for this notification")
  #.setPriority(NotificationCompat.PRIORITY_DEFAULT)
  #.setVisibility(VISIBILITY_PRIVATE)
  #.setPublicVersion(publicBuilder.build())
  #
  #Уведомление на иконках приложений
  #Зачастую, когда у вас появляются уведомления вы можете увидите
  #соответствующий значок на иконке приложения. Такие уведомления доступны на Android 8.0 и выше. К ним можно получить доступ, путем долгого нажатия на значок приложения.
  #Данный тип уведомлений включен с систему по умолчанию, и нет необходимости ничего настраивать для их использования. Вот пример, в котором мы настраиваем уведомление так, чтобы он отображал маленький значок вместо большого.
  #val builder = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
  #.setContentTitle("Badged Notification")
  #.setContentText("New badged notification")
  #.setSmallIcon(R.drawable.notification_icon)
  #.setBadgeIconType(NotificationCompat.BADGE_ICON_SMALL)  Также существует возможность отключения уведомлений на иконках приложений с помощью метода showBadges канале уведомлений.
  #val channel = NotificationChannel(CHANNEL_ID, name, importance).apply { description = descriptionText
  #setShowBadge(false)
  #
  #Добавление действий: onClick
  #Во-первых, давайте посмотрим, каким образом мы можем совершить какое-
  #либо действие по нажатию пользователя на содержание нашего уведомления. Для нам необходимо создать действие объект типа pendingIntent, чтобы открыть MainActivity как показано ниже:
  #val intent = Intent(this, MainActivity::class.java)
  #val pendingIntent: PendingIntent = PendingIntent.getActivity(this, 0, intent, 0)
  #После этого нам нужно передать pendingIntent в метод setContentIntent() при создании уведомления.
  #val builder = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
  #.setContentIntent(pendingIntent)
  #Можно настроить автоматическое удаление уведомления, когда пользователь нажимает на них с помощью метода setAutoCancel().
  #val builder = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
  #.setAutoCancel(true)
  #
  #Кнопки действий в уведомлении
  #В Android можно настроить до трех кнопок действий для уведомления. Это
  #позволяет пользователю быстро реагировать на события. Для добавления кнопок к уведомлению, необходимо передать объект PendingIntent методу addAction() при создании. Метод addAction() принимает три аргумента: иконка для действия, имя кнопки и объект типа pendingIntent для действия.
  #val intent = Intent(this, MainActivity::class.java).apply { flags = Intent.FLAG_ACTIVITY_NEW_TASK or
  #Intent.FLAG_ACTIVITY_CLEAR_TASK
  #}
  #val pendingIntent: PendingIntent = PendingIntent.getActivity(this, 0, intent, 0) val builder = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
  #.addAction(R.drawable.my_icon, "Open Activity", pendingIntent)
  #.setAutoCancel(true)
  #
  #Расширяемое уведомление
  #Можно расширить уведомление для отображения большего количества
  #информации, например больших изображений или блоков текста. Для этого необходимо вызвать метод setStyle() в Notification.Builder. В примере ниже для Style устанавливается значение NotificationCompat.BigPictureStyle (большое изображение).
  #val bitmap = BitmapFactory.decodeResource(resources, R.drawable.my_icon) val builder = NotificationCompat.Builder(this, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My expandable notification")
  #.setContentText("My notification that can be expended")
  #.setLargeIcon(bitmap)
  #.setStyle(NotificationCompat.BigPictureStyle()
  #.bigPicture(bitmap)
  #.bigLargeIcon(null))
  #Также можно отображать большие блоки текста, установив стиль
  #NotificationCompat.BigTextStyle.
  #
  #Индикатор выполнения (Progress bar)
  #Еще одно распространенное действие - отображать индикаторы выполнения
  #в ваших уведомлениях и обновлять их. Для этого можно воспользоваться методом setProgress(). Далее приведем пример уведомления с индикатором выполнения.
  #val builder = NotificationCompat.Builder(this, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My progress bar notification")
  #.setContentText("My notification with a progress bar ")
  #// константы для индикатора прогресса val PROGRESS_MAX = 100
  #val PROGRESS_CURRENT = 0
  #
  #Индикатор выполнения (Progress bar)
  #NotificationManagerCompat.from(this).apply {
  #// Устанавливает начальный прогресс на 0 builder.setProgress(PROGRESS_MAX, PROGRESS_CURRENT, false) notify(7 , builder.build())
  #for(i in 0 until 100){ builder.setProgress(PROGRESS_MAX, i, false) HandlerThread.sleep(100)
  #}
  #// Обновляет уведомление, когда прогресс завершен builder.setContentText("Download complete")
  #.setProgress(0, 0, false) notify(7, builder.build())
  #}
  #
  #
  #Вывод уведомлений на экран
  #Для вывода уведомлений на экран нужно вызвать метод notify() и передать
  #идентификатор и сборщик уведомлений:
  #with(NotificationManagerCompat.from(this)) { notify(id, builder.build())
  #}
  #Также можно группировать уведомления, которые могут отправляться приложениями за короткий промежуток времени (например социальными сетями). В примере ниже создается идентификатор группы, в которую добавляется уведомление.
  #val GROUP_KEY = "ru.samsung.itacademy.notificationexample.KEY"
  #val group = NotificationCompat.Builder(this@MainActivity, CHANNEL_ID)
  #.setSmallIcon(R.drawable.my_icon)
  #.setContentTitle("My group notification")
  #.setContentText("My notification group")
  #.setGroup(GROUP_KEY)
  #
  #Каналы уведомлений
  #Еще одна очень важная часть уведомлений - это канал уведомлений, который
  #требуется для всех уведомлений для версий Android Oreo (8.0) и выше. Канал определяет визуальное и слуховое поведение уведомлений, находящихся в нем. После создания каналов пользователь получает может включать и отключать различные каналы уведомлений вашего приложения, а также управлять настройками уведомлений. Для каждого типа уведомлений необходимо создать собственный канал например как показано ниже.
  #private val CHANNEL_ID = "CHANNEL_ID"
  #if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
  #// имя канала
  #val name = "Channel"
  #val descriptionText = "My channel example"
  #val importance = NotificationManager.IMPORTANCE_DEFAULT
  #val channel = NotificationChannel(CHANNEL_ID, name, importance).apply { description = descriptionText
  #}
  #
  #Каналы уведомлений
  #// регистрация канала в системе
  #val notificationManager: NotificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
  #notificationManager.createNotificationChannel(channel)
  #}
  #В этом примере мы создаем простой канал уведомлений и регистрируем его в системе с помощью метода createNotificationChannel().
  #В случае если канал уведомлений больше не используется, необходимо его удалить с помощью метода deleteNotificationChannel() класса NotificationManager:
  #private val CHANNEL_ID = "CHANNEL_ID" val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager notificationManager.deleteNotificationChannel(CHANNEL_ID)
  #
  #Примеры
  #
  #
  #Пример приложения, в котором создадим уведомление, создадим для него канал и установим действие по нажатию.
  #
  #Пример реализации сервиса по отправке уведомлений.
  #
  #
  #
  #
  #Безопасность ОС Android обеспечивается, в том числе, запуском отдельной виртуальной машины для каждого приложения. Таким образом, другим приложениям недоступны данные, принадлежащие текущему процессу. Так же приложение не может использовать системные возможности в связи со своей локализацией в отдельном информационном потоке. Однако, достаточно часто возникают ситуации, когда приложению необходимы сведения о состоянии или настройках системы, по этому Android публикует сообщения о происходящих системных событиях в своём пространстве. Для чтения этих сообщений у приложения должна быть настроена подписка на подобные рассылки. Понятно, что читать все сообщения подряд приложению нет необходимости, по этому подписка оформляется отдельно на каждое событие.
  #
  #Также часты случаи, когда у приложения возникает необходимость оповестить другие приложения (или систему) о своей деятельности: желании использовать данные из других приложений; запуску «тяжеловесного» процесса, для выполнения которого необходимо много энергетических ресурсов устройства; готовности «поделиться» с другими приложениями полученной информацией и т.п. То есть возникает необходимость «общения» приложения с другими процессами в системе. Такой функционал реализуется посредством объектов-трансляций, называемых широковещательными сообщениями (Broadcast).
  #
  #Для регистрации сообщений используется широковещательный приёмник (BroadcastReceiver), для отправки - метод sendBroadcast(), вызываемый в контексте приложения. Само широковещательное сообщение представляется в виде намерения, по этому сообщения могут быть явными (с указанием, кому предназначена трансляция) и неявными (адресованы всем подписчикам).
  #
  #Обмен трансляциями предназначен для информирования приложений о состояниях системы или других приложений. С завершением трансляции так же завершаются все процессы, запущенные в рамках текущей трансляции. По этому не стоит применять Broadcast для запуска выполнения каких-либо действий или запускать в трансляциях фоновые потоки.
  #Применение широковещательных возможностей для отслеживания состояния системы более рационально по сравнению с использованием сервисов, поскольку сервис постоянно проявляет активность для контроля состояния, а приёмник находится в ожидании и активизируется только при получении сообщения.
  #Набор системных трансляций, доступных к прослушиванию в текущем приложении, зависит от используемой операционной системы, а полный список всех сообщений размещён в файле BROADCAST_ACTIONS.TXT в пакете Android SDK/platforms в папке data для каждой платформы.
  #
  #Широковещательные сообщения (Broadcast). Приемники трансляций.
  #Работа приёмника трансляций описывается в отдельном классе (можно во вложенном в класс приложения), наследованном от абстрактного класса BroadcastReceiver. Деятельность приёмника программируется в единственном имплементируемом методе onReceive(Context?, Intent?).
  #class MyRec: BroadcastReceiver() {
  #override fun onReceive(p0: Context?, p1: Intent?) { TODO("Not yet implemented")
  #}
  #}
  #Выполнение BroadcastReceiver является процессом переднего плана, то есть выполняется в главном потоке. По этой причине тело метода onReceive() не должно содержать «тяжёлых» или «длинных» действий.
  #
  #Широковещательные сообщения (Broadcast). Способы регистрации приемника.
  #Существует два способа регистрации приёмника: статический и
  #динамический.
  #Статическая регистрация предусматривает объявление приёмника в файле манифеста как составляющую приложения. В этом случае receiver будет работать даже при неактивном приложении. Но следует помнить, что в этом случае повышается расход батареи устройства. По этой причине, начиная с Android 7.0 разработчики системы ужесточают ограничения на приёмники, зарегистрированные таким образом. То есть объявленный в манифесте BroadcastReceiver на «старой» версии Android будет корректно работать, а на устройствах c операционной системой Android 7.0 и выше будет проигнорирован системой. Список ограничений пополняется с выходом каждой новой версии. Все изменения по мере появления публикуются разработчиками в статье.
  #
  #Широковещательные сообщения (Broadcast). Способы регистрации приемника.
  #Для регистрации приёмника как составляющей приложения в файле
  #манифеста в объекте <application> нужно добавить вложенный объект
  #<receiver>, в качестве имени указать класс с описанием приёмника и вложить в него фильтры намерений:
  #<receiver android:name=".MainActivity$MyRec">
  #<intent-filter>
  #<!-- перечисление подписок приёмника-->
  #</intent-filter>
  #</receiver>
  #
  #Широковещательные сообщения (Broadcast). Способы регистрации приемника.
  #Динамическая регистрация приёмника осуществляется непосредственно в коде приложения. Работа делится на три этапа:
  #1.	Cоздание объекта приёмника
  #val receiver = MyRec()
  #2.	Указание фильтров намерений
  #val filter = IntentFilter().apply {
  #// подключение подписок приёмника
  #}
  #3.	Регистрация приёмника с настроенными намерениями
  #registerReceiver(receiver, filter)
  #
  #Широковещательные сообщения (Broadcast). Способы регистрации приемника.
  #С версии Android 8.0 все неявные широковещательные сообщения в системе регистрируются только динамически. Статическая регистрация разрешена только для явных и локальных трансляций. Список исключений, для которых разрешена регистрация в манифесте, публикуется разработчиками
  #в документации: https://developer.android.com/guide/components/broadcast-exceptions
  #
  #Широковещательные сообщения (Broadcast). Способы регистрации приемника.
  #В отличие от статической регистрации, динамически зарегистрированные приёмники получают сообщения, на которые подписаны, пока работает контекст их регистрации. То есть приёмник, зарегистрированный в контексте приложения, будет читать сообщения только пока приложение работает.
  #Для оптимизации расхода заряда батареи устройства необходимо отключать приёмник, если приложение не нуждается в его использовании:
  #unregisterReceiver(receiver)
  #Управление жизнедеятельностью приёмника производится в рамках рабочего контекста.
  #onCreate()	onDestoy()
  #onStart()	onStop()
  #onResume()	onPause()
  #
  #Наряду с регистрацией трансляций мобильные приложения могут посылать сообщения в информационное пространство системы, где подписанные на эти посылки приложения их читают. Отсылка может быть широковещательной в полном смысле, то есть адресованной всем, кто подписан; иметь ограничения на получателей; а может осуществляться внутри приложения. В любом случае сообщение запаковывается в намерение, и уже это намерение транслируется подписчикам. В конструктор при создании намерения передаётся имя трансляции. Именем может быть любая уникальная строковая константа, идентифицирующая передаваемую трансляцию.
  #
  #Часто имя трансляции начинают с имени пакета приложения, делающего рассылку
  #val intent = Intent("ru.myitacademy.samsung.postmaster.Letter")
  #
  #При необходимости в намерение добавляются передаваемые данные
  #intent.putExtra("text","Здравствуйте, дорогие читатели!")
  #Операционная система Android для каждого случая имеет свои механизмы адресации трансляций в зависимости от её типа:
  #
  #•	Неявная трансляция. Отправляется в общее пространство сообщений системы. Доступна системным процессам и приложениям, имеющим приёмник, зарегистрированный на её получение. Подписку может оформить любой процесс, которому известно имя трансляции.
  #•	Упорядоченная трансляция. Отправляется конкретному приёмнику, имеющему соответственные разрешения. Если подписчиков на трансляцию более одного, то отправка происходит по очереди в порядке приоритетности. Во время упорядоченной отправки сообщений приёмники могут изменять передаваемые данные, а так же могут в любой момент прервать трансляцию.
  #
  #•	Локальная трансляция. Используется в случае, когда отправитель и приёмник находятся в одном приложении. Сохраняет конфиденциальность пересылаемой информации в контексте одного приложения и не выходит за рамки своего процесса, тем самым оптимизируя расход ресурсов устройства.
  #
  #Неявная трансляция используется для отправки сообщения в систему и доступна всем, кто подписан на данную рассылку. В этом случае управление трансляцией полностью принадлежит запускающему приложению.
  #Приёмники широковещательной трансляции могут только регистрировать сообщения и не имеют возможности остановить трансляцию или отправить ответную реакцию за пределы своего контекста. Механизмом отправки неявных широковещательных трансляций выступает метод активности sendBroadcast(), получающий в качестве обязательного аргумента некоторое неявное намерение.
  #sendBroadcast(intent)
  #
  #
  #Можно объявлять намерение непосредственно в вызове метода:
  #sendBroadcast(Intent().also { intent ->
  #intent.action = "ru.myitacademy.samsung.postmaster.Letter" intent.putExtra("text","Здравствуйте, дорогие читатели!")
  #})
  #В качестве необязательного аргумента метода может быть передан список разрешений, которыми должен обладать приёмник для получения данной трансляции.
  #
  #
  #sendBroadcast(intent,android.Manifest.permission.WRITE_VOICEMAIL)
  #В таком случае рассылку смогут получать только приёмники, зарегистрированные в приложении с заданными разрешениями в манифесте. Подробнее о запуске трансляций по разрешениям можно ознакомиться в документации.
  #Метод sendBroadcast() является асинхронным фоновым процессом и срабатывает при запуске подписанных на его трансляцию приёмников.
  #
  #
  #При упорядоченной трансляции сообщение передаётся всем подписчикам по очереди в порядке приоритета.
  #Приоритет приёмника устанавливается в свойстве priority фильтра намерения (android:priority при статической регистрации) и представляется целым числом из отрезка [-1000; 1000]. Значением по умолчанию является 0.
  #val intentFilter = IntentFilter("ru.myitacademy.samsung.postmaster.Letter") intentFilter.priority = -100
  #Первыми получают трансляцию приёмники с наибольшим значением поля priority. Если у нескольких получателей одинаковый уровень приоритета, то порядок передачи сообщения между ними определяется случайным образом.
  #
  #Все подписчики имеют доступ к изменению данных, передаваемых в сообщении и их дальнейшей передаче, а так же имеют возможность прерывания трансляции. Это значит, что приёмники с приоритетом ниже, чем у остановившего трансляцию, сообщение не получат.
  #Если при трансляции не планируется возврата данных обратно в широковещательный канал, для запуска вещания используют метод sendOrderedBroadcast(Intrnt, String?) с двумя аргументами:
  #•	первый аргумент - обязательно непустое намерение, содержащее саму трансляцию;
  #•	второй аргумент - разрешения, требующиеся от приёмников для чтения сообщения. Если имеет значение null, то читать трансляцию могут все подписчики в порядке приоритета.
  #
  #Широковещательные сообщения (Broadcast). Изменение данных в трансляции.
  #Упорядоченная трансляция позволяет приёмникам управлять жизненным циклом трансляции и изменять передаваемые в ней данные. Если один из получателей остановит трансляцию, то приёмники с более низким приоритетом её уже не получат и данные будут возвращены отправителю. Если цепочка трансляций не будет оборвана, то все приёмники получат возможность не только прочитать сообщение, но и изменить передаваемые в трансляции данные, в любом случае, результат будет возвращён в посылающее приложение.
  #
  #Широковещательные сообщения (Broadcast). Изменение данных в трансляции.
  #Упорядоченная трансляция позволяет приёмникам управлять жизненным циклом трансляции и изменять передаваемые в ней данные. Если один из получателей остановит трансляцию, то приёмники с более низким приоритетом её уже не получат и данные будут возвращены отправителю. Если цепочка трансляций не будет оборвана, то все приёмники получат возможность не только прочитать сообщение, но и изменить передаваемые в трансляции данные, в любом случае, результат будет возвращён в посылающее приложение.
  #
  #Широковещательные сообщения (Broadcast). Изменение данных в трансляции.
  #•	resultCode. Код результата. Передаётся приёмнику из предыдущего участника и передаётся дальше в методе setResult().
  #•	resultData. Передаваемые по трансляции данные. Передаются в виде непустой текстовой строки, могут быть преобразованы в процессе трансляции. Передаётся в следующий приёмник методом setResult().
  #•	ResultExtras. Данные трансляции, извлекаемые методом getResultExstras(Boolean). Логический параметр указывает, нужно ли добавлять данные в коллекцию передаваемых данных. Если false, то данные не будут передаваться в следующий приёмник. Передача производится в методе setResult(). Данные из ResultExtras получаются через геттеры в зависимости от типа размещаемых данных:
  #
  #Широковещательные сообщения (Broadcast). Изменение данных в трансляции.
  #// у отправителя val extras = Bundle()
  #extras.putInt("putInt",45) extras.putString("putStr","myStr")
  #// у получателя
  #var res = getResultExtras(true) var i = res.getInt("putInt",-5) var str = res.getString("putStr")
  #
  #Широковещательные сообщения (Broadcast). Изменение данных в трансляции.
  #После получения параметров результата из предыдущего узла трансляции, приёмник в рамках работы метода onReseive() может внести изменения в эти данные и передать их дальше.
  #Все три свойства результата передаются по трансляции методом setResult(Int, String, Bundle)
  #Остановить трансляцию может любой приёмник, участвующий в передаче, вызовом метода abortBroadcast().
  #Трансляция с возвращаемыми данными посылается перегрузкой метода sendOrderedBroadcast(Intent, String?, BroadcastReceiver?, Handler?, int, String?, Bundle?)
  #
  #Любой процесс, даже работающий в фоновом режиме, неминуемо будет расходовать заряд батареи устройства: таймеры, напоминания, сигнальные службы - сервисы, работающие вне жизненного цикла приложения, при завершении работы самого приложения остаются в запущенном состоянии. Учитывая портативность смартфона, при отсутствии бесперебойного источника питания остро стоит вопрос экономии заряда батареи. Именно по этому по истечении определённого времени "простоя" устройства оно сначала "гасит" экран, а затем засыпает. При этом активные процессы тоже переходят в режим сна и перестают выполняться. В ракурсе экономии энергии устройства, режим сна весьма полезен. Однако, при "засыпании" устройства так же останавливаются и фоновые процессы, как правило, выполняющие тяжеловесные задачи (например, загрузку и установку обновлений, подготовку данных к отправке и отправка данных по HTTP, обращение к базе данных и т.п.) Остановка этих процессов влечёт за собой потерю данных, а, возможно, и сбои в работе приложений.
  #
  #Частично данную проблему можно решить за счёт использования механизма запуска процессов по расписанию с использованием PendingIntent - класса ожидающих намерений.
  #PendingIntent получает намерение и выполняет его по требованию, то есть является «управляющим» механизмом для запуска, регламентирования работы и остановки процессов.
  #При наличии такой регулировки приложения и сервисы запускаются по мере необходимости и не тратят заряд батареи на поддержку своей жизнедеятельности в фоновом режиме. В Android имеется несколько вариантов планировщиков, позволяющих организовать расписание для запуска действий.
  #
  #Класс AlarmManager
  #Механизм сигнализации в Android реализован в классе AlarmManager. Разработчики в документации подчёркивают назначение AlarmMаnager: запуск процессов по расписанию вне зависимости от состояния активности приложения. То есть данная сигнализация:
  #•	активирует приложение, если оно было неактивным;
  #•	может при запуске выводить устройство из режима сна, если устройство было неактивно;
  #•	срабатывает сразу после включения устройства, если в назначенное время устройство было выключено.
  #
  #Класс AlarmManager
  #Однако, с версии API 19 (Android 4.4.4 KitKat) была произведена оптимизация объекта AlarmManager в пользу экономии ресурса батареи за счёт управления пробуждениями устройства. Появилась возможность явного указания сигнализации на необходимость выводить устройство из режима сна. Без этого указания в режиме сна будильник срабатывать не будет, но сработает сразу же при переходе устройства в активное состояние.
  #Преимущества сигнализации:
  #•	возможность выполнения ожидающего намерения в определённый срок;
  #•	возможность использования AlarmManager в широковещательной рассылке для запуска сторонних процессов;
  #•	возможность управления другими процессами за рамками жизненного цикла текущего приложения или в режиме сна устройства;
  #•	возможность избежать использования ресурсоёмких служб и таймеров.
  #
  #Класс AlarmManager
  #AlarmManager целесообразно использовать для управления действиями за пределами работы текущего приложения.
  #При активном приложении разработчиками рекомендована организация фоновых потоков с использованием Handler.
  #Не рекомендуется использовать сигнализацию для организации сетевого взаимодействия. Для этих целей лучше использовать Firebase Cloud Messaging
  #Альтернативой сигнализации, выводящей устройство из режима сна, является механизм WorkManager
  #
  #https://developer.android.com/reference/kotlin/android/os/Handler
  #https://firebase.google.com/docs/cloud-messaging/
  #https://developer.android.com/jetpack/androidx/releases/work
  #
  #Класс AlarmManager
  #Точкой отсчёта времени срабатывания сигнализации может выступать как момент включения устройства и загрузки операционной системы, так и системное время, установленное на устройстве. Первый вариант более предпочтителен, поскольку не зависит от региональных настроек и не выполняет частых действий по проверке системного времени.
  #При использовании сигнализации следует придерживаться определённых правил:
  #•	желательно настраивать будильник на неопределённое время. В таком случае система будет запускать один будильник для всех задач, запланированных на ближайший диапазон времени. В противном случае на каждую задачу будет запущен отдельный будильник, что приведёт к нерациональному расходу заряда батареи;
  #•	действия над данными при сетевом взаимодействии выполнять в локальных процессах вне будильника и после его срабатывания;
  #•	не стоит будить устройство без необходимости, лучше использовать отложенную сигнализацию;
  #•	свести к минимуму использование времени часового пояса, по возможности время сигнализации настраивать в режиме отсчёта от момента загрузки устройства.
  #
  #Класс AlarmManager. Три режима.
  #1.	Одноразовая сигнализация set(Int, Long, PendingIntent!), которая срабатывает ровно один раз по прошествии времени от точки отсчёта и отключается;
  #2.	С точным повторением setRepeating(Int, Long, Long, PendingIntent!), которая срабатывает по прошествии заданного времени и потом повторяется через равные промежутки времени (этот будильник самостоятельно не отключается);
  #3.	С приблизительным повторением setInexactRepeating(Int, Long, Long, PendingIntent!), который срабатывает ориентировочно в установленное время от точки отсчёта и повторяется раз в установленный промежуток времени (один раз в день, один раз в час и т.п.)
  #Из повторяющихся режимов setInexactRepeating() более предпочтителен с точки зрения экономии энергии, поскольку в этом режиме сигнализация подстраивается под общее поведение системы и может быть запущена одна на несколько задач, запланированных примерно на одно время.
  #Для отмены установленной сигнализации применяется
  #метод cancel(PendingIntent!). Одноразовая сигнализация, как правило, в отмене не нуждается.
  #
  #Класс AlarmManager. API 23.
  #С API 23 в Android добавлена новая схема управления питанием - режим ожидания c пониженным энергопотреблением (Doze), отключающий все, в том числе и фоновые, пользовательские процессы. Отключение касается и сигнализаций, то есть они работать не будут. В случае необходимости вывода устройства из Doze - состояния AlarmManager запускают методами setAndAllowWhileIdle() или setExactAndAllowWhileIdle().
  #
  #1.	Создание класса запускаемого процесса:
  #class ExecProcess: [Activity() | BroadcastReceiver() | Service()] {
  #...
  #}
  #Запускаемым процессом может быть
  #•	активность в текущем приложении, запуск которой должен быть отложен на какое-то время;
  #•	приёмник широковещательных сообщений, предусматривающий выход за пределы контекста запускающего приложения;
  #•	сервис, так же работающий за пределами приложения.
  #2.	Создание намерения по запуску процесса:
  #val intent = Intent(context, ExecProcess::class.java)
  #
  #3.	Создание ожидающего намерения, запускающего подготовленное намерение по расписанию:
  #val pIntent = PendingIntent.get[Activity | Broadcast | Service] (context, requestCode, intent, flags)
  #4.	Подготовка объекта AlarmManager для принятия ожидающего намерения
  #val alarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager
  #5.	Установка ожидающего намерения на подготовленный объект сигнализации
  #alarmManager.set[Repeating](typeAlarm, triggerTime, [interval,] pIntent)
  #
  #Поскольку сигнализация является отложенным процессом, то и запускается она по отложенному намерению PendingIntent. Данный класс является "упаковкой" для обычного намерения Intent и представляет из себя ссылку на данные и действие с ними, размещенные в передаваемом намерении. Таким образом, отложенное намерение выполняет базовое намерение по определённому правилу.
  #PendingIntent имеет смысл применять в случае выхода расписания действий за пределы времени жизни запускающего его приложения, что вполне соответствует режиму работы сигнализации AlarmManager.
  #Для установки сигнализации, не зависимо от её режима, необходимо определить:
  #1.	Тип сигнализации
  #В классе AlarmManager существует четыре типа сигнализаций, использующих разные точки отсчёта времени и имеющие (не имеющие) право выводить устройство из спящего режима.
  #
  #2.	Время срабатывания сигнала
  #Устанавливается в зависимости от типа сигнализации. Если тип RTC, то используется временная шкала по системному времени, если тип ELAPSED_REALTIME, то время устанавливается от момента перезапуска устройства.
  #Для точных сигналов, работающих по системному времени можно устанавливать время с помощью объекта Calendar (используется в создании напоминаний и будильников)
  #val calendar = Calendar.getInstance() calendar.timeInMillis = System.currentTimeMillis() calendar.add(Calendar.HOUR_OF_DAY,14) calendar.set(Calendar.MINUTE,50)
  #
  #2.	Время срабатывания сигнала
  #Устанавливается в зависимости от типа сигнализации. Если тип RTC, то используется временная шкала по системному времени, если тип ELAPSED_REALTIME, то время устанавливается от момента перезапуска устройства.
  #Для точных сигналов, работающих по системному времени можно устанавливать время с помощью объекта Calendar (используется в создании напоминаний и будильников)
  #val calendar = Calendar.getInstance() calendar.timeInMillis = System.currentTimeMillis() calendar.add(Calendar.HOUR_OF_DAY,14) calendar.set(Calendar.MINUTE,50)
  #
  #3.	Временной интервал между срабатываниями
  #Первое срабатывание сигнализации происходит по прошествии времени, переданного во втором аргументе (Long-количество миллисекунд, прошедших от точки отсчёта) методов установки set(), setRepeating(), setInexactRepeating().
  #Временной интервал повторных сигналов так же задаётся в миллисекундах и передаётся в методах setRepeating(), setInexactRepeating() в третьем аргументе. У метода set() по понятным причинам данный аргумент отсутствует.
  #Для неточных сигнализаций (setInexactRepeating()) время повтора задаётся константами класса AlarmManager:
  #•	раз в день INTERVAL_DAY
  #•	раз в 15 минут INTERVAL_FIFTEEN_MINUTES
  #•	раз в 12 часов INTERVAL_HALF_DAY
  #•	раз в 30 минут INTERVAL_HALF_HOUR
  #•	раз в час INTERVAL_HOUR
  #
  #сигнализации. Примеры установки
  #сигнализации.
  #
  #
  #
  #alarmManager.set(AlarmManager.ELAPSED_ REALTIME)
  #
  #одноразовая сигнализация; время запуска не зависит от системного времени; срабатывает сразу, если устройство активно; в режиме сна не запускается, ожидая активации устройства
  #
  #
  #
  #
  #alarmManager.set(AlarmManager.RTC_WAK EUP,
  #calendar.timeInMillis, pIntent)
  #
  #одноразовая сигнализация; время срабатывания настроено в объекте Calendar; если к моменту запуска устройство неактивно, то выводит его из режима сна
  #
  #
  #Все сигнализации при перезагрузке устройства автоматически отключаются. Восстановление будильника можно регулировать с помощью установки флагов в методах запуска ожидающего намерения.
  #
  #сигнализации. Пример работы.
  #
  #
  #Сенсоры. Использование датчиков в мобильных устройствах
  #Каждое современное мобильное устройство оснащено датчиками, определяющими физическое состояние самого устройства.
  #Операционная система Android с помощью датчиков реагирует на пользовательское управление (сенсорный экран); определяет критические состояния устройства и вовремя принимает меры (если есть такая функциональность) или сигнализирует пользователю о необходимости их принятия (перегрев, повышенный расход заряда батареи); управляет отображением контента (поворот экрана, наклоны в игровом процессе); запускает приложения (счётчик шагов, пульс, активность человека).
  #
  #Сенсоры. Использование датчиков в мобильных устройствах. Аппаратные и программные.
  #Сенсоры по реализации делятся на два типа:
  #•	аппаратные (hardware-based), реализованные как составляющая единица аппаратного обеспечения устройства. Эти датчики получают данные с отслеживаемого параметра путём непосредственного измерения величин: температура воздуха, влажность, магнитное поле;
  #•	программные (software-based), использующие данные с аппаратных датчиков и интегрирующие их в одно измерение: сила тяжести, гравитация, ускорение, перемещение устройства в пространстве. Такие датчики называют виртуальными.
  #
  #Все датчики, поддерживаемые системой Android, можно условно разделить на три категории:
  #•	датчики окружающей среды. Аппаратные сенсоры для измерения температуры, влажности, давления, освещённости и других параметров окружающей атмосферы;
  #•	датчики положения: Аппаратные датчики: магнитометры, датчики положения устройства;
  #•	датчики движения. Виртуальные датчики, читающие данные с физических датчиков, размещённых по трём осям направлений: гироскопы, акселерометры, сенсоры центра тяжести.
  #
  #Набор датчиков зависит от конкретного устройства: даже на двух одинаковых моделях может оказаться различный набор датчиков. Следует учитывать, что программное управление датчиком так же зависит от используемого API: на устройстве может присутствовать некоторый сенсор, но если платформа его не поддерживает, то он доступен не будет.
  #https://developer.android.com/guide/topics/sensors/sensors_overview#sensor- availability
  #Android в составе пакета android.hardware располагает собственным набором классов обработки данных, поступающих с датчиков. Sensor Framework позволяет
  #•	опросить устройство по факту наличия датчиков и считать их характеристики;
  #•	собрать сведения о всех установленных на устройстве датчиках;
  #•	получить данные с датчика;
  #•	создать слушателя изменений показателей датчика.
  #
  #При отсутствии на устройстве датчика, используемого приложением, данное приложение не должно устанавливаться на устройство. В параметрах Google Play имеется функционал, позволяющий скрывать в маркете приложение, работающее с датчиком, отсутствующим на устройстве.
  #Для этого датчики регистрируются в файле манифеста:
  #<uses-feature android:name="android.hardware.sensor.compass" android:required="true"/>
  #Приложения, имеющие данное ограничение, не будут включаться в список поиска GooglePlay, выполняемого на устройстве без геомагнитного датчика.
  #
  #Свойство android:required позволяет регулировать видимость приложения в зависимости от его работы с указанным датчиком:
  #•	значение android:required ="true" устанавливается для приложений, которые без указанного датчика работать не смогут. Такие приложения на устройство установлены не будут;
  #•	значение android:required ="false" устанавливается для приложений, в которых датчик в случае его отсутствия на устройстве программно отключается. Такое приложение будет установлено на устройство, но функционал работы с отсутствующим датчиком реализован не будет.
  #
  #Класс, открывающий доступ к сенсорам устройства через создание объекта из
  #системной службы SENSOR_SERVICE.
  #val sm = getSystemService(SENSOR_SERVICE) as SensorManager
  #Объект SensorManager позволяет:
  #1.	Получить список установленных датчиков с их параметрами, вызовом метода
  #getSensorList(typeSensor: Int): sm.getSensorList(Sensor.TYPE_ALL)
  #Во входном параметре передаётся константа, определяющая тип сенсора. Начально значение константы было целочисленным, но с Android версии API
  #20.0 в набор были введены текстовые константы. Оба вида констант обращаются к одному и тому же сенсору, использование определённой константы зависит от минимальной версии операционной системы, на которую ориентируется приложение. Описание методик расчёта величин, получаемых с датчиков, размещено в документации по использованию свойства SensorEvent.values. Сами типы датчиков являются константами класса Sensor
  #
  #2.	Получить сведения о датчиках, используемых по умолчанию, можно методом
  #getDefaultSensor(Int), возвращающим объект Sensor:
  #var g = sm.getDefaultSensor(1) Log.d("info_sensor", ""+ g)
  #Результат:
  #{Sensor name="K6DS3TR Acceleration Sensor", vendor="STM", version=1, type=1, maxRange=78.4532, resolution=0.0023942017, power=0.25, minDelay=2000}
  #Датчик, используемый по умолчанию, может оказаться виртуальным и показывать усреднённые данные с нескольких сенсоров, из которых он состоит. По этой причине данные с датчиков по умолчанию не могут считаться точными, однако бывают случаи, когда такое выравнивание необходимо для корректной работы приложения: при ходьбе, при попадании на устройство прямых солнечных лучей и т.п.
  #
  #3.	Получить список динамических датчиков (на сегодняшний день в смартфонах
  #и планшетах не используются) можно методом getDynamicSensorList(type: Int). Метод добавлен в класс с версии Android 24 , что обосновано широким распространением других "умных" устройств помимо смартфона, которые в основном ориентированы на взаимодействие с сенсорами (AndroidThings).
  #Динамические датчики - это сенсоры, которые могут быть добавлены в устройство или изъяты из него аппаратно самим пользователем. Для взаимодействия с динамическими датчиками предусмотрен интерфейс DynamicSensorCallback
  #При отсутствии на устройстве подключаемых сенсоров запрос списка динамических датчиков возвращает пустой список:
  #if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
  #Log.d("info_sensor_dyn",""+sm.getDynamicSensorList(Sensor.TYPE_ALL))
  #}
  #Результат:
  #[]
  #
  #4.	Характеристики датчика можно получить при помощи методов класса Sensor:
  #
  #https://developer.android.com/reference/kotlin/android/hardware/Sensor#public- methods
  #
  #Для чтения данных с датчика необходимо для него зарегистрировать слушателя
  #методами registerListener(listener: SensorEventListener!, sensor: Sensor!, samplingPeriodUs: Int) или registerListener(listener: SensorEventListener!, sensor: Sensor!, samplingPeriodUs: Int, maxReportLatencyUs: Int)
  #sm = getSystemService(SENSOR_SERVICE) as SensorManager sensor = sm.getDefaultSensor(Sensor.TYPE_GYROSCOPE) sm.registerListener(this, sensor, SensorManager.SENSOR_DELAY_UI)
  #Нужно обязательно предусмотреть отсутствие датчика на устройстве:
  #
  #a)	прописать в манифесте требование на наличие датчика (при отсутствии сенсора приложение, устанавливаемое из .apk-файла не будет найдено и установлено)
  #<uses-feature
  #android:name="android.hardware.sensor.ambient_temperature" android:required="true"/>
  #или
  #b)	в момент регистрации слушателя сделать проверку на непустой объект сенсора
  #if(sensor !=null)
  #sensor.also { x -> sm.registerListener(this,x,SensorManager.SENSOR_DELAY_UI) } else Toast.makeText(this,"Нет датчика", Toast.LENGTH_LONG).show()
  #
  #Для чтения данных с датчика используются методы обратного вызова из
  #интерфейса SensorEventListener:
  #Таких методов два:
  #1.	onSensorChanged(event: SensorEvent!). Вызывается при каждом появлении значения отслеживаемого параметра. Если при очередном считывании значение параметра не изменилось, в массив данных записывается повторное значение.
  #lateinit var tw: TextView
  #...
  #override fun onSensorChanged(event: SensorEvent?) { tw.text = event!!.values[0].toString()
  #}
  #
  #2.	onAccuracyChanged(sensor: Sensor!, accuracy: Int). Вызывается только при
  #изменении точности отслеживаемого параметра. Вторым аргументом передаётся новая точность в виде константы класса SensorManager:
  #
  #SENSOR_STATUS_NO_CONTACT	-1	некорректные данные, поскольку датчик не
  #обращается к отслеживаемому объекту
  #
  #
  #SENSOR_STATUS_UNRELIABLE	0	датчик не откалиброван или недостаточно
  #возможностей для чтения показаний
  #
  #SENSOR_STATUS_ACCURACY_LOW	1	низкая точность показаний, требуется
  #калибровка окружающей среды
  #
  #
  #
  #SENSOR_STATUS_ACCURACY_MEDIU	2
  #M
  #
  #средний уровень показаний. Калибровка может повысить точность, но в большинстве случаев в этом нет необходимости
  #
  #
  #SENSOR_STATUS_ACCURACY_HIGH	3	максимальная точность показаний
  #
  #override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
  #val tw2 = findViewById<TextView>(R.id.temperature) when(accuracy){ SensorManager.SENSOR_STATUS_ACCURACY_HIGH -> tw2.text = "good“ SensorManager.SENSOR_STATUS_ACCURACY_LOW -> tw2.text = "bad“ SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM -> tw2.text = "average“ SensorManager.SENSOR_STATUS_NO_CONTACT -> tw2.text = "very bad“ SensorManager.SENSOR_STATUS_UNRELIABLE -> tw2.text = "oh!"
  #}
  #}
  #
  #Хранение данных
  #
  #
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Список тем дисциплины
  #1.	Хранение файлов Android приложения. Настройки приложения. Общее хранилище данных. Обмен данными.
  #2.	AndroidX Preferences Library. Реляционные базы данных. Язык SQL.
  #3.	Библиотека Android Room. Часть 1 и 2. Работа с камерой.
  #
  #Тема 1. Хранение файлов Android приложения.
  #Настройки приложения.
  #Общее хранилище. Обмен данными.
  #
  #В Android есть внутреннее Internal Storage и внешнее хранилище External
  #Storage. Исторически это были встроенная память в телефоне и внешняя SD- карта, поэтому объем внешнего хранилища как правило был больше, но медленнее и дешевле. Отсюда пошло разделение — настройки приложения и важные файлы для приложения записывали во внутреннее хранилище, а во внешнем хранили данные и большие файлы, например, медиаконтент. Потом внешнее хранилище также стало встраиваться в телефон, но логическое, сохранилось.
  #
  #У приложения всегда есть доступ к внутреннему хранилищу. Но эта папка только для конкретного приложения и она ограничена в памяти. К внешнему хранилищу необходимо было получать доступ и, кроме манипуляции со своими данными, можно было получить доступ к файлам и данным других приложений и производить с ними какие-либо действия (редактировать, удалять и т.д.).
  #
  #Чтобы минимизировать риски для пользователя в Google решили внедрить
  #технологию Scoped Storage во внешнее хранилище . Возможность проникнуть в папки других приложений убрали, а доступ есть только к своим данным — теперь это сугубо личная папка.
  #Папка внутреннего хранилища начиная с 10-й версии по умолчанию является зашифрованной. Если Scoped Storage не поддерживается на устройстве (ниже 10-й версии), то для доступа к данным других приложений потребуется получить доступ к чтению и записи в память. Иначе придётся получать доступ к файлам через Media Content, Storage Access Framework или новый, появившийся в 11-м Android, фреймворк Datasets в зависимости от типа данных. В таком случае придётся получать разрешение доступа к файлу, но по более интересной схеме. Когда общий файл создает само приложение сам, то доступ к нему не нужен. Однако, если переустановить приложение — доступ к нему опять потребуется.
  #
  #Способы хранения данных и файлов
  #На сегодняшний день в системе есть несколько вариантов хранения данных
  #приложения:
  #•	Специфичные для приложения файлы. Здесь хранятся файлы, предназначенные только для использования приложением. Доступ к файлам имеет только приложение, их создавшее. При этом файлы могут находиться во внутреннем и внешнем хранилище. У остальных приложений нет доступа, за исключением тех случаев, когда файлы хранятся на внешнем хранилище. При удалении приложения все файлы удаляются.
  #•	Общее (разделяемое) хранилище. Здесь хранятся файлы, которыми ваше приложение намерено поделиться с другими приложениями. Для медиафайлов (картинки, видео и т.д.) требуется разрешение READ_EXTERNAL_STORAGE или WRITE_EXTERNAL_STORAGE.
  #
  #Способы хранения данных и файлов
  #•	Настройки. Здесь хранятся данные по принципу "ключ-значение".
  #Доступно внутри приложения. Реализовано через Jetpack Preferences. Настройки удаляются, когда приложение удаляется пользователем.
  #•	Базы данных. Здесь хранятся структурированные данные в базе данных SQLite. На данный момент хранение реализовано через библиотеку Room. Доступ к данных при этом имеется только у приложения, в котором база была создана.
  #Решение по выбору одного из вариантов хранения зависит от конкретных потребностей, таких как, должны ли данные быть доступными только для вашего приложения или нет, сколько места требуется для ваших данных и др.
  #Характеристики разнообразных вариантов хранения данных изложены в официальной документации:
  #https://developer.android.com/training/data-storage
  #
  #При работе с внутренним и внешним хранилищем следует соблюдать осторожность, поскольку оно может быть не слишком большим и не подходить по объему для вашего приложения. Вдобавок к внутреннему хранилищу, устройство может иметь внешнее хранилище. В старых моделях им являлась съёмная SD-карта. Если ваше приложение слишком большое, можно указать в файле манифеста о необходимости устанавливать программу во внешнее хранилище:
  #<manifest ... android:installLocation="preferExternal">
  #...
  #</manifest>
  #Требования к разрешению работы с внешним хранилищем постоянно изменялись в зависимости от выхода новых версий системы Android. Сегодня приложение может иметь доступ к собственным и к некоторым общим файлам , которые находятся во внешнем хранилище. Доступ к общим файлам достигается через FileProvider API или контент-провайдеры.
  #
  #Для просмотра файлов через Android Studio можно воспользоваться инструментом Device File Explorer. Android определяет следующие разрешения, связанные с хранением файлов во внешней памяти:
  #•	READ_EXTERNAL_STORAGE - позволяет приложению считывать данные из внешнего хранилища.
  #•	WRITE_EXTERNAL_STORAGE - позволяет приложению записывать данные во внешнее хранилище.
  #•	MANAGE_EXTERNAL_STORAGE - позволяет приложению записывать данные во внешнее хранилище. Предназначен для использования несколькими приложениями, которым необходимо управлять файлами от имени пользователей. Если вашему приложению не нужен доступ к разрешению, удалите его из файла манифеста, иначе вы не сможете опубликовать свой продукт.
  #
  #Разрешения и доступ к внешнему хранилищу. Версии Android.
  #В более ранних версиях Android в приложениях необходимо было объявить разрешение READ_EXTERNAL_STORAGE для доступа к любому файлу за пределами каталогов приложения на внешнем хранилище. Кроме того, в приложениях необходимо было объявить разрешение WRITE_EXTERNAL_STORAGE на запись в любой файл за пределами каталога конкретного приложения.
  #
  #Более поздних версиях Android ситуация по работе с файлами (чтение или запись) больше зависит от их назначения, а не от его местоположения.
  #Например, если приложение предназначено для Android 11 или выше, разрешение WRITE_EXTERNAL_STORAGE никак не влияет на доступ приложения к хранилищу. Такой способ хранения данных повышает конфиденциальность пользователей, поскольку приложениям предоставляется доступ только к фактически используемым областям файловой системы
  #
  #В более ранних версиях Android в приложениях необходимо было объявить разрешение READ_EXTERNAL_STORAGE для доступа к любому файлу за пределами каталогов приложения на внешнем хранилище. Кроме того, в приложениях необходимо было объявить разрешение WRITE_EXTERNAL_STORAGE на запись в любой файл за пределами каталога конкретного приложения.
  #
  #Более поздних версиях Android ситуация по работе с файлами (чтение или запись) больше зависит от их назначения, а не от его местоположения.
  #Например, если приложение предназначено для Android 11 или выше, разрешение WRITE_EXTERNAL_STORAGE никак не влияет на доступ приложения к хранилищу. Такой способ хранения данных повышает конфиденциальность пользователей, поскольку приложениям предоставляется доступ только к фактически используемым областям файловой системы
  #
  #Чтобы предоставить пользователям больший контроль над собственными файлами и обеспечить их порядок, приложениям для версии Android 11 и выше, по умолчанию предоставляется ограниченный доступ к внешнему хранилищу или хранилищу с областью действия. Так например добавлено принудительное использование хранилища с ограниченной областью видимости (Scoped storage): доступ к каталогам внешних хранилищ ограничен каталогом конкретного приложения и определенными типами носителей, созданных приложением. Чтобы прочитать/записать данные на внешнем хранилище, требуется добавить в AndroidManifest.xml разрешения:
  #
  #<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
  #<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
  #
  #Запись в файл во внешнем хранилище
  #В пакете java.io существует метод openFileOutput(), который возвращает экземпляр класса FileOutputStream для записи файла во внешнее хранилище устройства. Для того чтобы получить каталог, который используется только вашим приложением, необходимо вызвать метод getExternalFilesDir(). Чтобы записать данные в файл, вызовите метод fileOutputStream.write().
  #var myExternalFile:File = File(getExternalFilesDir(filepath),fileName) try {
  #val fileOutPutStream = FileOutputStream(myExternalFile) fileOutPutStream.write(fileContent.toByteArray()) fileOutPutStream.close()
  #} catch (e: IOException) { e.printStackTrace()
  #}
  #
  #Чтение из файла во внешнем хранилище
  #Кроме этого пакет java.io предлагает метод openFileInput(), который возвращает экземпляр класса FileInputStream и считывает файл из внешнего хранилища устройства. Чтобы прочитать данные из файла, необходимо вызвать метод BufferedReader().readLine():
  #var myExternalFile:File = File(getExternalFilesDir(filepath), fileName) val filename = fileName.text.toString()
  #myExternalFile = File(getExternalFilesDir(filepath),filename) var fileInputStream =FileInputStream(myExternalFile)
  #var inputStreamReader: InputStreamReader = InputStreamReader(fileInputStream) val bufferedReader: BufferedReader = BufferedReader(inputStreamReader)
  #val stringBuilder: StringBuilder = StringBuilder() var text: String? = null
  #while ({ text = bufferedReader.readLine(); text }() != null) { stringBuilder.append(text)
  #}
  #fileInputStream.close()
  #
  #Во многих приложениях создаются файлы. При этом другие приложения зачастую не должны иметь к ним доступ. Система Android предоставляет следующие возможности для хранения таких файлов:
  #•	Внутренние каталоги. Они содержат в себе выделенное место для хранения постоянных файлов и данных кэша. Система Android запрещает доступ другим приложениям к этим файлам, и начиная с версии Android 10 (уровень API 29) и выше эти местоположения зашифрованы.
  #•	Внешние каталоги. Они также содержат выделенное место для хранения постоянных файлов и данных кэша. Другие приложения могут получить доступ данных только в случае наличия специального разрешения. Когда такой доступ необходим, приложение должно хранить эти файлы в общей части внешнего хранилища.
  #
  #При удалении приложения, файлы, созданные в хранилище для него также
  #удаляются. Таким образом, не стоит сохранять файлы в подобные хранилища , если материалы могут быть полезны пользователю вне зависимости от того есть приложение на устройстве или его нет. К примеру, если в вашем приложении можно делать снимки с камеры, то пользователь будет ожидать возможность их использования. Необходимо обеспечить доступ к этим фотографиям даже после удаления вашего приложения.
  #
  #Для каждого приложения система предоставляет два каталога во внутреннем хранилище. Один предназначен для постоянных файлов, а другой содержит кэшированные файлы приложений. При этом, как было сказано ранее, другие приложения не имеют е ним доступ к файлам, что делает внутреннее хранилище хорошим местом для хранения конфиденциальной информации приложений.
  #Данные каталоги имеют относительно небольшой размер памяти, соответственно перед записью файлов необходимо запросить размер свободного пространства на устройстве.
  #
  #При удалении приложения, файлы, созданные в хранилище для него также
  #удаляются. Таким образом, не стоит сохранять файлы в подобные хранилища , если материалы могут быть полезны пользователю вне зависимости от того есть приложение на устройстве или его нет. К примеру, если в вашем приложении можно делать снимки с камеры, то пользователь будет ожидать возможность их использования. Необходимо обеспечить доступ к этим фотографиям даже после удаления вашего приложения.
  #
  #Для каждого приложения система предоставляет два каталога во внутреннем хранилище. Один предназначен для постоянных файлов, а другой содержит кэшированные файлы приложений. При этом, как было сказано ранее, другие приложения не имеют е ним доступ к файлам, что делает внутреннее хранилище хорошим местом для хранения конфиденциальной информации приложений.
  #Данные каталоги имеют относительно небольшой размер памяти, соответственно перед записью файлов необходимо запросить размер свободного пространства на устройстве.
  #
  #Первым вариантом для доступа к файлам и их хранения выступает
  #использование File API. Следующий фрагмент кода демонстрирует, как его использовать:
  #val file = File(context.filesDir, filename)
  #В качестве альтернативы использованию файлового API можно задействовать метод openFileOutput(). В следующий код демонстрирует как записать текст в файл:
  #val filename = "myfile"
  #val fileContents = "My IT Academy!" context.openFileOutput(filename, Context.MODE_PRIVATE).use {
  #it.write(fileContents.toByteArray())
  #}
  #Здесь следует отметить, что на устройствах с Android 7.0 или выше, если не передать режим доступа к файлу MODE_PRIVATE в метод openFileOutput(), появиться исключительная ситуация SecurityException.
  #
  #Для чтения файла в потоковом режиме необходимо использовать метод
  #openFileInput(). Сделать это можно следующим образом:
  #context.openFileInput(filename).bufferedReader().useLines { lines -> lines.fold("") { my, message ->
  #"$my\n$message "
  #}
  #}
  #Еще одной опцией является получение массива из имен каталоге filesDir. Для этого целесообразно вызвать метод fileList(), например следующим образом:
  #var files: Array<String> = context.fileList()
  #
  #Каталог кэша
  #Для хранения временных данных, можно использовать каталог кэша. Он предназначен для хранения небольшого количества данных, доступных только внутри разработанного приложения. При этом при удалении приложения все файлы так же будут удалены. В случае недостатка места на устройстве, система Android может удалить файлы кэша. Во избежание ошибок нужно проверить наличие файлов кэша перед их чтением. Для определения доступного места в каталоге кэша можно вызвать метод getCacheQuotaBytes(), а для создания кэшированного файла можно использовать следующий код:
  #File.createTempFile(filename, null, context.cacheDir)
  #В случае недостатка места на устройстве, система Android может удалить файлы кэша. Во избежание ошибок нужно проверить наличие файлов кэша перед их чтением.
  #
  #Пример работы
  #
  #
  #
  #Разберем проект, в котором будем записывать и считывать данные из файла из внутреннего хранилища устройства.
  #
  #В случаях когда данные приложения должны быть доступны другим
  #приложениям можно использовать общее хранилище пользовательских данных. Даже если пользователь удаляется ваше приложения, информация в общем хранилище сохраняется. Само название указывает на то, что его можно использовать в приложении на устройстве. Любое приложение может получить доступ к этим данным. До версии Android Q разработчик должен был получать разрешения от пользователя на чтение и запись данных в общее хранилище. Начиная с Android Q с появилось Scoped Storage и теперь разработчику не нужно получать разрешение на запись, чтение и изменение собственных данных нашего приложения.
  #Scoped Storage — это изолированные куски памяти, выделяемые каждому приложению, впрочем, это даже можно понять по названию. В настоящее время в Android приложения работают с памятью по аналогии с Windows — они получают доступ ко всей файловой системе. Scoped Storage позволит изолировать определенные ячейки памяти под конкретные приложения. Есть несколько ключевых причин такого нововведения. С одной использование устройств становиться более безопасным, с другой стороны, в файловой системе устройства стало больше детерминированности.
  #
  #Благодаря концепции хранилища Scoped Android система знает, какой файл
  #создается каким приложением, и за счет чего происходит лучшее управления файлами приложения. Из Android Q и выше разработчик не может напрямую получить доступ к расположению общих данных. Для доступа к ним необходимо указать в манифесте приложения разрешение
  #«ACCESS_MEDIA_LOCATION».
  #Android предоставляет API для хранения и доступа к следующим типам общих данных:
  #•	Медиа. В Android есть общедоступные каталоги для медиаресурсов: фото, аудиофайлы и т.д. Приложение может получить доступ к медиаконтенту с использованием MediaStore API платформы, о котором речь пойдет позже.
  #•	Документы. В системе есть специальный каталог для хранения документов (например файлов PDF или книг использующие в формате EPUB). Для доступа к этим файлам можно использовать Storage Access Framework.
  #
  #•	Датасеты. На Android 11 (уровень API 30) и выше система кэширует
  #большие наборы данных, используемые несколькими приложениями. Данные наборы могут использоваться например при решении задач машинного обучения. Приложения могут получить доступ к этим общим наборам данных с помощью API BlobStoreManager.
  #
  #Доступ к медиа в общем хранилище
  #MediaStore API - это рекомендуемый способ работы с медиафайлами (изображения, аудио, видео). Для взаимодействия с хранилищем мультимедия файлов необходимо использовать объект ContentResolver, извлекаемый из контекста приложения.
  #MediaStore API сохраняет данные в виде базы данных. Для каждого вида файла существует отдельная таблица для хранения данных. Для хранения обычно используется три типа файлов: изображения, видео и аудио. Начиная с версии Android 10, добавлена новая коллекция Download Collections. Для изображений используют MediaStore.Images, для видео - таблица MediaStore.Video, для аудиофайлов - MediaStore.Audio, для загрузок - таблица MediaStore.Downloads.
  #
  #В MediaStore API для чтения данных с устройства, предоставленных приложением, нет необходимости получать специальное разрешение от пользователя. Однако, для обработки данных, которые не создавались нашим приложением, необходимо получить соответствующие разрешения от пользователя устройства на доступ к ним.
  #
  #Получить файлы мультимедиа можно следующим способом:
  #val projection = arrayOf(MediaStore.Images.Media._ID, MediaStore.Images.Media.DISPLAYNAME, MediaStore.Images.Media.DATE_TAKEN)
  #val selection = "${MediaStore.Images.Media.DATE_TAKEN} >= ?"
  #val selectionArgs = arrayOf dateToTimestamp(day = 24, month = 7, year = 2019).toString())
  #val sortOrder = "${MediaStore.Images.Media.DATE_TAKEN} DESC”
  #getApplication().contentResolver.query( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, projection,
  #selection, selectionArgs, sortOrder)?.use
  #{ cursor -> imageList = addImagesFromCursor(cursor) }
  #
  #В коде:
  #•	projection - массив, содержащий всю необходимую информацию медиафайла. Это похоже на запрос select базы данных.
  #•	selection - аналогично оператору where при запросах в базе данных. Содержит условие, на основании которого должны быть получены данные.
  #•	selectionArgs - массив, содержащий значения, по которым осуществляется выбор.
  #•	sortOrder - ключ, используемый для сортировки данных по столбцу и порядку. По умолчанию порядок возрастающий. Для убывающего порядка, используйте ключевое слово DESC.
  #•	query() - метод класса ContentResolver, который принимает все вышеперечисленные параметры, а также дополнительный параметр Uri, который сопоставляется с требуемой таблицей в провайдера.
  #
  #Открытие файлов
  #При открытии медиафайлов можно использовать несколько вариантов. Логика их использования во многом зависит от того как лучше представлять медиаконтент: в виде файлового дескриптора, потока файлов или пути к файлу. Чтобы открыть медиафайл с помощью файлового дескриптора, необходимо задействовать логику, аналогичную следующей:
  #val resolver = applicationContext.contentResolver val readOnlyMode = "r"
  #resolver.openFileDescriptor(content-uri, readOnlyMode).use { pfd ->
  #// операции с pdf
  #}
  #
  #Сохранение данных
  #Далее приведен пример сохранения данных с помощью Scoped Storage: val values = ContentValues().apply { put(MediaStore.Images.Media.DISPLAY_NAME, name) put(MediaStore.Images.Media.MIME_TYPE, “image/jpeg") put(MediaStore.Images.Media.RELATIVE_PATH, “Pictures/$bucketName/") put(MediaStore.Images.Media.IS_PENDING, 1)
  #}
  #val collection = MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRI MARY)
  #val imageUri = context.contentResolver.insert(collection, values) context.contentResolver.openOutputStream(imageUri).use { out -> bmp.compress(Bitmap.CompressFormat.JPEG, 90, out)
  #}
  #values.clear() values.put(MediaStore.Images.Media.IS_PENDING, 0) context.contentResolver.update(imageUri, values, null, null)
  #
  #Пример
  #Рассмотрим приложение, в котором по нажатию кнопки в текстовом поле будут отображаться имена файлов двадцати последних сохраненных на устройстве изображений вместе с датой их последнего изменения.
  #
  #
  #Обмен простыми данными между приложениями
  #Одной из замечательных опций приложений для Android-приложений - это их способность общаться и интеграции друг с другом. Действительно, зачем изобретать функционал, который не является базисом для вашего приложения, когда он уже есть в другом?
  #Например, вы можете поделиться изображением из приложения Google Photo в другое приложение, чтобы создать какое-то сообщение или историю. В настоящее время это обычная функция для приложенияй Android.
  #В данном разделе рассмотрим некоторые распространенные способы отправки и получения простых данных (например, изображений, текста или файлов) между приложениями с помощью таблицы общих ресурсов Android и намерений.
  #
  #Для отправки простых данных другим приложениям в Android используются намерения. Существует два способа обмена данными между приложениями:
  #1.	Общая таблица (Sharesheet) Android. Предназначена для отправки информации за пределы приложения и/или непосредственно другому пользователю. Например, совместное использование URL-адреса с другим пользователем.
  #2.	Распознаватель намерений (Intent Resolver) Android. В большей степени подходит для передачи данных на следующий этап четко определенной задачи.
  #
  #При создании намерения требуется указание действия, которое должно при этом выполнятся. Для отправки данных из одной активности в другую в намерение необходимо передать константу [ACTION_SEND]:
  #https://developer.android.com/reference/android/conte nt/Intent#ACTION_SEND
  #При этом кому доставляются данные, не уточняется. Также необходимо указать данные и их тип. Система автоматически идентифицирует совместимые активности, которые могут получать данные, и отображает их для выбора пользователю. На экране приложения появляются доступные приложения для отправки контента.
  #
  #В целях обеспечения согласованности действий пользователей в разных приложениях, при передачи данных разработчики рекомендуют все же использовать первый способ (Sharesheet). Такой метод передачи данных дает пользователям возможность делиться информацией с другими пользователями или приложениями всего в один клик.
  #Схематично обмен данными в приложении выглядит так, как показано на рисунке ниже:
  #
  #
  #Отправка простых данных другим приложениям. ShareSheet.
  #Для передачи информации необходимо создать намерение и установить для его действия значение Intent.ACTION_SEND. Чтобы отобразить Sharesheet Android, вам нужно вызвать метод Intent.createChooser().
  #Наиболее простое и распространенное использование Android Sharesheet - отправка текстового сообщения из одной активности в другую. Например, это может быть полезно для обмена статьей или веб-сайтом с друзьями по электронной почте или в социальных сетях. Далее представлен фрагмент кода, где показано как это сделать:
  #val sendIntent: Intent = Intent().apply { action = Intent.ACTION_SEND
  #putExtra(Intent.EXTRA_TEXT, "Hello, world!!!") type = "text/plain"
  #}
  #val shareIntent = Intent.createChooser(sendIntent, null) startActivity(shareIntent)
  #
  #При необходимости в намерение можно добавить дополнительные сведения, например электронную почту получателя (EXTRA_EMAIL), тему письма (EXTRA_SUBJECT) и др.
  #С помощью действия ACTION_SEND есть возможность поделиться двоичными данными. Для этого необходимо установить соответствующий тип MIME и передать Intent.EXTRA_STREAM и URI ресурса в метод putExtras(). Обычно данный подход задействуют для совместного использования изображений, однако он может использоваться для совместного использования любого типа двоичного контента.
  #val shareIntent: Intent = Intent().apply { action = Intent.ACTION_SEND putExtra(Intent.EXTRA_STREAM, uri) type = "image/jpeg"
  #}
  #startActivity(Intent.createChooser(shareIntent, resources.getText(R.string.send_to)))
  #
  #Получающему приложению необходимо разрешение на доступ к данным, на которые указывает URI. Это можно сделать, используя один следующих способов:
  #•	Хранение данных в своем собственном контент-провайдере (ContentProvider). При этом целесообразно убедиться, что другие приложения имеют правильное разрешение на доступ к нему. Разработчики предлагают в качестве предпочтительного механизма использование временных разрешений на URI и предоставление доступа только приложению-получателю. Простой способ такай ContentProvider - использовать класс FileProvider.
  #
  #•	Использование MediaStore API. Хранилище MediaStore в основном используется для типов MIME видео, аудио и изображений. Но, начиная с Android 3.0 (уровень API 11), в нем можно хранить типы, не относящиеся к мультимедиа.
  #
  #Для того, чтобы отправить другому приложению несколько фрагментов с содержимым, необходимо передать в метод putExtras() аргументы Intent.ACTION_SEND_MULTIPLE вместе со списком уникальных идентификаторов ресурсов. Тип MIME при этом варьируется в зависимости от сочетания контента, которым вы делитесь. К примеру, если вы хотите сразу передать три изображения PNG, тип MIME также будет "image/png". При сочетании файлов изображения с различным расширением необходимо использовать "image/".
  #Использование совместных MIME-типов возможно (используйте "/*"), однако не рекомендовано поскольку получателю неясно, что должно быть отправлено.
  #Анализ и обработка ваших данных зависит от принимающего приложения. Приведем пример:
  #
  #val uris: ArrayList<Uri> = arrayListOf( imageUri1,
  #imageUri2
  #)
  #val shareIntent = Intent().apply {
  #action = Intent.ACTION_SEND_MULTIPLE putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris) type = "image/*"
  #}
  #startActivity(Intent.createChooser(shareIntent, "Share images to.."))
  #
  #Начиная с Android 10 (уровень API 29), на Sharesheet Android отображается предварительный просмотр текста содержимого сообщения. Иногда данный текст труден для понимания. Для этого существует опция более детального просмотра содержимого присланного сообщения. Для того, чтобы принимающее приложение или пользователь понял, что за сообщение ему пришло, при предварительном просмотре текста можно задать его заголовок и миниатюру.
  #Сделать это можно следующим образом:
  #val share = Intent.createChooser(Intent().apply { action = Intent.ACTION_SEND putExtra(Intent.EXTRA_TEXT,“URL”)
  #// заголовок содержимого
  #putExtra(Intent.EXTRA_TITLE, "Introducing to data sharing!")
  #// URI контента изображению для отображения data = contentUri
  #flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
  #}, null) startActivity(share)
  #
  #Отправка простых данных другим приложениям. IntentResolver.
  #Его использование целесообразно при отправке данных в другое приложение в рамках определенного потока задач. Ключевым отличием от использования Sharesheet выступает отсутствие необходимости вызова метода Intent.createChooser():
  #val sendIntent: Intent = Intent().apply { action = Intent.ACTION_SEND putExtra(Intent.EXTRA_TEXT, "Hello!!!") type = "text/plain"
  #}
  #startActivity(sendIntent)
  #
  #Приложение также может получать данные и из других приложений. При разработке приложений-приемников необходимо подумать, как пользователи взаимодействуют с вашим ними и какие типы данных необходимо получать от других приложений. Например, в мессенджере можно получать сообщения, фото, видео и т.д. Ранее было рассказано о двух способах оправления контента: через Sharesheet и Intent Resolver. Все полученные данные имеют тип MIME, заданный передающим приложением. Ваше приложение должно иметь возможность получать максимально широкий спектр типов MIME.
  #
  #Для определения того, какие данные приложение готово принять существуют фильтры в манифесте. В приложениях-приемниках сообщений необходимо определить фильтр намерений в манифесте, используя элемент <intent-filter>. Например, если ваше приложение обрабатывает прием текста, одного или нескольких изображений любого типа, файл AndroidManifest.xml может выглядеть так:
  #
  #<activity android:name=".MyActivity" >
  #<intent-filter>
  #<action android:name="android.intent.action.SEND" />
  #<category android:name="android.intent.category.DEFAULT" />
  #<data android:mimeType="image/*" />
  #</intent-filter>
  #<intent-filter>
  #<action android:name="android.intent.action.SEND" />
  #<category android:name="android.intent.category.DEFAULT" />
  #<data android:mimeType="text/plain" />
  #</intent-filter>
  #<intent-filter>
  #<action android:name="android.intent.action.SEND_MULTIPLE" />
  #<category android:name="android.intent.category.DEFAULT" />
  #<data android:mimeType="image/*" />
  #</intent-filter>
  #</activity>
  #
  #Когда приложение-отправитель попытается поделиться соответствующим контентом, ваше приложение будет в списке на предполагаемую рассылку. Если пользователь выберет ваше приложение для рассылки, будет запущена активность MyActivity из предыдущего примера.
  #Для получения необходимого намерения, в приложении-приемнике сообщения сначала необходимо вызвать метод getIntent(). Получив нужный объект и изучив его можно определить дальнейшие действия. При этом нужно помнить о необходимости обработки двоичных данных в отдельном потоке. Код в приложении-приемнике может быть следующим:
  #
  #override fun onCreate(savedInstanceState: Bundle?) {
  #when {
  #intent?.action == Intent.ACTION_SEND -> { if ("text/plain" == intent.type) {
  #handleSendText(intent) // обработка отправляемого текста
  #} else if (intent.type?.startsWith("image/") == true) { handleSendImage(intent) // обработка одной отправляемой картинки
  #}
  #}
  #intent?.action == Intent.ACTION_SEND_MULTIPLE && intent.type?.startsWith("image/") == true -> { handleSendMultipleImages(intent)
  #// обработка множества отправляемых картинок
  #}
  #else -> {
  #// обработка других намерений
  #}
  #}
  #}
  #
  #private fun handleSendText(intent: Intent) {
  #intent.getStringExtra(Intent.EXTRA_TEXT)?.let {
  #// обновление UI для отображение отправленного текста
  #}
  #}
  #private fun handleSendImage(intent: Intent) { (intent.getParcelableExtra<Parcelable>(Intent.EXTRA_STREAM) as? Uri)?.let {
  #// обновление UI для отображение отправленного изображения
  #}
  #}
  #private fun handleSendMultipleImages(intent: Intent) { intent.getParcelableArrayListExtra<Parcelable>(Intent.EXTRA_STREAM)?.let {
  #// обновление UI для отображение множества отправленных изображений
  #}
  #}
  #Обновление пользовательского интерфейса после получения данных зависит от функционала приложения.
  #
  #Пример
  #Рассмотрим простое приложение, которое может делиться содержимым, таким как URL, текст и файлы изображений с другими приложениями, установленными на вашем устройстве Android.
  #
  #
  #
  #
  #Хранение данных
  #
  #
  #
  #
  #
  #
  #Степанов Павел Валериевич
  #
  #Тема 2. AndroidX Preferences Library. Реляционные базы данных. Язык SQL.
  #
  #AndroidX Preference library
  #Во многих приложения можно увидеть настройки. Они позволяют
  #пользователям адаптировать приложение под себя, настроить внешний вид и режим работы. Кроме того, в экранах настройки зачастую предоставлены ссылки на внешнюю информацию (политика конфиденциальности, лицензии с открытым исходным кодом и многое другое). Данные экраны можно разрабатывать самостоятельно, при этом требуется не только создать пользовательский интерфейс экрана настроек, но и прописать необходимую логику поведения приложения при их изменении.
  #
  #Android Jetpack содержит библиотеку настроек Preference Library, которая в значительной степени помогает разработчикам в создании экранов настроек. С помощью библиотеки AndroidX Preference library можно создавать интерактивные экраны настроек без необходимости взаимодействия с хранилищем устройства или управления пользовательским интерфейсом. Для использования данной библиотеки в файл build.gradle вашего проекта необходимо добавить следующие зависимости:
  #dependencies {
  #def preference_version = "1.1.1"
  #implementation "androidx.preference:preference-ktx:$preference_version"
  #}
  #
  #Иерархия настроек используется для определения различных свойств
  #настроек, которые могут быть установлены в приложении. Существует два способа определения иерархии настроек: программно или в файле XML. Способ отображения наших настроек в соответствующий компонент приложения (активность или фрагмент), будет зависеть от того, как мы изначально определяем иерархию настроек.
  #В случае если для построения иерархии настроек мы используем XML, необходимо определить новый файл ресурсов PreferenceScreen в каталоге res/xml. Далее можно определить различные настройки, которые мы хотим отображать на этом экране.
  #Например можно создать xml-файл с настройками res/xml/pref.xml образом:
  #
  #
  #
  #
  #После этого создастся xml-файл с корневым элементом РreferenceScreen, куда
  #можно добавлять остальные xml-элементы настроек (добавлять можно вручную или с помощью конструктора). Далее необходимо определить различные настройки, которые мы хотим отображать на экране настроек. Если мы создаем настройки программно, то требуется перейти непосредственно к компоненту, который мы собираемся использовать для нашего экрана.
  #
  #
  #
  #
  #Существует множество различных типов настроек. Рассмотрим некоторые из
  #них.
  #Текстовый элемент
  #<Preference
  #android:key="preference_key" android:title="@string/preference_title" android:summary="@string/preference_summary" />
  #В данном случае определено три атрибута элемента Preference:
  #•	key - ключ используется для сохранения и извлечения значения настроек;
  #•	title - заголовок, используемый в отображении настроек;
  #•	summary - описание настроек.
  #В итоге на экране будет показано следующее:
  #
  #Типы настроек. CheckBoxPreference.
  #Например можно использовать CheckBoxPreference:
  #<CheckBoxPreference android:key="checkbox"
  #android:title="@string/title_checkbox_preference" android:summary="@string/preference_summary"/>
  #Или программно:
  #val checkBoxPreference = CheckBoxPreference(context).apply { key = "checkbox"
  #title = "Checkbox"
  #summary = "This one has a checkbox"
  #}
  #
  #
  #Типы настроек. SwitchPreferenceCompat.
  #Также в настройках можно задействовать switch-переключатели:
  #<SwitchPreferenceCompat android:key="switch"
  #android:title="@string/title_switch_preference" android:summary="@string/preference_summary"/>
  #
  #
  #
  #
  #
  #Типы настроек. DrowDownPreference.
  #DropDownPreference - этот виджет позволяет отображать раскрывающийся список элементов на выбор пользователя. В приложение добавим два ресурс- массива:
  #<string-array name="entries">
  #<item>one</item>
  #<item>two</item>
  #</string-array>
  #<string-array name="entry_values">
  #<item>1</item>
  #<item>2</item>
  #</string-array>
  #Тогда код для DropDownPreference может быть следующий:
  #<DropDownPreference android:key="dropdown"
  #android:title="@string/title_dropdown_preference" android:entries="@array/entries" app:useSimpleSummaryProvider="true" android:entryValues="@array/entry_values"/>
  #
  #При нажатии на элемент настройки появляется выпадающий список:
  #
  #
  #Создание соответствующей настройки программно будет выглядеть следующим образом:
  #val dropDownPreference = DropDownPreference(context).apply { key = "drop_down"
  #title = "Some title"
  #entries = arrayOf("One", "Two", "Three") entryValues = arrayOf("1", "2", "3")
  #}
  #
  #Типы настроек. SeekBarPreference.
  #Следующим примером настройки выступает SeekBarPreference, в котором задействована специальная шкала:
  #<SeekBarPreference android:key="seekbar" android:title="Seek bar!" android:max="10" android:defaultValue="5" />
  #
  #
  #Типы настроек. SeekBarPreference.
  #В данном случае существует еще несколько атрибутов, которые мы можем установить, кроме обычных ключей и заголовка.
  #•	max - максимальное значение, которое можно выбрать с помощью шкалы поиска.
  #•	defaultValue - значение по умолчанию, которое будет отображаться на панели поиска, когда его нет/до того, как оно будет установлено.
  #При добавлении данной настройки программно можно использовать следующий код:
  #val seekBarPreference = SeekBarPreference(context).apply { key = "seekbar"
  #title = "Some title" max = 10 setDefaultValue(5)
  #}
  #
  #Типы настроек. EditTextPreference.
  #Библиотека AndroidX Preference позволяет использовать элементы настроек, в которых пользователь можно ввести некоторые данные в отдельном окне.
  #Первым из них является элемент EditTextPreference, который позволяет ввести некоторый текст, который будет сохранен в качестве значения для элемента настройки.
  #<EditTextPreference android:key="edittext" android:title="Some input"
  #app:useSimpleSummaryProvider="true" android:dialogTitle="This is the title"/>
  #При нажатии на виджет появится следующее диалоговое окно:
  #
  #
  #Типы настроек. ListPreference.
  #Следующим виджетом выступает ListPreference, который отображает предопределенный список элементов:
  #<ListPreference android:key="list" android:title="Some list"
  #app:useSimpleSummaryProvider="true" android:entries="@array/entries" android:entryValues="@array/entry_values" />
  #При создании элемента программно, код может выглядеть следующим образом:
  #val listPreference = ListPreference(context).apply { key = "drop_down"
  #title = "Some title"
  #entries = arrayOf("One", "Two", "Three") entryValues = arrayOf("1", "2", "3")
  #}
  #
  #Типы настроек. MultiSelectListPreference.
  #Элемент MultiSelectListPreference работает аналогично элементу ListPreference с той разницей, что при этом пользователь может выбрать несколько значений списка.
  #<MultiSelectListPreference android:key="multi_select_list" android:title="Some multi select list" android:summary="This is a summary" android:entries="@array/entries" android:entryValues="@array/entry_values"/>
  #
  #Типы настроек. PreferenceCategory.
  #Для группировки настроек используют их разбиение на категории. Например сделать это можно следующим образом:
  #<PreferenceCategory android:title="Text">
  #<Preference android:key="preference_key" android:title="@string/preference_title"
  #android:summary="@string/preference_summary" />
  #<Preference android:key="preference_key" android:title="@string/preference_title"
  #android:summary="@string/preference_summary" android:icon="@drawable/ic_launcher_background" />
  #</PreferenceCategory>
  #…
  #
  #Типы настроек. Группировка.
  #<PreferenceCategory android:title="Switches">
  #<CheckBoxPreference android:key="checkbox"
  #android:title="@string/title_checkbox_preference" android:summary="@string/preference_summary"/>
  #<SwitchPreferenceCompat android:key="switch"
  #android:title="@string/title_switch_preference" android:summary="@string/preference_summary"/>
  #</PreferenceCategory>
  #
  #Типы настроек. Группировка.
  #На экране приложения это будет выглядеть следующим образом:
  #
  #PreferenceCategory также может быть создана программно:
  #val notificationCategory = PreferenceCategory(context).apply { key = "notifications_category"
  #title = "Notifications"
  #}
  #
  #Отображение настроек
  #Для отображения экрана настроек приложения, необходимо создать экземпляр класса PreferenceFragmentCompat. Если мы собираемся отображать настройки из файла xml, то код будет следующим:
  #class SettingsFragment : PreferenceFragmentCompat() {
  #override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) { setPreferencesFromResource(R.xml.prefs, rootKey)
  #}
  #}
  #
  #Отображение настроек. onCreatePreferences()
  #Внутри класса переопределим метод onCreatePreferences() для настройки нашего экрана Preferences. В данном фрагменте можно настроить параметры программно с использованием класса PreferenceManager. В случае конфигурации меню настройки программно настраивать элементы необходимо вручную.
  #Например это можно сделать следующим образом:
  #override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) { val context = preferenceManager.context
  #val screen = preferenceManager.createPreferenceScreen(context) val notificationPreference = SwitchPreferenceCompat(context) val feedbackPreference = Preference(context) screen.addPreference(notificationPreference) screen.addPreference(feedbackPreference)
  #preferenceScreen = screen
  #}
  #
  #Отображение настроек. Preference Manager
  #Preference Manager возвращает экземпляр класса PreferenceScreen, который используется для отображения экрана настроек. Для того чтобы виджеты настроек отображались, необходимо задействовать метод addPreference(). Его можно вызвать для любого элемента настройки. Сначала необходимо создать элемент настроек, например следующим образом:
  #val notificationCategory = PreferenceCategory(context).apply { key = "notifications"
  #title = "notifications" initialExpandedChildrenCount = 1
  #}
  #Далее следует передать его методу addPreference() и присвоить переменную screen переменной preferenceScreen:
  #screen.addPreference(notificationPreference) preferenceScreen = screen
  #
  #Отображение настроек. Итог
  #Далее можно создать активность для отображения фрагмента с настройками
  #приложения. В приведенном ниже примере создан вложенный класс
  #SettingsFragment внутри SettingsActivity:
  #class SettingsActivity : AppCompatActivity() {
  #override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.settings_activity) supportFragmentManager
  #.beginTransaction()
  #.replace(R.id.settings, SettingsFragment())
  #.commit() supportActionBar?.setDisplayHomeAsUpEnabled(true)
  #}
  #class SettingsFragment : PreferenceFragmentCompat() {
  #override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) { setPreferencesFromResource(R.xml.prefs, rootKey)
  #}
  #}
  #}
  #
  #Отображение настроек. Пример.
  #Создадим простое приложение, состоящие из главной активности, активности с
  #настройками с одним элементом SwitchPreference, при изменении которого на экране будет появляться Toast-сообщение со статусом виджета (On/Off).
  #
  #
  #База данных (БД) — это специальным образом организованная совокупность данных о некоторой предметной области, хранящаяся во внешней памяти компьютера.
  #Система управления базами данных (СУБД) — это программные средства для создания и обработки (добавления, изменения, поиска данных).
  #
  #В современном мире БД используют во многих областях, например:
  #Когда покупатель в супермаркете оплачивает товары на кассе, то кассир через сканер получает штрих-код, и информационная система ищет товар с таким штрих- кодом в БД, получает его цену, записывает информацию, что данный товар куплен и одновременно удаляет купленный товар из списка тех, которые есть в наличии.
  #Отдел закупок супермаркета со своей стороны видит, сколько товаров в остатке, и может проанализировать, с какой скоростью товар раскупается, далее принимает решение, сколько товара заказать на следующую неделю.
  #Для сдачи ЕГЭ все школьники должны зарегистрироваться в общероссийской БД. Для этого школы предоставляют информацию об учениках: ФИО, номер удостоверения пенсионного страхования, паспортные данные, регион, школа, выбранные предметы и т. д. После сдачи ЕГЭ в соответствии с определенной технологией комиссии вводят результаты в БД. Затем выпускники и приемные комиссии вузов имеют возможность увидеть эти результаты.
  #
  #В каком виде можно хранить информацию из приведенных ранее примеров?
  #Каким образом обеспечить различные права на доступ и изменение информации для разных сторон, которые используют одну и ту же информацию? Если у нас хранится информация о миллионах товаров или школьников, как обеспечить быстрый поиск нужной информации?
  #Обычные текстовые файлы не могут решить описанные выше задачи по ряду причин:
  #•	любой поиск и изменение данных не эффективны, потому что текстовые файлы требуют последовательного чтения;
  #•	один и тот же объект (товар, ученик) можно описать по-разному, поэтому если использовать естественный язык, то информацию будет очень сложно найти и в принципе провести какой-то анализ или обработку;
  #•	из-за того, что текстовый файл изначально не разделен на части, невозможно обеспечить доступ множества пользователей к отдельным его частям с разным уровнем доступа: кому-то для чтения, кому-то для изменения, причем одновременно.
  #
  #Исторический прорыв в области хранения информации был совершен в 1970 году, когда англичанин Эдгар Кодд из компании IBM предложил реляционную модель данных. С ее появлением пришли понятия «база данных» (БД) и система управления БД (СУБД).
  #Понятно, что можно придумать множество различных способов, как хранить и обрабатывать данные в БД. Этот способ организации данных в БД определяется моделью данных.
  #Модель данных применительно к БД — это некоторые логические правила представления информации в памяти вычислительного устройства.
  #Позже была предложена более универсальная модель «сущность-связь», и Кодд предложил расширенную реляционную модель RM/V2. Модель
  #«сущность-связь» очень легко перекладывается на реляционную модель, которая на данный момент остается самой распространенной и лежит в основе большинства СУБД.
  #
  #Реляционная модель данных — это представление совокупности данных в виде двумерных таблиц.
  #Пусть перед нами стоит задача хранить информацию по сотрудникам некоторой компании. Рассмотрим на примере сущности «Сотрудник». Для проектирования и иллюстрации модели
  #«сущность-связь» широко используют схемы БД, которые аналогичны диаграмме классов UML для отражения ОО модели.
  #У каждой сущности есть ряд свойств, которые ее описывают, — атрибуты. Пусть в нашем примере для каждого сотрудника мы хотим хранить такие поля: «Фамилия», «Имя», «Отчество», «Отдел»,
  #«Должность», «Адрес». Тогда сущность примет вид таблицы:
  #Сотрудник Фамилия Имя Отчество Отдел Должность Адрес
  #
  #Адрес заголовке мы указали наименование сущности, внутри список атрибутов.
  #В реляционной модели этой картинке соответствует таблица «Сотрудник» с столбцами:
  #«Фамилия», «Имя», «Отчество», «Отдел», «Должность», «Оклад».
  #Если мы заполним таблицу набором значений атрибутов, например, по двум сотрудникам, то в терминах реляционной модели мы получим две записи. А таблица имеет 6 полей:
  #
  #
  #
  #
  #
  #
  #
  #Реляционная модель тесно связана с реляционной алгеброй, в терминах которой набор значений атрибутов (запись) носит название кортеж.
  #
  #Каждый объект любой таблицы БД должен быть уникальным, иначе могут быть неприятности, связанные с неоднозначностью размещения одного и того же объекта несколько раз. Убирают эту неоднозначность ключевые поля, которые хранят только уникальную информацию об объекте и никогда не повторяются. Как быть в ситуации, когда в БД у людей полностью совпадают ФИО и дата рождения? Тогда ключом человека может быть серия и номер паспорта, а этого же человека в налоговой службе — ИНН, в пенсионном фонде — номер СНИЛС.
  #
  #Пример с человеком описывает важность ключа, а также тот факт, что один и тот же человек может храниться в разных БД, а значит иметь разные свойства в таблицах. То есть человек один, а сущности разные. Еще примеры ключевых данных: серийный номер изделия, регистрационный номер авто, ну и, конечно же, номер на денежной банкноте, который хранится в БД казначейства и различает одинаковые купюры.
  #Таким образом, у каждой сущности должно быть определено специальное поле — ключ.
  #
  #Ключ — это атрибут или группа атрибутов, значения которых уникальны для каждого экземпляра сущности. Ключ позволяет быстро идентифицировать каждый экземпляр сущности. Для ранее рассмотренного примера одним ключом может быть поле «Табельный номер», он уникален для каждого сотрудника и по нему легко найти конкретного сотрудника:
  #Сотрудник
  #--------------
  #Табельный номер
  #--------------
  #Фамилия Имя Отчество Отдел Должность Адрес
  #
  #В схемах БД для выделения ключевые атрибуты отделяются от остальных чертой либо какими-то знаками (ключиками, звездочками и т. д.).
  #Идеи Кодда на языке таблиц:
  #•	каждая таблица описывает одну сущность/отношение — порядок расположения полей в таблице не имеет значения;
  #•	все значения одного поля имеют одинаковый тип данных;
  #•	в таблице не может быть двух полностью одинаковых записей;
  #•	порядок записей в таблице не определен.
  #
  #При работе с реляционной БД характерно:
  #•	количество и состав полей определяет разработчик БД, пользователи же работают с записями таблицы (добавляют, удаляют, редактируют);
  #•	любое поле должно иметь уникальное имя;
  #•	поля имеют тип (схоже с понятием тип переменной). Как правило, в СУБД можно задать следующие типы полей: строка символов, текст — целое число — вещественное число — денежная сумма — дата, время — логическое поле (истина или ложь, да или нет).
  #Поля могут быть обязательными для заполнения или нет;
  #•	таблица может содержать столько записей, сколько позволяет объем памяти;
  #•	для работы с ними используют язык запросов SQL. Программисты не работают напрямую с файлами БД, для этого используют специальные программы — системы управления базой данных (СУБД), о которых пойдет речь далее
  #
  #Перед нами стоит задача разработать БД для ведения семейного бюджета, главная задача которой фиксировать доходы и расходы семьи, чтобы затем можно было провести их анализ.
  #Начнем с того, что БД должна хранить данные о всех расходах и доходах, то есть какие происходили денежные операции. И для каждой операции еще нужно знать, на что были потрачены деньги или откуда пришли (зарплата, кредит и т. д.). Рассмотрим таблицу «Операция» со следующей структурой:
  #
  #
  #ID — это ключевое поле, поэтому на схеме слева от наименования нарисован ключ.
  #В этой структуре плохо то, что мы храним все детальные операции, но не можем провести их анализ, сгруппировать: например, посчитать, сколько за месяц мы потратили на питание, сколько на транспорт и т. д. Значит, нам нужно указание, из какой категории каждая операция.
  #
  #Данные этой таблицы страдают избыточностью из-за совпадений некоторых значений поля
  #«Категория». Причем, из-за того, что это текстовые поля, будет расходоваться много памяти. Более того, если мы захотим изменить наименование категории, то нам придется сделать это во всех записях таблицы. Убрать избыточность позволит отдельная таблица или таблицы. В нашем случае можно создать таблицу, которая хранит сущность «Категория»:
  #
  #
  #Кроме этого, мы должны связать таблицу операций с категориями. Для этого нужно выяснить, какая из них будет главная, а какая подчиненная. Поскольку таблица «Категория» хранит неповторяющиеся значения, она будет главной, а таблица «Операция» будет подчиненной.
  #Как физически связываются таблицы? Для этого подчиненной таблице добавляют еще одно поле для связи с главной. То есть таблице «Операция» нужно добавить поле ID_категории. Затем свяжем ключевое поле главной таблицы с новым полем подчиненной таблицы. Новое поле подчиненной таблицы называют «внешний ключ» (FOREIGN KEY) и оно отображает информацию, которая хранится в другой таблице, а именно в ключевом поле (PRIMARY KEY) главной таблицы.
  #То ключевое поле главной таблицы называется главным. Для отображения связи между сущностями на схемах БД используют линии:
  #
  #
  #
  #			февраль
  #
  #Что случится, если в таблице «Категория» удалить любую запись? Очевидно, что возникнет проблема в таблице «Операция», потому что для операции по заданному коду категории мы не сможем получить нужную информацию. То есть сущность
  #«Операция» зависима от сущности «Категория». Если в таблице есть внешний ключ, то он должен обязательно совпадать с одним из значений первичного ключа в другой таблице. Это называется соблюдением ссылочной целостности. Современные СУБД имеют различные средства поддержки ссылочной целостности БД. Например, пользователю не разрешат удалить таблицу, если есть таблицы, которые от нее зависят.
  #
  #При проектировании БД и работы с ней очень важно устанавливать связи между таблицами. Не менее важно понимать какого типа эти связи. Рассмотрим основные из них.
  #1.	Связь «один ко многим»
  #На рисунке со схемой БД, соединяющей таблицы, отображены 1 и ∞. Это условное обозначение типа связи 1:М — «один ко многим». Это самая распространенная связь. Связь «один ко многим» означает, что с одной записью в таблице, на стороне которой стоит
  #«1», могут быть связаны сколько угодно записей из другой таблицы, где стоит «∞». То есть во второй таблице может быть несколько записей с одинаковым значением внешнего ключа, что мы и наблюдали.
  #
  #
  #
  #2.	Связь «один к одному»
  #Редко, но встречается связь «1:1», когда каждой записи в первой таблице соответствует 0 или 1 запись в связанной таблице. Это обычно используют для вертикального разделения большой таблицы на две части. Например, сделать часть полей таблицы доступной всем, а остальные поля вынести в другую таблицу и показывать в зависимости от прав пользователя.
  #
  #
  #3.	Связь «многие ко многим»
  #Наиболее сложная, но при этом часто встречаемая связь «M:M». Например, в школе преподаватель может вести несколько предметов и в то же время предмет с таким наименованием могут преподавать несколько учителей.
  #
  #
  #
  #Значит есть сущности «Преподаватель» и «Предмет», между которыми связь «многие ко многим».
  #Реляционные БД не могут на физическом уровне явно реализовать связь «многие ко многим». И действительно, невозможно в плоской таблице к одной записи без ее дублирования привязать разные значения внешнего ключа.
  #Появление при проектировании связи «многие ко многим» всегда говорит о том, что не достает третьей сущности, которая описывает процесс взаимодействия этих двух сущностей.
  #В данном случае явно не хватает сущности «Преподавание». То есть нужно просто ввести новую сущность, которая и будет хранить все нужные соответствия ключей из таблиц
  #«Преподаватель» и «Предмет»:
  #
  #
  #
  #Cистема управления базами данных СУБД (DataBase Management System, DBMS) — программное обеспечение, с помощью которого пользователи могут определять, создавать и поддерживать базу данных, а также получать к ней контролируемый доступ.
  #СУБД — это программа, которая:
  #•	создает БД и редактирует в ней информацию (добавление, удаление и изменение информации);
  #•	позволяет выполнять вычисления над данными;
  #•	предоставляет или ограничивает доступ к БД;
  #•	обеспечивает одновременный доступ к данным для нескольких пользователей;
  #•	обеспечивает целостность БД;
  #•	позволяет восстановить БД в случае сбоя аппаратного или программного обеспечения.
  #
  #В истории вычислительной техники можно проследить развитие двух основных областей ее
  #использования.
  #Первая область — применение вычислительной техники для выполнения численных расчетов, которые слишком долго или вообще невозможно производить вручную. Характерной особенностью данной области применения вычислительной техники является наличие сложных алгоритмов обработки, которые применяются к простым по структуре данным, объем которых, как правило, сравнительно невелик.
  #Вторая область — это использование средств вычислительной техники в автоматических или автоматизированных информационных системах.
  #Информационная система представляет собой программно-аппаратный комплекс, обеспечивающий выполнение следующих функций:
  #•	надежное хранение информации в памяти компьютера;
  #•	выполнение специфических для данного приложения преобразований информации и вычислений;
  #•	предоставление пользователям удобного и легко осваиваемого интерфейса.
  #
  #Обычно такие системы имеют дело с большими объемами информации, имеющей достаточно
  #сложную структуру, поэтому используют БД. Классическими примерами информационных систем являются банковские системы, автоматизированные системы управления предприятиями, системы резервирования авиационных или железнодорожных билетов, мест в гостиницах и т. д.
  #Не стоит путать понятия «информационная система» и СУБД. СУБД и БД являются лишь частями информационной системы. Помимо них в ИС всегда присутствует прикладное программное обеспечение (ПО), которое реализует удобный интерфейс пользователя для работы с данными: формы ввода и поиска, отчеты и т. д.
  #
  #Что это значит? Например, в ИС по продаже билетов можно огромным количеством способов
  #выдавать информацию из БД, но в системе реализуют только те формы и отчеты, которые необходимы, например, отчет, который показывает, сколько и какие свободные места есть в поезде на заданную дату, каким образом можно добраться из пункта, А в пункт Б в определенные даты и т. д.
  #Первые БД основывались на иерархической и сетевой моделях. В 1965 году на конференции CODASYL (Conference on Data Systems Languages) была сформирована рабочая группа Data Base Task Group (DBTG), которая занялась определением спецификаций среды, которая допускала бы разработку баз данных и управление данными. В 1971 году DBTG выделила две группы языков.
  #1.	Язык определения данных (Data Definition Language, DDL), который позволит описать структуру БД.
  #2.	Язык манипулирования данными (Data Manipulation Language, DML), предназначенный для управления данными в БД.
  #Несмотря на то что этот отчет официально не был одобрен Национальным Институтом Стандартизации США (American National Standards Institute — ANSI), большое количество систем было разработано в полном соответствии с этими предложениями группы DBTG. Теперь они называются CODASYL-системами, или DBTG-системами. CODASYL-системы и системы на основе иерархических подходов представляют собой СУБД первого поколения.
  #
  #В 1970 году Э. Ф. Кодд, работавший в корпорации IBM, опубликовал статью о реляционной модели
  #данных, позволявшей устранить недостатки прежних моделей. И это дало начало общеизвестным результатам:
  #•	появился структурированный язык запросов SQL, который стал стандартным языком любых реляционных СУБД;
  #•	в 80-х годах были созданы различные коммерческие реляционные СУБД, например, DB2 или SQL/DS корпорации IBM, Oracle корпорации Oracle, др.
  #
  #Существует множество способов классификации СУБД, рассмотрим наиболее значимые.
  #Локальныe
  #Это самый простой случай, когда прикладное ПО, СУБД и БД находятся на одном устройстве пользователя (например, компьютер, планшет или смартфон). Такой способ реализации хорошо подходит для небольших ИС, где предполагается один пользователь. В ОС Android для создания локальных БД уже встроена СУБД SQLite.
  #Для ОС Windows удобнее использовать СУБД, которые дополнительно предоставляют готовые инструменты для создания прикладной части ИС — средства конструирования интерфейса пользователя (Microsoft Access, OpenOffice Base). Преимущества локальных БД: независимость от работы компьютерных сетей.
  #Недостатки: невозможность работать нескольким пользователям одновременно.
  #
  #
  #Удаленные и распределенные
  #Их реализуют, когда предполагается работа множества пользователей с одной БД. Для этих систем зачастую характерен большой объем хранимых данных, и они строятся на клиент- серверной архитектуре.
  #Отличие между удаленной и распределенной базами данных в том, что для первой характерно размещение СУБД и БД на одном сервере. Распределенная же БД размещается на нескольких серверах.
  #
  #Файл-серверные
  #В файл-серверных СУБД файлы данных располагаются централизованно на файл-сервере. СУБД располагается на каждом клиентском компьютере (рабочей станции). Доступ СУБД к данным осуществляется через локальную сеть. Синхронизация чтений и обновлений осуществляется посредством файловых блокировок. Преимуществом этой архитектуры является низкая нагрузка на процессор файлового сервера. Недостатки: потенциально высокая загрузка локальной сети; затрудненность или невозможность централизованного управления; затрудненность или невозможность обеспечения таких важных характеристик, как высокая надежность, высокая доступность и безопасность. Применяются чаще всего в локальных приложениях, которые используют функции управления БД; в системах с низкой интенсивностью обработки данных и низкими пиковыми нагрузками на БД.
  #
  #На данный момент файл-серверная технология считается устаревшей, а ее использование в крупных информационных системах — недостатком.
  #
  #Файл-серверные
  #В файл-серверных СУБД файлы данных располагаются централизованно на файл-сервере. СУБД располагается на каждом клиентском компьютере (рабочей станции). Доступ СУБД к данным осуществляется через локальную сеть. Синхронизация чтений и обновлений осуществляется посредством файловых блокировок. Преимуществом этой архитектуры является низкая нагрузка на процессор файлового сервера. Недостатки: потенциально высокая загрузка локальной сети; затрудненность или невозможность централизованного управления; затрудненность или невозможность обеспечения таких важных характеристик, как высокая надежность, высокая доступность и безопасность. Применяются чаще всего в локальных приложениях, которые используют функции управления БД; в системах с низкой интенсивностью обработки данных и низкими пиковыми нагрузками на БД.
  #
  #На данный момент файл-серверная технология считается устаревшей, а ее использование в крупных информационных системах — недостатком.
  #
  #Клиент-серверные
  #Главной отличительной чертой построения клиент-серверной СУБД в том, что прикладное ПО (клиент) физически отделено от СУБД и БД. При этом к БД клиент может обращаться только через СУБД.
  #
  #
  #
  #
  #
  #
  #Классификация по способу доступа к БД
  #Клиент-серверные
  #Клиентское приложение на устройстве пользователя по сети отправляет команды (запросы) к СУБД на выполнение различных операций. Команды клиента к СУБД формируются на специальном языке запросов SQL (Structured Query Language — язык структурных запросов).
  #Что делает сервер:
  #•	ожидает запросы от клиентов по сети;
  #•	выставляет запросы в очередь на выполнение;
  #•	выполняет запросы;
  #•	отправляет ответы обратно клиенту.
  #•	В частном случае серверная и клиентская части могут быть установлены на одном компьютере. Недостаток клиент-серверных СУБД состоит в повышенных требованиях к серверу (высокая стоимость). Достоинства: потенциально более низкая загрузка локальной сети; удобство централизованного управления; удобство обеспечения таких важных характеристик, как высокая надежность, высокая доступность и безопасность.
  #Примеры: Oracle, Firebird, Interbase, IBM DB2, MS SQL Server, Sybase Adaptive Server Enterprise, PostgreSQL, MySQL, Caché.
  #
  #Классификация по способу доступа к БД
  #Встраиваемые
  #Встраиваемая СУБД — СУБД, которая может поставляться как составная часть некоторого программного продукта, не требуя процедуры самостоятельной установки. Встраиваемая СУБД предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование
  #в сети. Физически встраиваемая СУБД чаще всего реализована в виде подключаемой библиотеки. Доступ к данным со стороны приложения может происходить через SQL либо через специальные программные интерфейсы.
  #Примеры: SQLite (она часто используется при программировании под Android), BerkeleyDB, Firebird Embedded, Microsoft SQL Server Compact.
  #
  #Введение в SQL
  #Одним из языков, появившихся в результате разработки реляционной модели данных, является язык SQL (Structured Query Language), который в настоящее время получил очень широкое распространение и фактически стал стандартом реляционных баз данных.
  #Язык SQL достаточно компактен, содержит небольшое количество команд.
  #Запись SQL-операторов
  #Идентификаторы языка SQL предназначены для обозначения объектов в базе данных: имен таблиц, столбцов и других объектов базы данных. В соответствии со стандартом SQL идентификатор:
  #•	по умолчанию может содержать строчные и прописные буквы латинского алфавита (A-Z, a-z), цифры (0–9), символ подчеркивания (_);
  #•	может иметь длину до 128 символов;
  #•	должен начинаться с буквы;
  #•	не может содержать пробелы.
  #•	читаемый вид при использовании выравнивания.
  #
  #Оператор CREATE TABLE определяет имя таблицы и множество
  #поименованных столбцов в указанном порядке. Для каждого столбца могут быть определены тип и размер. Каждая создаваемая таблица должна иметь по крайней мере один столбец.
  #Базовый синтаксис оператора создания таблицы имеет следующий вид:
  #CREATE TABLE <имя_таблицы> (<имя_столбца> <тип_данных> [NULL | NOT NULL ] [,...n])
  #Здесь и далее квадратные скобки используются для необязательных частей конструкции, то есть сами квадратные скобки не пишутся, а то, что в них, можно опускать. Угловые скобки тоже не пишутся, а указывают на тип данных, вместо которых нужно подставить реальные значения, например, имя таблицы.
  #Конструкция NOT NULL обозначает, что поле должно быть обязательно заполнено.
  #
  #Создать таблицу для хранения данных о товарах. Необходимо учесть такие
  #сведения, как название, тип товара и его цену.
  #CREATE TABLE Product (
  #id INTEGER PRIMARY KEY AUTOINCREMENT, Name TEXT NOT NULL UNIQUE,
  #Price REAL
  #)
  #Обратите внимание на поле id. Это поле встречается в таблицах SQL
  #и является первичным ключом, однозначно определяет объект, в нашем случае — товар.
  #Первый столбец обозначен, как primary key (первичный ключ), это понятие мы уже разобрали в предыдущей теме. Слово autoincrement указывает, что база данных будет автоматически увеличивать значение ключа при добавлении каждой записи, что и обеспечивает его уникальность (поле — счетчик).
  #
  #В SQLite существует договоренность первый столбец всегда называть _id, это
  #не жесткое требование SQLite, однако может понадобиться при использовании контент-провайдера в Android.
  #Возможные типы полей:
  #TEXT — строки или символы в кодировке UTF-8, UTF-16BE или UTF-16LE; INTEGER — целое число;
  #REAL — дробное число;
  #BLOB — бинарные данные; TIMESTAMP — метка времени; NULL — пустое значение.
  #
  #В SQLite отсутствует тип, работающий с датами. Можно использовать
  #строковые значения, например, как 2015-02-16 (16 февраля 2015 года). Для даты со временем рекомендуется использовать формат 2015-02-16T07:58. В таких случаях можно использовать некоторые функции SQLite для добавления дней, установки начала месяца и т. д. Учтите, что SQLite не поддерживает часовые пояса. Также не поддерживается тип boolean.
  #Используйте числа 0 для false и 1 для true. Не используйте тип BLOB для хранения данных (картинки) в Android. Лучше хранить в базе путь к изображениям, а сами изображения хранить в файловой системе.
  #Как было отмечено выше, SQLite поддерживает типы TEXT (аналог String в Java), INTEGER (аналог long в Java) и REAL (аналог double в Java). Остальные типы следует конвертировать, прежде чем сохранять в базе данных. SQLite сама по себе не проверяет типы данных, поэтому вы можете записать целое число в колонку, предназначенную для строк и наоборот.
  #
  #Оператор INSERT применяется для добавления записей в таблицу. Формат
  #оператора:
  #INSERT INTO <имя_таблицы> [(имя_столбца [,...n])] {VALUES (значение[,...n])|
  #<SELECT_оператор>}
  #Первая форма оператора INSERT с параметром VALUES предназначена для вставки единственной строки в указанную таблицу. Список столбцов указывает столбцы, которым будут присвоены значения в добавляемых записях. Список может быть опущен, тогда подразумеваются все столбцы таблицы (кроме объявленных как счетчик), причем в определенном порядке, установленном при создании таблицы.
  #
  #Если в операторе INSERT указывается конкретный список имен полей, то
  #любые пропущенные в нем столбцы должны быть объявлены при создании таблицы как допускающие значение NULL, за исключением тех случаев, когда при описании столбца использовался параметр DEFAULT. Список значений должен следующим образом соответствовать списку столбцов:
  #•	количество элементов в обоих списках должно быть одинаковым;
  #•	должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй — ко второму столбцу и т. д.;
  #•	типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы.
  #
  #Добавить в таблицу Product новую запись:
  #INSERT INTO Product (Name, Price) VALUES ("Ливерная колбаса", 50.70)
  #Если столбцы таблицы Product указаны в полном составе и в том порядке, в котором они перечислены при создании, оператор можно упростить: INSERT INTO Товар VALUES ("Ливерная колбаса", 50.70)
  #Можно добавить сразу несколько записей в одном запросе
  #INSERT INTO Товар VALUES ("Ливерная колбаса", 50.70), ("Докторская колбаса", 60.80)
  #Обычно такой запрос выполняется быстрее, чем два отдельных запроса.
  #
  #SELECT
  #Оператор SELECT — один из наиболее важных и самых распространенных операторов SQL. Он позволяет производить выборки данных из таблиц
  #и преобразовывать к нужному виду полученные результаты. Оператор SELECT
  #имеет следующий формат:
  #SELECT [ALL | DISTINCT ] {*|[имя_столбца [AS новое_имя]]} [,...n] FROM имя_таблицы [[AS] псевдоним] [,...n] [WHERE <условие_поиска>] [GROUP BY имя_столбца [,...n]] [HAVING <критерии выбора групп>] [ORDER BY имя_столбца [,...n]]
  #Оператор SELECT определяет поля (столбцы), которые будут входить в результат выполнения запроса. В списке они разделяются запятыми
  #и приводятся в такой очередности, в какой должны быть представлены
  #в результате запроса. Символом * можно выбрать все поля, а вместо имени поля применить выражение из нескольких имен.
  #
  #Предложение FROM задает имена таблиц и представлений, которые
  #содержат поля, перечисленные в операторе SELECT. Необязательный параметр псевдонима — это сокращение, устанавливаемое для имени таблицы.
  #Обработка элементов оператора SELECT выполняется в следующей последовательности:
  #1.	FROM — определяются имена используемых таблиц;
  #2.	WHERE — выполняется фильтрация строк объекта в соответствии с заданными условиями;
  #3.	GROUP BY — образуются группы строк, имеющих одно и то же значение в указанном столбце;
  #4.	HAVING — фильтруются группы строк объекта в соответствии с указанным условием;
  #5.	SELECT — устанавливается, какие столбцы должны присутствовать в выходных данных;
  #6.	ORDER BY — определяется упорядоченность результатов выполнения операторов.
  #
  #Порядок предложений и фраз в операторе SELECT не может быть изменен.
  #Только два предложения SELECT и FROM являются обязательными, все остальные могут быть опущены. SELECT — закрытая операция: результат запроса к таблице представляет собой другую таблицу.
  #Составить список всех данных о всех продуктах.
  #SELECT * FROM Product
  #Составить список названий всех продуктов.
  #SELECT Name FROM Product
  #Результат выполнения запроса может содержать дублирующиеся значения. Для исключения дублирования используют предикат DISTINCT. Необходимо помнить, что использование DISTINCT может резко замедлить выполнение запросов. Откорректированный пример выглядит следующим образом:
  #SELECT DISTINCT Name FROM Product
  #
  #SELECT * FROM WHERE…
  #С помощью WHERE-параметра пользователь определяет, какие строки появятся в результате запроса. За ключевым словом WHERE следует перечень условий поиска, определяющих те строки, которые должны быть выбраны при выполнении запроса.
  #Существует пять основных типов условий поиска (или предикатов).
  #1.	Сравнение: сравниваются результаты вычисления одного выражения с результатами вычисления другого.
  #2.	Диапазон: проверяется, попадает ли результат вычисления выражения в заданный диапазон значений.
  #3.	Принадлежность множеству: проверяется, принадлежит ли результат вычислений выражения заданному множеству значений.
  #4.	Соответствие шаблону: проверяется, отвечает ли некоторое строковое значение заданному шаблону.
  #5.	Значение NULL: проверяется, содержит ли данный столбец определитель
  #NULL (неизвестное значение).
  #
  #SELECT, сравнение
  #В языке SQL можно использовать следующие операторы сравнения:
  #= — равенство;
  #< — меньше;
  #> — больше;
  #<= — меньше или равно;
  #>= — больше или равно;
  #<> — не равно.
  #Показать все товары, стоимостью более 100.
  #SELECT * FROM Product WHERE Price > 100
  #В выражениях можно использовать логические операторы AND, OR или NOT,
  #а также скобки.
  #Вывести список товаров, цена которых больше 100 и меньше или равна 200.
  #SELECT
  #FROM Product
  #WHERE Price > 100 AND Price <= 200
  #
  #SELECT, соответствие шаблону
  #С помощью оператора LIKE можно выполнять сравнение выражения с
  #заданным шаблоном, в котором допускается использование символов- заменителей:
  #•	символ % — вместо этого символа может быть подставлено любое количество произвольных символов;
  #•	символ _ — заменяет один символ строки;
  #•	[] — вместо символа строки будет подставлен один из возможных символов, указанный в этих ограничителях;
  #•	[^] — вместо соответствующего символа строки будут подставлены все символы, кроме указанных в ограничителях.
  #Например, вывести список колбас и сыров:
  #SELECT Name, Price FROM Product
  #WHERE Name LIKE "Cыр%" OR
  #Name LIKE "Колбаса%"
  #Обратите внимание. Вместо союза «и», который мы использовали в русском языке, нужно использовать «OR», то есть «или».
  #
  #SELECT, диапазон
  #Оператор BETWEEN используется для поиска значения внутри некоторого интервала, определяемого своими минимальным и максимальным значениями. При этом указанные значения включаются в условие поиска.
  #Например, вывести список товаров, цена которых лежит в диапазоне от 100 до 150
  #SELECT Name, Price FROM Product
  #WHERE Price BETWEEN 100 And 150
  #Например, вывести список товаров, цена которых НЕ лежит в диапазоне от 100 до 150.
  #SELECT Name, Price FROM Product
  #WHERE Price NOT BETWEEN 100 AND 150
  #
  #SELECT, принадлежность множеству
  #Оператор IN используется для сравнения некоторого значения со списком заданных значений, при этом проверяется, соответствует ли результат вычисления выражения одному из значений в предоставленном списке. При помощи оператора IN может быть достигнут тот же результат, что и в случае применения оператора OR, однако оператор IN выполняется быстрее.
  #Например:
  #SELECT Name, Price FROM Product
  #WHERE Name IN ("Сырок Глазированный", "Сыр домашний")
  #
  #SELECT, значение NULL
  #Оператор IS NULL используется для сравнения текущего значения со значением NULL — специальным значением, указывающим на отсутствие любого значения.
  #Например, вывести товары с неуказанными ценами.
  #SELECT Name FROM Product WHERE Price IS NULL
  #IS NOT NULL используется для проверки присутствия значения в поле.
  #
  #SELECT, ORDER BY
  #В общем случае строки в результирующей таблице SQL-запроса никак не упорядочены. Однако их можно требуемым образом отсортировать, для чего в оператор SELECT помещается фраза ORDER BY. Сортировка может выполняться по нескольким полям, в этом случае они перечисляются за ключевым словом ORDER BY через запятую.
  #Например, вывести список продуктов в алфавитном порядке:
  #SELECT Name FROM Product ORDER BY Name
  #Например, вывести список продуктов от самого дорогого до самого дешевого:
  #SELECT Name, Price FROM Product ORDER BY Price DESC
  #
  #UPDATE
  #Оператор UPDATE применяется для изменения значений в группе записей или в одной записи указанной таблицы.
  #Формат оператора:
  #UPDATE имя_таблицы SET имя_столбца=<выражение>[,...n] [WHERE <условие_отбора>]
  #Например, установить нулевую цену для товаров с неуказанной ценой:
  #UPDATE Product SET Price = 0 WHERE Price IS NULL Например, увеличить цену дешевых товаров на 25%: UPDATE Product SET Price = Price*1.25 WHERE Price < 10
  #
  #DELETE
  #Оператор DELETE предназначен для удаления группы записей из таблицы. Формат оператора:
  #DELETE
  #FROM <имя_таблицы>[WHERE <условие_отбора>]
  #Например, удалить все записи о товарах:
  #DELETE FROM Product
  #В документации по SQLite указано, что не поддерживаются конструкции SQL, которые позволяют удалить или изменить существующий столбец в таблице (например, его имя или тип). Но можно прибегнуть к «хитрости»: создать другую таблицу, скопировав в нее нужные данные из старой, например:
  #
  #DELETE
  #-- создаем временную таблицу
  #CREATE TEMPORARY TABLE Temper_backup(name,temp);
  #-- копируем данные из таблицы Temper во временную таблицу Temper_backup
  #INSERT INTO Temper_backup SELECT name,temp FROM Temper;
  #-- удаляем таблицу Temper
  #DROP TABLE Temper;
  #-- создаем таблицу Temper
  #CREATE TABLE Temper(name,NEW);
  #-- вставляем данные из таблицы Temper_backup в таблицу Temper
  #INSERT INTO Temper SELECT name,temp FROM Temper_backup;
  #-- удаляем таблицу Temper_backup
  #DROP TABLE Temper_backup;
  #
  #Агрегированные запросы
  #С помощью итоговых (агрегатных) функций запроса можно получить статистические сведения о множестве отобранных значений выходного набора.
  #Пользователю доступны следующие основные итоговые функции:
  #•	Count (выражение) — определяет количество записей в выходном наборе SQL-запроса;
  #•	Min/Max (выражение) — определяет наименьшее и наибольшее из множества значений в некотором поле запроса;
  #•	Avg (выражение) — эта функция позволяет рассчитать среднее значение множества значений, хранящихся в определенном поле отобранных запросом записей. Оно является арифметическим средним значением, то есть суммой значений, деленной на их количество;
  #•	Sum (выражение) — вычисляет сумму множества значений, содержащихся в определенном поле отобранных запросом записей.
  #
  #Агрегированные запросы
  #Все эти функции оперируют со значениями в единственном столбце таблицы или с арифметическим выражением и возвращают единственное значение.
  #Функции COUNT, MIN и MAX применимы как к числовым, так и к нечисловым полям, тогда как функции SUM и AVG могут использоваться только в случае числовых полей. При вычислении результатов любых функций сначала исключаются все пустые значения, после чего требуемая операция применяется только к оставшимся конкретным значениям столбца.
  #Вариант COUNT(*) — особый случай использования функции COUNT, его назначение состоит в подсчете всех строк в результирующей таблице, независимо от того, содержатся там пустые, дублирующиеся или любые другие значения.
  #Если до применения обобщающей функции необходимо исключить дублирующиеся значения, следует перед именем столбца в определении функции поместить ключевое слово DISTINCT. Оно не имеет смысла для функций MIN и MAX, однако его использование может повлиять
  #на результаты выполнения функций SUM и AVG, поэтому необходимо заранее обдумать, должно ли оно присутствовать в каждом конкретном случае.
  #
  #Агрегированные запросы
  #Агрегатные функции используются в запросах SELECT. Например, вывести первый товар по алфавиту:
  #SELECT MIN(Name)
  #FROM Product
  #Например, определить количество товаров:
  #SELECT COUNT(*)
  #
# Корутины в Kotlin — это шаблон проектирования конкурентности для асинхронного программирования в последовательной манере. Это способ написания асинхронного, неблокирующего кода, который похож на синхронный, понятнее и проще в сопровождении. Корутинами разработчики выполняют длительные задачи, такие как сетевые запросы и операции дискового вводавывода, без блокировки основного потока или создания многочисленных потоков.
  #
  #Одно из ключевых отличий корутин от потоков — расход ресурсов. Потоки — это тяжеловесные ресурсы операционной системы, поэтому создавать новый поток для каждой параллельно выполняемой задачи очень затратно и неэффективно, особенно на платформах с ограниченными ресурсами, например в мобильных устройствах.
  #Корутины же легковесны и запускаются сотнями или тысячами без больших накладных расходов.
  #
  #Другое важное отличие — модель программирования. Потоки обычно придерживаются модели приоритетной многозадачности: когда переключаться между потоками, определяется планировщиком операционной системы. При некорректном управлении это чревато непредсказуемым поведением и потенциальными состояниями гонки.
  #Корутины же придерживаются модели кооперативной многозадачности с явно определяемыми точками приостановки, в которых управление передается между корутинами. Этим обеспечивается более предсказуемое, детерминированное поведение, упрощается управление конкурентностью.
  #Кроме того, в корутинах имеется встроенная поддержка структурированной конкурентности, благодаря чему разработчики управляют ими в иерархическом порядке, распределяя на области. Так предотвращаются утечки ресурсов, обеспечивается корректная их очистка при отмене или завершении корутин.
  #Многозадачность (от англ. multitasking) — свойство операционной системы или среды выполнения обеспечивать возможность параллельной обработки нескольких задач.
  #Существует два типа многозадачности:
  #•	Процессная многозадачность (основанная на процессах — одновременно выполняющихся программах). Здесь программа — наименьший элемент управляемого кода, которым может управлять планировщик операционной системы. Более известна большинству пользователей (работа в текстовом редакторе и прослушивание музыки).
  #•	Поточная многозадачность (основанная на потоках). Наименьший элемент управляемого кода — поток (одна программа может выполнять 2 и более задачи одновременно).
  #Резюме:
  #Конкурентное программирование реализуется потоками (Threads) и корутинами (Coroutines), но последние легковеснее, эффективнее и предсказуемее в написании асинхронного кода на языке Kotlin.
  #У корутин выше уровень абстракции для управления конкурентностью, особенно хороши они для асинхронных задач в разработке Android.
  #Конкурентное программирование (КП) — это подход к разработке программного обеспечения (ПО), при котором несколько вычислительных процессов выполняются одновременно, чтобы повысить эффективность и производительность систем.
  #Корутины или СоПрограммы (перевод с англ.) = Со + Программы
  #Co означает Cooperation , а Routines означает функции.
  #Это означает, что когда функции взаимодействуют друг с другом, мы называем это сопрограммами.
  #
  #
  #Давайте разберем это на примере
  #Предположим, у нас есть две функции functionA() и functionB().
  #
  #Давайте разберем это на примере.
  #Предположим, у нас есть две функции functionA() и functionB().
  #fun functionA(case: Int) {	fun functionB(case: Int) { when (case) {	when (case) {
  #1	-> {	1 -> {
  #	taskA1()	taskB1()
  #	functionB(1)	functionA(2)
  #	}	}
  #2	-> {	2 -> {
  #	taskA2()	taskB2()
  #	functionB(2)	functionA(3)
  #	}	}
  #3	-> {	3 -> {
  #	taskA3()	taskB3()
  #	functionB(3)	functionA(4)
  #}	} …	…
  #}	}
  #Затем мы вызываем:
  #functionA(1)
  #Здесь functionA() выполняет taskA1() и далее передает управление функции  function для выполнения taskB1().
  #Далее functionB() выполняет taskB1() и передает управление обратно в функцию functionA() для выполнения taskA2и так далее…
  #Таким образом functionA() и functionB() работают в кооперации.
  #С помощью корутин описанное выше взаимодействие можно реализовать очень легко, без использования when или switch case.
  #
  #Давайте возьмем стандартный вариант использования приложения Android, который выглядит следующим образом:
  #•	получить данные о пользователе с сервера;
  #•	показать информацию о нем в пользовательском интерфейсе.
  #fun fetchAndShowUser() {
  #val user = fetchUser()
  #showUser(user)
  #} fun fetchUser(): User {
  #// make network call
  #// return user
  #}
  #fun showUser(user: User) { // show user
  #}
  #Когда мы вызываем fetchAndShowUser() функцию, она выдает исключение NetworkOnMainThreadException, поскольку сетевой вызов не разрешен в основном потоке.
  #Использование обратного вызова: здесь мы запускаем fetchUser в фоновом потоке и передаем результат с помощью обратного вызова (CallBack):
  #fun fetchAndShowUser() {
  #fetchUser { user ->
  #showUser(user)
  #}
  #}
  #fun fetchUser(callback: (User) -> Unit)) {
  #// make network call on background thread to get user
  #// callback with user callback(user)
  #}
  #fun showUser(user: User) { // show user
  #}
  #Идея коллбэков (обратных вызовов, ориг.: callbacks) состоит в том, чтобы передать одну функцию в качестве параметра другой функции и вызвать ее после завершения процесса.
  #fun postItem(item: Item) {
  #preparePostAsync { token ->
  #submitPostAsync(token, item) { post ->
  #processPost(post)
  #}
  #}
  #}
  #fun preparePostAsync(callback: (Token) -> Unit) {
  #// делает запрос и немедленно возвращается
  #// организует коллбэк для последующего вызова
  #}
  #Давайте рассмотрим еще один пример, в котором у нас есть три вложенных сетевых вызова:
  #fun fetchData() {
  #fetchA { a ->
  #fetchB(a) { b ->
  #fetchC(b) { c ->
  #// do something with c
  #	}	Callback hell в JS:
  #}
  #}
  #}
  #
  #Использование RxJava: подход реактивного программирования. Таким образом мы можем избавиться от вложенного обратного вызова:
  #fetchUser()
  #.subscribeOn(Schedulers.io())
  #.observerOn(AndroidSchedulers.mainThread())
  #.subscribe { user -> showUser(user)
  #}
  #fun fetchUser(): Single<User> {
  #// make network call
  #// emit user
  #}
  #fun showUser(user: User) { // show user
  #}
  #Использование сопрограмм:
  #fun fetchAndShowUser() {
  #GlobalScope.launch(Dispatchers.Main) { val user = fetchUser() // fetch on IO thread
  #showUser(user) // back on UI thread
  #} }
  #suspend fun fetchUser(): User {
  #return withContext(Dispatchers.IO) {
  #// make network call on IO thread
  #// return user
  #}
  #}
  #fun showUser(user: User) {	Написав launch, мы создаем и
  #	// show user	запускаем сопрограмму для
  #}	выполнения задачи.
  #Преимущества использования корутин в разработке Android:
  #1.	Асинхронное программирование. С корутинами просто и интуитивно понятно писать асинхронный код: выполнять длительные задачи, такие как сетевые запросы, операции с базами данных или файловый вводвывод, не блокируя основной поток. Так поддерживается адаптивный пользовательский интерфейс, предотвращаются ANR-ошибки.
  #2.	Лаконичный, удобный для восприятия код. С корутинами асинхронный код пишется в последовательной манере, как синхронный. В итоге он получается чище, удобнее для восприятия и сопровождения по сравнению с традиционными структурами на основе обратных вызовов или вложенными структурами асинхронного кода. Эта четкость достигается в
  #корутинах благодаря приостанавливающим функциям и структурированной конкурентности.
  #3.	Легкость и эффективность. В отличие от потоков, то есть тяжелых ресурсов операционной системы, корутины легковесны и запускаются сотнями или тысячами без больших накладных расходов. Поэтому корутинами эффективнее расходуются ресурсы, особенно на мобильных устройствах, где ресурсы ограничены.
  #4.	Структурированная конкурентность. Благодаря ее поддержке в корутинах, параллельно выполняемые задачи организовываются и управляются в иерархическом порядке. Так корутины корректно распределяются на области и контролируются, за счет чего предотвращается утечка ресурсов, упрощаются обработка ошибок и отмена корутин.
  #5.	Легкая интеграция с функционалом Kotlin — приостанавливающими функциями, построителями и областями корутин. Поэтому разработчикам здесь несложно освоить корутины и асинхронное программирование в целом.
  #6.	Совместимость с имеющимися асинхронными API в Android: LiveData, Room, Retrofit и другими. Они легко интегрируются с кодовыми базами, серьезных архитектурных изменений при этом не требуется. Поэтому корутины проще адаптировать как в новых, так и в имеющихся проектах.
  #7.	Поддержка тестирования асинхронного кода. Благодаря ей написание модульных и интеграционных тестов с корутинами упрощается. В библиотеках вроде kotlinx-coroutines-test имеются утилиты для тестирования — с надежным тестовым покрытием — приостанавливающих функций и кода на основе корутин.
  #
  #Функция приостановки — это функция, которую можно запустить, приостановить и возобновить.
  #
  #Это фундаментальная концепция корутин Kotlin для асинхронного программирования в последовательной, неблокирующей манере.
  #Приостанавливающие функции определяются ключевым словом suspend, выполнение приостанавливается ими без блокирования вызывающего потока. А длительные или асинхронные задачи, такие как сетевые запросы, операции дискового ввода-вывода или запросы к базе данных, выполняются без блокировки основного потока или использования обратных вызовов.
  #Чем приостанавливающие функции отличаются от обычных:
  #1.	Приостановка выполнения
  #Выполнение приостанавливается приостанавливающими функциями в точках приостановки без блокирования потока. Оказываясь в точке приостановки, такая функция может приостановить свое выполнение и освободить поток для выполнения других задач. Когда приостановленная операция завершается, выполнение возобновляется функцией с того места, где было остановлено.
  #2.	Они неблокирующие
  #Приостанавливающие функции — неблокирующие, то есть во время ожидания завершения приостановленной операции вызывающий поток ими не блокируется. Так конкурентные приостанавливающие функции выполняются параллельно, не расходуя дополнительных потоков.
  #
  #3.	Контекст корутины
  #Приостанавливающие функции вызываются только из контекста корутины. Благодаря беспроблемному взаимодействию с этими функциями, асинхронные задачи выполняются корутинами без блокировки.
  #4.	Корутиноцентричное программирование
  #Приостанавливающие функции — основа корутиноцентричного программирования с асинхронными задачами в виде последовательно выполняемых блоков кода внутри корутин. С этими функциями нет необходимости во вложенных обратных вызовах или сложном управлении состояниями, асинхронное программирование упрощается.
  #5.	Интеграция с построителями корутин Асинхронные задачи в корутинах часто выполняются приостанавливающими функциями с помощью построителей корутин launch и async. Этими построителями удобно запускать корутины, которыми выполняются приостанавливающие функции и обрабатываются их приостановка и возобновление.
  #override fun onCreate(savedInstanceState: Bundle?) {
  #super.onCreate(savedInstanceState)
  #GlobalScope.launch(Dispatchers.Main) { val user = fetchUser() // fetch on IO thread
  #showUser(user) // back on UI thread
  #}
  #}
  #suspend fun fetchUser(): User {
  #return withContext(Dispatchers.IO) {
  #// make network call on IO thread
  #// return user
  #}
  #}
  #fun showUser(user: User) { // show user }
  #fetchUser() можно вызвать только из другой функции приостановки или сопрограммы
  #Функция fetchUserбудет() работать в потоке ввода-вывода, поскольку мы использовали Dispatchers.IO с withContext.
  #Функция showUser() будет работать в потоке пользовательского интерфейса, поскольку мы использовали Dispatchers.Main для запуска сопрограммы, из которой он вызывается.
  #Функция withContext() — это функция в корутинах Kotlin, которая позволяет изменить контекст выполнения корутины на другой Dispatcher. Она применяется для того, чтобы выполнить определённый блок кода в заданном потоке  и после этого возвращает результат обратно в исходный контекст.
  #
  #Еще пример:
  #class MainActivity : AppCompatActivity() {
  #override fun onCreate(savedInstanceState: Bundle?) {
  #super.onCreate(savedInstanceState)
  #GlobalScope.launch(Dispatchers.Main) { doSomething() // non-suspend, UI thread doLongRunningTask() // suspend, Default background thread doSomethingElse() // non-suspend, UI thread
  #}
  #}
  #fun doSomething() {
  #}
  #fun doSomethingElse() {
  #}	suspend fun doLongRunningTask() { withContext(Dispatchers.Default) {
  #// code for doing a long running task
  #// Added delay to simulate delay(2000)
  #}
  #}
  #Здесь у нас есть 3 функции, из которых только одна является функцией suspend:
  #•	doSomething(): функция, не требующая приостановки
  #•	doLongRunningTask(): suspend функция
  #•	doSomethingElse(): функция, не требующая приостановки
  #В этом случае не приостанавливаемые функции doSomething() и doSomethingElse()  будут выполняться в потоке пользовательского интерфейса, поскольку мы использовали Dispatchers.Main для запуска сопрограммы, из которой они вызываются.
  #А функция приостановки doLongRunningTask() будет запущена в фоновом потоке по умолчанию, поскольку мы использовали Dispatchers.Default с withContext.
  #Здесь мы запустили сопрограмму с помощью Dispatchers.Main, сначала она запускается с UI Thread, она выполнит функцию doSomething в UI Thread, поскольку это не приостанавливаемая функция. В настоящее время мы можем сказать, что управление находится в руках UI Thread.
  #Затем он столкнется с suspend функцией doLongRunningTask(). Она запускает сопрограмму с фоновым потоком Default, как мы использовали
  #Dispatchers.Default с withContext. В настоящее время мы можем сказать, что управление находится в руках Default Thread.
  #После этого, когда длительная задача будет завершена, управление будет возвращено потоку пользовательского интерфейса, поскольку у нас снова есть функция non-suspend doSomethingElse(). Эта функция будет выполнена в потоке пользовательского интерфейса.
  #Контекст корутины
  #Это набор специфичных для корутины элементов, которыми определяются ее поведение и контекст выполнения: диспетчер, задание, название и другие контекстные элементы.
  #•	Контекст корутины неизменяем, он корректируется построителями корутин и операторами: launch, async, withContext, CoroutineScope.
  #•	Контекст корутины — это такой набор правил и параметров, которыми определяются ее поведение и место выполнения.
  #
  #Диспетчеры
  #Это набор диспетчеров корутины, которым определяются поток или пул потоков, где она выполняется, а также контекст выполнения — например, запускается она в основном потоке, фоновом или в пользовательском пуле потоков.
  #В Kotlin имеются встроенные диспетчеры:
  #•	Dispatchers.Default: оптимизирован для вычислений или задач с интенсивным расходом ресурсов процессора, использованием общего пула фоновых потоков.
  #•	Dispatchers.IO: оптимизирован для задач с ограничением скорости ввода-вывода, таких как сетевые запросы, операции с файлами, доступ к базе данных, для параллельного выполнения конкурентных операций ввода-вывода им используется общий пул фоновых потоков.
  #•	Dispatchers.Main: специфичен для разработки Android, представляет основной поток или поток ПИ, то есть пользовательского интерфейса, используется в операциях ПИ, таких как обновление элементов ПИ или обработка пользовательского ввода.
  #•	Dispatchers.Unconfined: корутины запускаются им без конкретных ограничений в любом потоке, в том числе вызывающем, для разработки Android обычно не рекомендуется из-за непредсказуемого поведения.
  #Dispatchers.Default
  #Нам следует использовать Dispatchers.Default для выполнения задач, интенсивно использующих процессор.
  #Примеры вариантов использования:
  #•	Выполнение сложных вычислений, таких как умножение матриц;
  #•	Выполнение любых операций с большим списком, имеющимся в памяти, например сортировка, фильтрация, поиск и т. д.;
  #•	Применение фильтра к растровому изображению, имеющемуся в памяти, а НЕ путем чтения файла изображения, имеющегося на диске;
  #•	Анализ JSON, имеющегося в памяти, а НЕ чтение JSON-файла, имеющегося на диске;
  #•	Масштабирование растрового изображения, уже имеющегося в памяти, а НЕ путем чтения файла изображения, имеющегося на диске;
  #•	Любые операции с растровым изображением, уже имеющимся в памяти, а НЕ путем чтения файла изображения, имеющегося на диске.
  #
  #Dispatchers.IO
  #Следует использовать Dispatchers.IO для выполнения задач, связанных с дисковым или сетевым вводом-выводом.
  #Примеры вариантов использования:
  #•	Любые сетевые операции, например, совершение сетевого вызова;
  #•	Загрузка файла с сервера;
  #•	Перемещение файла из одного места на диске в другое;
  #•	Чтение из файла;
  #•	Запись в файл;
  #•	Выполнение запроса к базе данных; •	Загрузка общих настроек.
  #Короче говоря, все, что связано с файловыми системами или сетевыми функциями, должно выполняться с помощью, Dispatchers.IO поскольку эти задачи связаны с вводом-выводом.
  #Dispatchers.Main
  #Мы должны использовать Dispatchers.Main для запуска сопрограммы в главном потоке Android. Мы все знаем, где мы используем главный поток Android. В основном в местах, где мы взаимодействуем с пользовательским интерфейсом и выполняем небольшие задачи.
  #Примеры вариантов использования:
  #•	Выполнение задач, связанных с пользовательским интерфейсом;
  #•	Любые небольшие задачи, такие как любые операции над небольшим списком, имеющимся в памяти, например, сортировка, фильтрация, поиск и т. д.
  #Dispatchers.Unconfined
  #Он не меняет поток. При запуске он работает в том потоке, в котором был запущен. При возобновлении он работает в том потоке, который его возобновил.
  #Проще говоря: мы должны использовать его Dispatchers.Unconfined, когда нам все равно, где будет выполняться сопрограмма.
  #
  #В Kotlin есть две функции для запуска сопрограмм:
  #•	launch()
  #•	async()
  #Разница в том, что launch() возвращает Job и не несет никакого результирующего значения, тогда как async() возвращает экземпляр Deferred<T>, который имеет await() функцию, возвращающую результат сопрограммы, подобно тому, как в Java есть future, в котором мы делаем это future.get() для получения результата.
  #Другими словами:
  #•	launch(): создал, запустил и забыл;
  #•	async(): выполнить задачу и вернуть результат.
  #Мы можем использовать запуск следующим образом:
  #GlobalScope.launch(Dispatchers.Default) {
  #// do something and do not return result
  #}
  #Но когда нам нужен результат, нам нужно использовать async():
  #val deferred = GlobalScope.async(Dispatchers.Default) { // do something and return result, for example 10 as a result
  #return@async 10
  #} val result = deferred.await() // result = 10
  #Здесь мы получаем результат, используя функцию await().
  #Функция withContext не создает новую сопрограмму, а только смещает контекст существующей сопрограммы и является функцией приостановки, тогда как launch() и async() создают новую сопрограмму и не являются функциями приостановки.
  #Давайте посмотрим код для withContext:
  #private suspend fun doLongRunningTaskAndDoNotReturnResult() {
  #withContext(Dispatchers.Default) {
  #// your code for doing a long running task
  #// Added delay to simulate delay(10000)
  #}
  #}
  #Или она также может вернуть результат:
  #private suspend fun doLongRunningTask(): Int { return withContext(Dispatchers.Default) {
  #// your code for doing a long running task
  #// Added delay to simulate delay(10000)
  #return@withContext 10
  #}
  #}
  #Функция withContext() как и функция приостановки, может быть вызвана только из функции приостановки или сопрограммы. Таким образом, обе вышеуказанные функции doLongRunningTask() являются suspend функциями.
  #Давайте рассмотрим пример использования вышеуказанной функции:
  #GlobalScope.launch(Dispatchers.Main) { val resultOne = doLongRunningTaskOne()
  #val resultTwo = doLongRunningTaskTwo()
  #showResult(resultOne + resultTwo) // back on UI thread
  #}
  #private suspend fun doLongRunningTaskOne(): Int {
  #return withContext(Dispatchers.Default) {
  #// Added delay to simulate delay(2000)
  #return@withContext 10
  #}
  #}	Здесь примерно через 4000 миллисекунд будет показан результат, так как будет завершена первая задача, а затем начнется
  #// your code for doing a long running task private suspend fun doLongRunningTaskTwo(): Int { return withContext(Dispatchers.Default) { только вторая задача.
  #// your code for doing a long running task
  #// Added delay to simulate delay(2000) return@withContext 10
  #}
  #}
  #Теперь предположим, что нам нужно выполнить обе задачи параллельно, поэтому нам придется запустить две сопрограммы. Итак, мы можем использовать launch или async для запуска сопрограмм. Здесь, поскольку нам нужен результат из задачи, нам придется использовать async как показано ниже:
  #GlobalScope.launch { val deferredOne = async {
  #doLongRunningTaskOne()
  #}
  #val deferredTwo = async {
  #doLongRunningTaskTwo()
  #}
  #val result = deferredOne.await() + deferredTwo.await() showResult(result) // back on UI thread
  #}
  #Здесь мы запускаем две сопрограммы с помощью async(), поэтому обе задачи будут выполняться параллельно. Примерно через 2000 миллисекунд он покажет результат, поскольку обе задачи будут выполняться параллельно.
  #
  #В runBlocking запускается новая корутина, которой блокируется текущий поток, пока она не завершится, и возвращается ее результат:
  #fun main() { runBlocking { println("runBlocking start!") delay(3000)
  #}
  #println("Main run after 3 s.") }	fun main() {
  #GlobalScope.launch { println("launch start!") delay(3000)
  #println("launch end!")
  #}
  #println("Main run immediately")
  #}
  #Результат:
  #runBlocking start!	Результат:
  #Main run immediately
  #Main run after 3 s.
  #Резюме:
  #•	В launch запускается новая корутина, которой асинхронно выполняется задача без возвращения результата, возвращается объект Job — сама корутина для управления и контроля за ее жизненным циклом, например отмены или ожидания завершения корутины.
  #•	В async запускается новая корутина, которой асинхронно выполняется задача и возвращается результат — объект Deferred для получения результата после завершения корутины. обычно применяется для выполнения фоновой задачи и извлечения ее результата, например получения данных из сети или выполнения асинхронных вычислений с интенсивным расходом ресурсов процессора.
  #•	В runBlocking запускается новая корутина, которой блокируется текущий поток, пока она не завершится, и возвращается ее результат с возможностью выполнить код корутины в условиях блокировки вне контекста корутины. Применяется в основном для написания тестового кода или выполнения кода корутины в условиях блокировки вне контекстов корутины. Во избежание блокировки основного потока не используется в производственном коде.
  #Области действия в сопрограммах Kotlin очень полезны, поскольку нам нужно отменить фоновую задачу, как только активность будет уничтожена.
  #В проектах, специфичных для Android, следует использовать пользовательские области действия, созданные с учетом жизненного цикла Activity, ViewModel и т. д.
  #Области действия присутствуют в библиотеках расширения Kotlin.
  #Обязательно добавьте требуемые зависимости в свой проект.
  #GlobalScope — это предопределенная область корутины, доступная глобально во всем приложении. Запущенные в ней корутины не привязаны к жизненному циклу конкретного компонента, например Activity или Fragment, и продолжают выполняться, пока не отменятся явно.
  #GlobalScope удобна для запуска корутин с глобальной областью и длительными задачами, но обычно не рекомендуется для приложений Android, поскольку чревата утечками памяти при некорректной отмене корутин, когда они больше не нужны.
  #CoroutineScope — это пользовательская область корутины, обычно связанная с жизненным циклом конкретного компонента, например Activity или Fragment.
  #Созданием области корутины, привязанной к жизненному циклу компонента, обеспечивается то, что запущенные в этой области корутины автоматически отменяются, когда компонент уничтожается или больше не нужен, благодаря этому предотвращаются утечки памяти.
  #Область корутины создается конструктором CoroutineScope с указанием контекста корутины , например MainScope, IOCoroutineScope, которым определяется контекст выполнения для запускаемых в этой области корутин.
  #LifecycleScope — это предопределенная область корутины из библиотеки AndroidX Lifecycle, привязанная к жизненному циклу конкретного компонента, например Activity или Fragment. Когда компонент уничтожается или больше не находится в активном состоянии, корутины автоматически отменяются этой областью.
  #Доступ к LifecycleScope получается через свойство lifecycleScope, указанное в артефакте lifecycle-runtime-ktx.
  #Вот пример управления областью корутины в приложении Android с LifecycleScope:
  #Например:
  #class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState)
  #lifecycleScope.launch { val user = fetchUser()
  #// show user
  #} }
  #suspend fun fetchUser(): User { return withContext(Dispatchers.IO) {
  #// fetch user
  #// return user
  #}
  #}
  #}	Как только Activity будет уничтожена, задача будет отменена, даже если она выполняется, поскольку мы использовали область действия, привязанную к жизненному циклу
  #Activity.
  #
  #При использовании launch():
  #suspend fetchUserAndSaveInDatabase() {
  #withContext(Dispatchers.IO) {
  #// fetch user
  #// save in database
  #}
  #}
  #GlobalScope.launch(Dispatchers.Main) { try {
  #fetchUserAndSaveInDatabase() // do on IO thread and back to UI Thread
  #} catch (exception: Exception) {
  #Log.d(TAG, "$exception handled !")
  #}
  #}
  #Другой способ — использовать обработчик:
  #Для этого нам нужно создать обработчик исключений, как показано ниже:
  #val handler = CoroutineExceptionHandler { _, exception -> Log.d(TAG, "$exception handled !")
  #}
  #Затем мы можем прикрепить обработчик, как показано ниже:
  #GlobalScope.launch(Dispatchers.Main + handler) { fetchUserAndSaveInDatabase() // do on IO thread and back to UI Thread
  #}
  #Если в fetchUserAndSaveInDatabase() возникнет исключение,то оно будет обработано обработчиком, который мы прикрепили.
  #Рассмотрим еще несколько реальных вариантов использования обработки исключений при разработке Android:
  #launch {
  #try {
  #val users = getUsers() val moreUsers = getMoreUsers() } catch (exception: Exception) {
  #Log.d(TAG, "$exception handled !")
  #}
  #}
  #Если один из сетевых вызовов завершается неудачей, он сразу переходит к catch блоку.
  #Но предположим, что мы хотим вернуть пустой список для сетевого вызова, который не удался, и продолжить с ответом от другого сетевого вызова. Мы можем добавить try-catch блок к индивидуальному сетевому вызову, как показано ниже:
  #launch {
  #val users = try {
  #getUsers()
  #} catch (e: Exception) { emptyList<User>()
  #}
  #val moreUsers = try { getMoreUsers()
  #} catch (e: Exception) { emptyList<User>()
  #} }
  #Таким образом, если возникнет какая-либо ошибка, работа продолжится с пустым списком.
  #
  #А что, если мы хотим делать сетевые вызовы параллельно? Мы можем написать код, как показано ниже, используя функцию async()
  #launch {
  #try {
  #coroutineScope {
  #val usersDeferred = async {  getUsers() } val moreUsersDeferred = async { getMoreUsers() } val users = usersDeferred.await()
  #val moreUsers = moreUsersDeferred.await()
  #}
  #} catch (exception: Exception) {
  #Log.d(TAG, "$exception handled !")
  #} }
  #Теперь, если возникнет какая-либо ошибка сети, она попадет в catch блок.
  #Мы использовали coroutineScope.
  #Но предположим еще раз, что мы хотим вернуть пустой список для сетевого вызова, который не удался, и продолжить с ответом от другого сетевого вызова. Нам придется использовать supervisorScope и добавить try-catch блок к индивидуальному сетевому вызову, как показано ниже:
  #
  #launch {
  #supervisorScope {
  #val usersDeferred = async { getUsers() } val moreUsersDeferred = async { getMoreUsers() }
  #val users = try {
  #usersDeferred.await()
  #} catch (e: Exception) { emptyList<User>()
  #}
  #val moreUsers = try { moreUsersDeferred.await()
  #} catch (e: Exception) { emptyList<User>()
  #}
  #}
  #}
  #Опять же, в этом случае, если возникнет какаялибо ошибка, работа продолжится с пустым списком.
  #
  #Резюме:
  #•	НЕ используя async(), мы можем использовать try-catch или
  #CoroutineExceptionHandler и достичь чего угодно в зависимости от наших вариантов использования;
  #•	При использовании async(), помимо try-catch, у нас есть две опции: coroutineScope и supervisorScope;
  #•	С помощью async() используйте supervisorScope с отдельным параметром try-catch для каждой задачи, когда вы хотите продолжить выполнение других задач, если одна или несколько из них не были выполнены;
  #•	С async, используйте coroutineScope с верхним уровнем try-catch, когда вы НЕ хотите продолжать выполнение других задач, если какая-либо из них не была выполнена.
  #Главное отличие в том, что coroutineScope отменяется всякий раз, когда любой из его потомков выходит из строя. Если мы хотим продолжить выполнение других задач, даже если один из них выходит из строя, мы используем supervisorScope. SupervisorScope не отменяет другие потомки, если один из них выходит из строя.
  #
  #Добавление зависимостей корутин
  #Необходимые зависимости включаются в файл build.gradle проекта Android:
  #implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:x.x.x’
  #Меняем x.x.x на используемую версию корутин Kotlin. 
  #Запуск корутины с диспетчером ввода-вывода
  #Построителем launch запускаем корутину для выполнения фоновых задач. Чтобы задача выполнялась в фоновом потоке, внутри корутины указываем Dispatchers.IO:
  #fun performBackgroundTask() {
  #CoroutineScope(Dispatchers.IO).launch {
  #// Фоновая задача, например сетевой запрос, операции с файлами
  #// ...
  #}
  #}
  #Выполнение фоновой задачи
  #Внутри корутины выполняем фоновую задачу: сетевой запрос, доступ к базе данных, считывание файла — асинхронно, не блокируя корутину, с помощью приостанавливающих функций из библиотек Retrofit, Room или стандартной библиотеки Kotlin:
  #fun performBackgroundTask() {
  #CoroutineScope(Dispatchers.IO).launch { val result = fetchDataFromNetwork() // Пример suspend функции // Результат обрабатываем
  #// ...
  #}
  #}
  #suspend fun fetchDataFromNetwork(): String {
  #// Выполняем сетевой запрос, например, с помощью Retrofit
  #// ...
  #return "Data from network"
  #}
  #
  #Обновление UI в основном потоке (необязательно)
  #Чтобы обновить UI результатом фоновой задачи, переключаемся на Dispatchers.Main с помощью функции withContext:
  #fun performBackgroundTaskAndUpdateUI() {
  #CoroutineScope(Dispatchers.IO).launch { val result = fetchDataFromNetwork() // Пример suspend функции
  #withContext(Dispatchers.Main) { // Обновляем UI результатом
  #// ...
  #}
  #}
  #}
  #Чтобы эффективно управлять ресурсами и предотвращать утечки памяти в длительно выполняемых или фоновых задачах, необходимо корректно отменять корутины Kotlin.
  #Вот как отменяют корутины согласно лучшим практикам для приложений Android:
  #•	Вызовом функции cancel() в объекте Job, так корутина отменяется со всеми дочерними корутинами:
  #val job = CoroutineScope(Dispatchers.Default).launch { // Тело корутины
  #}
  #// Отменяем корутину job.cancel()
  #•	Отменой области CoroutineScope мы отменяем все запущенные в ней корутины:
  #val scope = CoroutineScope(Dispatchers.Default) val job1 = scope.launch {
  #// Корутина 1
  #}
  #val job2 = scope.launch {
  #// Корутина 2
  #}
  #// Отменяем все запущенные в области корутины scope.cancel()
  #•	Явной обработкой отмены дочерних корутин, запущенные заданием супервизора дочерние корутины не отменяются при отмене родительской:
  #val supervisor = SupervisorJob()
  #val scope = CoroutineScope(Dispatchers.Default + supervisor) val job1 = scope.launch {
  #// Корутина 1
  #}
  #val job2 = scope.launch {
  #// Корутина 2
  #}
  #// Отменяем только одну // из дочерних корутин job1.cancel()
  #
  #•	Корректной обработкой отмены в корутинах. Отменена ли корутина, проверяем в ее свойстве isActive:
  #val job = CoroutineScope(Dispatchers.Default).launch {
  #while (isActive) {
  #// Выполняем задачу
  #}
  #}
  #•	Применением структурированной конкурентности, когда корутины запускаются в привязанной к жизненному циклу компонента ограниченной области, например CoroutineScope, которой обеспечивается их автоматическая отмена, когда компонент уничтожается или больше не нужен, благодаря этому предотвращаются утечки памяти:
  #class MyViewModel : ViewModel() {
  #private val viewModelScope = CoroutineScope(Dispatchers.Main) fun performBackgroundTask() {
  #viewModelScope.launch { // Тело корутины
  #} }
  #override fun onCleared() {
  #super.onCleared()
  #viewModelScope.cancel() // Отменяем все корутины, когда «ViewModel»
  #очищен
  #}
  #}
  #•	Обработкой исключений CancellationException отмены корутины, выбрасываемых во время выполнения приостанавливающей функции, они обрабатываются блоками try/catch или вызовом функции resumeWithException() из CancellableContinuation:
  #val job = CoroutineScope(Dispatchers.Default).launch { try {
  #// Выполняем задачу
  #} catch (e: CancellationException) {
  #// Обрабатываем отмену